{"version":3,"names":["attributesParsers","id_DomainNameBeneficiary","DomainNameBeneficiary","id_DomainNameLegalRepresentative","DomainNameLegalRepresentative","id_DomainNameOwner","DomainNameOwner","id_DomainNameTechnicalOperator","DomainNameTechnicalOperator","id_TypeRelationship","TypeRelationship","id_ActivityDescription","ActivityDescription","id_WebGDPR","WebGDPR","id_InsuranceValue","InsuranceValue","id_ValuationRanking","ValuationRanking","id_pkcs9_at_challengePassword","ChallengePassword","id_pkcs9_at_unstructuredName","UnstructuredName","id_pkcs9_at_extensionRequest","ExtensionRequest","Attribute","AsnData","getAsnExtnValue","this","asn","values","constructor","raw","super","AsnAttribute","asnExtnValue","target","type","value","AsnParser","parse","console","warn","Convert","ToHex","error","message","X509AttributeCertificate","certificateRawToBuffer","AttributeCertificate","thumbprints","acinfo","serialNumber","version","notBefore","attrCertValidityPeriod","notBeforeTime","Error","notAfter","notAfterTime","validity","dateDiff","issuer","v1Form","_a","v2Form","issuerName","holder","signature","signatureValue","signatureAlgorithm","algorithm","parseExtensions","extensions","map","e","Extension","AsnConvert","serialize","parseAttributes","attributes","getThumbprint","thumbprint","getCertificateThumbprint","exportAsBase64","ToBase64","exportAsHexFormatted","hexFormat","exportAsPemFormatted","base64Format","commonName","downloadAsPEM","name","Download","attrCert","asPEM","downloadAsDER","asDER","CSR","CertificationRequest","certificationRequestInfo","subject","Name","toJSON","publicKey","subjectPublicKey","subjectPKInfo","params","id_ecPublicKey","parameters","ECParameters","id_rsaEncryption","RSAPublicKey","spki","i","length","shortName","extensionRequestAttribute","find","attribute","csr","CRL","CertificateList","tbsCertList","lastUpdate","thisUpdate","getTime","nextUpdate","revokedCertificates","revokedCertificate","revocationDate","userCertificate","crlEntryExtensions","crlExtensions","crl"],"sources":["src/crypto/attribute.ts","src/crypto/x509_attribute_certificate.ts","src/crypto/csr.ts","src/crypto/crl.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) Peculiar Ventures, LLC.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { Convert } from 'pvtsutils';\nimport { AsnParser } from '@peculiar/asn1-schema';\nimport { Attribute as AsnAttribute } from '@peculiar/asn1-x509';\nimport {\n  id_DomainNameBeneficiary,\n  DomainNameBeneficiary,\n\n  id_DomainNameLegalRepresentative,\n  DomainNameLegalRepresentative,\n\n  id_DomainNameOwner,\n  DomainNameOwner,\n\n  id_DomainNameTechnicalOperator,\n  DomainNameTechnicalOperator,\n\n  id_TypeRelationship,\n  TypeRelationship,\n\n  id_ActivityDescription,\n  ActivityDescription,\n\n  id_WebGDPR,\n  WebGDPR,\n\n  id_InsuranceValue,\n  InsuranceValue,\n\n  id_ValuationRanking,\n  ValuationRanking,\n} from '@peculiar/asn1-ntqwac';\nimport {\n  id_pkcs9_at_extensionRequest,\n  ExtensionRequest,\n\n  id_pkcs9_at_challengePassword,\n  ChallengePassword,\n\n  id_pkcs9_at_unstructuredName,\n  UnstructuredName,\n} from '@peculiar/asn1-pkcs9';\n\nimport { AsnData } from './asn_data';\n\nconst attributesParsers = {\n  [id_DomainNameBeneficiary]: DomainNameBeneficiary,\n  [id_DomainNameLegalRepresentative]: DomainNameLegalRepresentative,\n  [id_DomainNameOwner]: DomainNameOwner,\n  [id_DomainNameTechnicalOperator]: DomainNameTechnicalOperator,\n  [id_TypeRelationship]: TypeRelationship,\n  [id_ActivityDescription]: ActivityDescription,\n  [id_WebGDPR]: WebGDPR,\n  [id_InsuranceValue]: InsuranceValue,\n  [id_ValuationRanking]: ValuationRanking,\n  [id_pkcs9_at_challengePassword]: ChallengePassword,\n  [id_pkcs9_at_unstructuredName]: UnstructuredName,\n  [id_pkcs9_at_extensionRequest]: ExtensionRequest,\n};\n\ntype TAttributeKeys = keyof typeof attributesParsers;\nexport type TAttributeValue = InstanceType<typeof attributesParsers[TAttributeKeys]> | string;\n\nexport class Attribute<T extends TAttributeValue> extends AsnData<AsnAttribute> {\n  public readonly value: T;\n\n  private getAsnExtnValue() {\n    return this.asn.values[0];\n  }\n\n  constructor(raw: BufferSource) {\n    super(raw, AsnAttribute);\n\n    const asnExtnValue = this.getAsnExtnValue();\n\n    try {\n      const target = attributesParsers[this.asn.type];\n\n      if (target) {\n        this.value = AsnParser.parse<T>(asnExtnValue, target);\n      } else {\n        console.warn(`Didn't detect parser for \"${this.asn.type}\" attribute.`);\n\n        this.value = Convert.ToHex(asnExtnValue) as T;\n      }\n    } catch (error) {\n      console.error(`Error parse \"${this.asn.type}\" attribute:`, error.message);\n\n      this.value = Convert.ToHex(asnExtnValue) as T;\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) Peculiar Ventures, LLC.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { AsnConvert } from '@peculiar/asn1-schema';\nimport type { GeneralName } from '@peculiar/asn1-x509';\nimport { AttributeCertificate, Holder } from '@peculiar/asn1-x509-attr';\nimport { Convert } from 'pvtsutils';\n\nimport { dateDiff, Download } from '../utils';\n\nimport { AsnData } from './asn_data';\nimport { Extension, TExtensionValue } from './extension';\nimport { Attribute, TAttributeValue } from './attribute';\nimport {\n  certificateRawToBuffer,\n  hexFormat,\n  base64Format,\n  getCertificateThumbprint,\n} from './utils';\n\ninterface ISignature {\n  algorithm: string;\n  value: BufferSource;\n}\n\nexport class X509AttributeCertificate extends AsnData<AttributeCertificate> {\n  public readonly serialNumber: string;\n\n  public readonly version: number;\n\n  public readonly notBefore: Date;\n\n  public readonly notAfter: Date;\n\n  public readonly validity: string;\n\n  public extensions: Extension<TExtensionValue>[];\n\n  public attributes: Attribute<TAttributeValue>[];\n\n  public thumbprints: Record<string, string> = {};\n\n  public readonly issuer: GeneralName[];\n\n  public holder: Holder;\n\n  public type: string = 'X.509 Attribute Certificate';\n\n  constructor(raw: string) {\n    super(certificateRawToBuffer(raw), AttributeCertificate);\n\n    const { acinfo } = this.asn;\n\n    this.serialNumber = Convert.ToHex(acinfo.serialNumber);\n    this.version = acinfo.version;\n\n    const notBefore = acinfo.attrCertValidityPeriod.notBeforeTime;\n\n    if (!notBefore) {\n      throw new Error(\"Cannot get 'notBefore' value\");\n    }\n\n    this.notBefore = notBefore;\n\n    const notAfter = acinfo.attrCertValidityPeriod.notAfterTime;\n\n    if (!notAfter) {\n      throw new Error(\"Cannot get 'notAfter' value\");\n    }\n\n    this.notAfter = notAfter;\n    this.validity = dateDiff(this.notBefore, this.notAfter);\n    this.issuer = acinfo.issuer.v1Form || acinfo.issuer.v2Form?.issuerName;\n    this.holder = acinfo.holder;\n  }\n\n  public get signature(): ISignature {\n    const { signatureValue, signatureAlgorithm } = this.asn;\n\n    return {\n      value: signatureValue,\n      algorithm: signatureAlgorithm.algorithm,\n    };\n  }\n\n  public parseExtensions() {\n    const { acinfo } = this.asn;\n\n    if (acinfo.extensions) {\n      this.extensions = acinfo.extensions\n        .map((e) => new Extension(AsnConvert.serialize(e)));\n    }\n  }\n\n  public parseAttributes() {\n    const { acinfo } = this.asn;\n\n    if (acinfo.attributes) {\n      this.attributes = acinfo.attributes\n        .map((e) => new Attribute(AsnConvert.serialize(e)));\n    }\n  }\n\n  public async getThumbprint(\n    algorithm: string = 'SHA-1',\n  ): Promise<void> {\n    try {\n      const thumbprint = await getCertificateThumbprint(algorithm, this.raw);\n\n      if (thumbprint) {\n        this.thumbprints[algorithm] = Convert.ToHex(thumbprint);\n      }\n    } catch (error) {\n      console.error('Error thumbprint get:', error);\n    }\n  }\n\n  public exportAsBase64() {\n    return Convert.ToBase64(this.raw);\n  }\n\n  public exportAsHexFormatted() {\n    return hexFormat(Convert.ToHex(this.raw));\n  }\n\n  public exportAsPemFormatted() {\n    return `-----BEGIN ATTRIBUTE CERTIFICATE-----\\n${base64Format(this.exportAsBase64())}\\n-----END ATTRIBUTE CERTIFICATE-----`;\n  }\n\n  public get commonName(): string {\n    return `attribute-certificate-${this.thumbprints['SHA-1']}`;\n  }\n\n  public downloadAsPEM(name?: string) {\n    Download.attrCert.asPEM(\n      this.exportAsPemFormatted(),\n      name || this.commonName,\n    );\n  }\n\n  public downloadAsDER(name?: string) {\n    Download.attrCert.asDER(\n      this.exportAsHexFormatted(),\n      name || this.commonName,\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) Peculiar Ventures, LLC.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { AsnConvert } from '@peculiar/asn1-schema';\nimport { ECParameters, id_ecPublicKey } from '@peculiar/asn1-ecc';\nimport { id_rsaEncryption, RSAPublicKey } from '@peculiar/asn1-rsa';\nimport { CertificationRequest } from '@peculiar/asn1-csr';\nimport {\n  id_pkcs9_at_extensionRequest,\n  ExtensionRequest,\n} from '@peculiar/asn1-pkcs9';\nimport { Convert } from 'pvtsutils';\n\nimport { Download } from '../utils';\n\nimport { AsnData } from './asn_data';\nimport { Name, INameJSON } from './name';\nimport { Attribute, TAttributeValue } from './attribute';\nimport { Extension, TExtensionValue } from './extension';\nimport {\n  certificateRawToBuffer,\n  hexFormat,\n  base64Format,\n  getCertificateThumbprint,\n} from './utils';\n\ninterface ISignature {\n  algorithm: string;\n  value: BufferSource;\n}\n\ninterface IPublicKey {\n  algorithm: string;\n  value: BufferSource;\n  params?: ECParameters | RSAPublicKey;\n}\n\nexport class CSR extends AsnData<CertificationRequest> {\n  public readonly subject: INameJSON[];\n\n  public readonly version: number;\n\n  public attributes: Attribute<TAttributeValue>[];\n\n  public extensions: Extension<TExtensionValue>[];\n\n  public thumbprints: Record<string, string> = {};\n\n  public type: string = 'PKCS#10 Certificate Request';\n\n  constructor(raw: string) {\n    super(certificateRawToBuffer(raw), CertificationRequest);\n\n    const { certificationRequestInfo } = this.asn;\n\n    this.subject = new Name(certificationRequestInfo.subject).toJSON();\n    this.version = certificationRequestInfo.version;\n  }\n\n  public get publicKey(): IPublicKey {\n    const { subjectPublicKey, algorithm } = this.asn.certificationRequestInfo.subjectPKInfo;\n    let params;\n\n    if (algorithm.algorithm === id_ecPublicKey && algorithm.parameters) {\n      params = AsnConvert.parse(algorithm.parameters, ECParameters);\n    }\n\n    if (algorithm.algorithm === id_rsaEncryption) {\n      params = AsnConvert.parse(subjectPublicKey, RSAPublicKey);\n    }\n\n    const spki = AsnConvert.serialize(this.asn.certificationRequestInfo.subjectPKInfo);\n\n    return {\n      params,\n      value: spki,\n      algorithm: algorithm.algorithm,\n    };\n  }\n\n  public get signature(): ISignature {\n    const { signature, signatureAlgorithm } = this.asn;\n\n    return {\n      value: signature,\n      algorithm: signatureAlgorithm.algorithm,\n    };\n  }\n\n  public get commonName(): string {\n    if (!this.subject) {\n      return '';\n    }\n\n    for (let i = 0; i < this.subject.length; i += 1) {\n      const name = this.subject[i];\n\n      if (name.shortName === 'CN' || name.shortName === 'E' || name.shortName === 'O') {\n        return name.value;\n      }\n    }\n\n    return '';\n  }\n\n  public async getThumbprint(\n    algorithm: string = 'SHA-1',\n  ): Promise<void> {\n    try {\n      const thumbprint = await getCertificateThumbprint(algorithm, this.raw);\n\n      if (thumbprint) {\n        this.thumbprints[algorithm] = Convert.ToHex(thumbprint);\n      }\n    } catch (error) {\n      console.error('Error thumbprint get:', error);\n    }\n  }\n\n  public parseAttributes() {\n    const { certificationRequestInfo } = this.asn;\n\n    if (certificationRequestInfo.attributes) {\n      this.attributes = certificationRequestInfo.attributes\n        .map((e) => new Attribute(AsnConvert.serialize(e)));\n\n      const extensionRequestAttribute = this.attributes.find(\n        (attribute) => attribute.asn.type === id_pkcs9_at_extensionRequest,\n      ) as Attribute<ExtensionRequest>;\n\n      if (extensionRequestAttribute) {\n        this.extensions = extensionRequestAttribute.value\n          .map((e) => new Extension(AsnConvert.serialize(e)));\n      }\n    }\n  }\n\n  public exportAsBase64() {\n    return Convert.ToBase64(this.raw);\n  }\n\n  public exportAsHexFormatted() {\n    return hexFormat(Convert.ToHex(this.raw));\n  }\n\n  public exportAsPemFormatted() {\n    return `-----BEGIN CERTIFICATE REQUEST-----\\n${base64Format(this.exportAsBase64())}\\n-----END CERTIFICATE REQUEST-----`;\n  }\n\n  public downloadAsPEM(name?: string) {\n    Download.csr.asPEM(\n      this.exportAsPemFormatted(),\n      name || this.commonName,\n    );\n  }\n\n  public downloadAsDER(name?: string) {\n    Download.csr.asDER(\n      this.exportAsHexFormatted(),\n      name || this.commonName,\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) Peculiar Ventures, LLC.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { AsnConvert } from '@peculiar/asn1-schema';\nimport { CertificateList, Time } from '@peculiar/asn1-x509';\nimport { Convert } from 'pvtsutils';\n\nimport { Download } from '../utils';\n\nimport { Extension, TExtensionValue } from './extension';\nimport { AsnData } from './asn_data';\nimport { Name, INameJSON } from './name';\nimport {\n  certificateRawToBuffer,\n  hexFormat,\n  base64Format,\n  getCertificateThumbprint,\n} from './utils';\n\ninterface ISignature {\n  algorithm: string;\n  value: BufferSource;\n}\n\nexport interface IRevokedCertificate {\n  userCertificate: ArrayBuffer;\n  revocationDate: Time;\n  crlEntryExtensions?: Extension<TExtensionValue>[];\n}\n\nexport class CRL extends AsnData<CertificateList> {\n  public readonly issuer: INameJSON[];\n\n  public readonly version: number;\n\n  public readonly lastUpdate: Date;\n\n  public readonly nextUpdate: Date;\n\n  public extensions: Extension<TExtensionValue>[];\n\n  public revokedCertificates: IRevokedCertificate[];\n\n  public thumbprints: Record<string, string> = {};\n\n  public type: string = 'X.509 Certificate Revocation List';\n\n  constructor(raw: string) {\n    super(certificateRawToBuffer(raw), CertificateList);\n\n    const { tbsCertList } = this.asn;\n\n    this.issuer = new Name(tbsCertList.issuer).toJSON();\n    this.version = tbsCertList.version + 1;\n    this.lastUpdate = tbsCertList.thisUpdate.getTime();\n    this.nextUpdate = tbsCertList.nextUpdate.getTime();\n\n    this.revokedCertificates = (tbsCertList.revokedCertificates || [])\n      .map((revokedCertificate) => ({\n        revocationDate: revokedCertificate.revocationDate,\n        userCertificate: revokedCertificate.userCertificate,\n        crlEntryExtensions: revokedCertificate.crlEntryExtensions\n          ?.map((e) => new Extension(AsnConvert.serialize(e))),\n      }));\n  }\n\n  public async getThumbprint(\n    algorithm: string = 'SHA-1',\n  ): Promise<void> {\n    try {\n      const thumbprint = await getCertificateThumbprint(algorithm, this.raw);\n\n      if (thumbprint) {\n        this.thumbprints[algorithm] = Convert.ToHex(thumbprint);\n      }\n    } catch (error) {\n      console.error('Error thumbprint get:', error);\n    }\n  }\n\n  public get signature(): ISignature {\n    const { signature, signatureAlgorithm } = this.asn;\n\n    return {\n      value: signature,\n      algorithm: signatureAlgorithm.algorithm,\n    };\n  }\n\n  public get commonName(): string {\n    if (!this.issuer) {\n      return '';\n    }\n\n    for (let i = 0; i < this.issuer.length; i += 1) {\n      const name = this.issuer[i];\n\n      if (name.shortName === 'CN' || name.shortName === 'E' || name.shortName === 'O') {\n        return name.value;\n      }\n    }\n\n    return '';\n  }\n\n  public parseExtensions() {\n    const { tbsCertList } = this.asn;\n\n    if (tbsCertList.crlExtensions) {\n      this.extensions = tbsCertList.crlExtensions\n        .map((e) => new Extension(AsnConvert.serialize(e)));\n    }\n  }\n\n  public exportAsBase64() {\n    return Convert.ToBase64(this.raw);\n  }\n\n  public exportAsHexFormatted() {\n    return hexFormat(Convert.ToHex(this.raw));\n  }\n\n  public exportAsPemFormatted() {\n    return `-----BEGIN X509 CRL-----\\n${base64Format(this.exportAsBase64())}\\n-----END X509 CRL-----`;\n  }\n\n  public downloadAsPEM(name?: string) {\n    Download.crl.asPEM(\n      this.exportAsPemFormatted(),\n      name || this.commonName,\n    );\n  }\n\n  public downloadAsDER(name?: string) {\n    Download.crl.asDER(\n      this.exportAsHexFormatted(),\n      name || this.commonName,\n    );\n  }\n}\n"],"mappings":"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"}