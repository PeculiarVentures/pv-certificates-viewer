import{r as t,h as e}from"./p-24e0417d.js";function r(t,e,r){return t instanceof Object==0?r:e in t?t[e]:r}function s(t,e=0,r=t.byteLength-e,s=!1){let i="";for(const n of new Uint8Array(t,e,r)){const t=n.toString(16).toUpperCase();1===t.length&&(i+="0"),i+=t,s&&(i+=" ")}return i.trim()}function i(t,e,r,s){return e instanceof ArrayBuffer==0?(t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===e.byteLength?(t.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):s<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-s<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))}function n(t,e){let r=0;if(1===t.length)return t[0];for(let s=t.length-1;s>=0;s--)r+=t[t.length-1-s]*Math.pow(2,e*s);return r}function a(t,e,r=-1){const s=r;let i=t,n=0,a=Math.pow(2,e);for(let o=1;o<8;o++){if(t<a){let t;if(s<0)t=new ArrayBuffer(o),n=o;else{if(s<o)return new ArrayBuffer(0);t=new ArrayBuffer(s),n=s}const r=new Uint8Array(t);for(let s=o-1;s>=0;s--){const t=Math.pow(2,s*e);r[n-s-1]=Math.floor(i/t),i-=r[n-s-1]*t}return t}a*=Math.pow(2,e)}return new ArrayBuffer(0)}function o(...t){let e=0,r=0;for(const n of t)e+=n.byteLength;const s=new ArrayBuffer(e),i=new Uint8Array(s);for(const n of t)i.set(new Uint8Array(n),r),r+=n.byteLength;return s}function h(...t){let e=0,r=0;for(const n of t)e+=n.length;const s=new ArrayBuffer(e),i=new Uint8Array(s);for(const n of t)i.set(n,r),r+=n.length;return i}function c(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=0===t[0]&&0==(128&t[1]);(255===t[0]&&128&t[1]||e)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let n=0;n<this.valueHex.byteLength;n++)r[n]=0;r[0]=128&t[0];const s=n(r,8),i=new ArrayBuffer(this.valueHex.byteLength),a=new Uint8Array(i);for(let n=0;n<this.valueHex.byteLength;n++)a[n]=t[n];return a[0]&=127,n(a,8)-s}function u(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),s=new Uint8Array(e);for(let i=0;i<r.length;i++)if(r[i]!==s[i])return!1;return!0}function l(t,e){const r=t.toString(10);if(e<r.length)return"";const s=e-r.length,i=new Array(s);for(let n=0;n<s;n++)i[n]="0";return i.join("").concat(r)}const m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function w(t,e=!1,r=!1,s=!1){let i=0,n=0,a=0,o="";const h=e?f:m;if(s){let e=0;for(let r=0;r<t.length;r++)if(0!==t.charCodeAt(r)){e=r;break}t=t.slice(e)}for(;i<t.length;){const e=t.charCodeAt(i++);i>=t.length&&(n=1);const s=t.charCodeAt(i++);i>=t.length&&(a=1);const c=t.charCodeAt(i++),u=e>>2,l=(3&e)<<4|s>>4;let m=(15&s)<<2|c>>6,f=63&c;1===n?m=f=64:1===a&&(f=64),o+=r?64===m?`${h.charAt(u)}${h.charAt(l)}`:64===f?`${h.charAt(u)}${h.charAt(l)}${h.charAt(m)}`:`${h.charAt(u)}${h.charAt(l)}${h.charAt(m)}${h.charAt(f)}`:`${h.charAt(u)}${h.charAt(l)}${h.charAt(m)}${h.charAt(f)}`}return o}function d(t,e=!1,r=!1){const s=e?f:m;function i(t){for(let e=0;e<64;e++)if(s.charAt(e)===t)return e;return 64}function n(t){return 64===t?0:t}let a=0,o="";for(;a<t.length;){const e=i(t.charAt(a++)),r=a>=t.length?0:i(t.charAt(a++)),s=a>=t.length?0:i(t.charAt(a++)),h=a>=t.length?0:i(t.charAt(a++)),c=n(e)<<2|n(r)>>4,u=(15&n(r))<<4|n(s)>>2,l=(3&n(s))<<6|n(h);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(u)),64!==h&&(o+=String.fromCharCode(l))}if(r){let t=-1;for(let e=o.length-1;e>=0;e--)if(0!==o.charCodeAt(e)){t=e;break}o=-1!==t?o.slice(0,t+1):""}return o}function y(t){let e="";const r=new Uint8Array(t);for(const s of r)e+=String.fromCharCode(s);return e}function b(t){const e=t.length,r=new ArrayBuffer(e),s=new Uint8Array(r);for(let i=0;i<e;i++)s[i]=t.charCodeAt(i);return r}const p=Math.log(2);function g(t){const e=Math.log(t)/p,r=Math.floor(e),s=Math.round(e);return r===s?r:s}function A(t,e){for(const r of e)delete t[r]}const v=[new Uint8Array([1])],S="0123456789";class k{constructor(t={}){this.blockLength=r(t,"blockLength",0),this.error=r(t,"error",""),this.warnings=r(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:s(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const C=t=>(class extends t{constructor(t={}){super(t),this.isHexOnly=r(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,e,r){return!1===i(this,t,e,r)?-1:0===new Uint8Array(t,e,r).length?(this.warnings.push("Zero buffer length"),e):(this.valueHex=t.slice(e,e+r),this.blockLength=r,e+r)}toBER(t=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===t?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isHexOnly=this.isHexOnly,t.valueHex=s(this.valueHex,0,this.valueHex.byteLength),t}});class P extends(C(k)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=r(t.idBlock,"isHexOnly",!1),this.valueHex=r(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=r(t.idBlock,"tagClass",-1),this.tagNumber=r(t.idBlock,"tagNumber",-1),this.isConstructed=r(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(t=!1){let e,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(e=new ArrayBuffer(1),r=new Uint8Array(e),!t){let t=this.tagNumber;r[0]=s|=t&=31}return e}if(!1===this.isHexOnly){const i=a(this.tagNumber,7),n=new Uint8Array(i),o=i.byteLength;if(e=new ArrayBuffer(o+1),(r=new Uint8Array(e))[0]=31|s,!t){for(let t=0;t<o-1;t++)r[t+1]=128|n[t];r[o]=n[o-1]}return e}if(e=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(e))[0]=31|s,!1===t){const t=new Uint8Array(this.valueHex);for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHex.byteLength]=t[t.length-1]}return e}fromBER(t,e,r){if(!1===i(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);if(0===s.length)return this.error="Zero buffer length",-1;switch(192&s[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&s[0]),this.isHexOnly=!1;const a=31&s[0];if(31!==a)this.tagNumber=a,this.blockLength=1;else{let t=1;this.valueHex=new ArrayBuffer(255);let e=255,r=new Uint8Array(this.valueHex);for(;128&s[t];){if(r[t-1]=127&s[t],++t>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(t===e){e+=255;const t=new ArrayBuffer(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex)}}this.blockLength=t+1,r[t-1]=127&s[t];const i=new ArrayBuffer(t),a=new Uint8Array(i);for(let s=0;s<t;s++)a[s]=r[s];this.valueHex=new ArrayBuffer(t),(r=new Uint8Array(this.valueHex)).set(a),this.blockLength<=9?this.tagNumber=n(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.tagClass=this.tagClass,t.tagNumber=this.tagNumber,t.isConstructed=this.isConstructed,t}}class E extends k{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=r(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=r(t.lenBlock,"longFormUsed",!1),this.length=r(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(t,e,r){if(!1===i(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);if(0===s.length)return this.error="Zero buffer length",-1;if(255===s[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===s[0],!0===this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&s[0]),!1===this.longFormUsed)return this.length=s[0],this.blockLength=1,e+this.blockLength;const a=127&s[0];if(a>8)return this.error="Too big integer",-1;if(a+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(a);for(let i=0;i<a;i++)o[i]=s[i+1];return 0===o[a-1]&&this.warnings.push("Needlessly long encoded length"),this.length=n(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=a+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&((r=new Uint8Array(e))[0]=128),e;if(!0===this.longFormUsed){const s=a(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(e=new ArrayBuffer(s.byteLength+1),!0===t)return e;const i=new Uint8Array(s);(r=new Uint8Array(e))[0]=128|s.byteLength;for(let t=0;t<s.byteLength;t++)r[t+1]=i[t];return e}return e=new ArrayBuffer(1),!1===t&&((r=new Uint8Array(e))[0]=this.length),e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isIndefiniteForm=this.isIndefiniteForm,t.longFormUsed=this.longFormUsed,t.length=this.length,t}}class N extends k{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,e,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}class B extends k{constructor(t={},e=N){super(t),"name"in t&&(this.name=t.name),"optional"in t&&(this.optional=t.optional),"primitiveSchema"in t&&(this.primitiveSchema=t.primitiveSchema),this.idBlock=new P(t),this.lenBlock=new E(t),this.valueBlock=new e(t)}static blockName(){return"BaseBlock"}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t=!1){let e;const r=this.idBlock.toBER(t),s=this.valueBlock.toBER(!0);let i;if(this.lenBlock.length=s.byteLength,e=o(r,this.lenBlock.toBER(t)),e=o(e,i=!1===t?this.valueBlock.toBER(t):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===t){const t=new Uint8Array(r);t[0]=0,t[1]=0}e=o(e,r)}return e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.idBlock=this.idBlock.toJSON(),t.lenBlock=this.lenBlock.toJSON(),t.valueBlock=this.valueBlock.toJSON(),"name"in this&&(t.name=this.name),"optional"in this&&(t.optional=this.optional),"primitiveSchema"in this&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}}class I extends N{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=r(t,"isHexOnly",!0)}fromBER(t,e,r){if(!1===i(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);if(0===s.length)return this.warnings.push("Zero buffer length"),e;this.valueHex=new ArrayBuffer(s.length);const n=new Uint8Array(this.valueHex);for(let i=0;i<s.length;i++)n[i]=s[i];return this.blockLength=r,e+r}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueHex=s(this.valueHex,0,this.valueHex.byteLength),t.isHexOnly=this.isHexOnly,t}}class U extends B{constructor(t={}){super(t,I),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class x extends N{constructor(t={}){super(t),this.value=r(t,"value",[]),this.isIndefiniteForm=r(t,"isIndefiniteForm",!1)}fromBER(t,e,r){const s=e,n=r;if(!1===i(this,t,e,r))return-1;if(0===new Uint8Array(t,e,r).length)return this.warnings.push("Zero buffer length"),e;let a=e;for(;(!0===this.isIndefiniteForm?1:r)>0;){const e=Nt(t,a,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(a=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),!0===this.isIndefiniteForm&&e.result.constructor.blockName()===H.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===H.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=t.slice(s,s+n),a}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++)e=o(e,this.value[r].toBER(t));return e}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.isIndefiniteForm=this.isIndefiniteForm,t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class D extends B{constructor(t={}){super(t,x),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class O extends N{constructor(t={}){super(t)}fromBER(t,e,r){return e}toBER(t=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class H extends B{constructor(t={}){super(t,O),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class R extends N{constructor(t={}){super(t),this.value=r(t,"value",!1),this.isHexOnly=r(t,"isHexOnly",!1),"valueHex"in t?this.valueHex=t.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(t,e,r){if(!1===i(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(s.length);const n=new Uint8Array(this.valueHex);for(let i=0;i<s.length;i++)n[i]=s[i];return this.value=0!==c.call(this),this.blockLength=r,e+r}toBER(t=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t.isHexOnly=this.isHexOnly,t.valueHex=s(this.valueHex,0,this.valueHex.byteLength),t}}class j extends B{constructor(t={}){super(t,R),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class K extends D{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class $ extends D{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class T extends B{constructor(t={}){super(t,k),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t=!1){const e=new ArrayBuffer(2);if(!0===t)return e;const r=new Uint8Array(e);return r[0]=5,r[1]=0,e}}class V extends(C(x)){constructor(t={}){super(t),this.isConstructed=r(t,"isConstructed",!1)}fromBER(t,e,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(s=x.prototype.fromBER.call(this,t,e,r)))return s;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===H.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==M.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(t,e,r),this.blockLength=r;return s}toBER(t=!1){if(!0===this.isConstructed)return x.prototype.toBER.call(this,t);let e=new ArrayBuffer(this.valueHex.byteLength);return!0===t?e:0===this.valueHex.byteLength?e:e=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=s(this.valueHex,0,this.valueHex.byteLength),t}}class M extends B{constructor(t={}){super(t,V),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e):super.fromBER(t,e,r)}static blockName(){return"OctetString"}isEqual(t){return t instanceof M!=0&&JSON.stringify(this)===JSON.stringify(t)}}class J extends(C(x)){constructor(t={}){super(t),this.unusedBits=r(t,"unusedBits",0),this.isConstructed=r(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(t,e,r){if(0===r)return e;let s=-1;if(!0===this.isConstructed){if(-1===(s=x.prototype.fromBER.call(this,t,e,r)))return s;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===H.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==L.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[t].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return s}if(!1===i(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const a=new Uint8Array(this.valueHex);for(let i=0;i<r-1;i++)a[i]=n[i+1];return this.blockLength=n.length,e+r}toBER(t=!1){if(!0===this.isConstructed)return x.prototype.toBER.call(this,t);if(!0===t)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const e=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let i=0;i<this.valueHex.byteLength;i++)s[i+1]=e[i];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.unusedBits=this.unusedBits,t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=s(this.valueHex,0,this.valueHex.byteLength),t}}class L extends B{constructor(t={}){super(t,J),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(t,e,r){return 0===r?e:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r))}isEqual(t){return t instanceof L!=0&&JSON.stringify(this)===JSON.stringify(t)}}class F extends(C(N)){constructor(t={}){super(t),"value"in t&&(this.valueDec=t.value)}set valueHex(t){this._valueHex=t.slice(0),t.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,t.byteLength>0&&(this._valueDec=c.call(this)))}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this._valueHex=function(t){const e=t<0?-1*t:t;let r=128;for(let s=1;s<8;s++){if(e<=r){if(t<0){const t=a(r-e,8,s);return new Uint8Array(t)[0]|=128,t}let i=a(e,8,s),n=new Uint8Array(i);if(128&n[0]){const t=i.slice(0),e=new Uint8Array(t);i=new ArrayBuffer(i.byteLength+1),n=new Uint8Array(i);for(let r=0;r<t.byteLength;r++)n[r+1]=e[r];n[0]=0}return i}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(t)}get valueDec(){return this._valueDec}fromDER(t,e,r,s=0){const i=this.fromBER(t,e,r);if(-1===i)return i;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const t=new ArrayBuffer(s);new Uint8Array(t).set(n,s-this._valueHex.byteLength),this._valueHex=t.slice(0)}return i}toDER(t=!1){const e=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&e[0]):{const t=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(t);r[0]=0,r.set(e,1),this._valueHex=t.slice(0)}break;case 0===e[0]&&0==(128&e[1]):{const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}}return this.toBER(t)}fromBER(t,e,r){const s=super.fromBER(t,e,r);return-1===s?s:(this.blockLength=r,e+r)}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}toString(){function t(t,e){const r=new Uint8Array([0]);let s=new Uint8Array(t),i=new Uint8Array(e),n=s.slice(0);const a=n.length-1;let o=i.slice(0);const c=o.length-1;let u=0,l=0;for(let m=c<a?a:c;m>=0;m--,l++){switch(!0){case l<o.length:u=n[a-l]+o[c-l]+r[0];break;default:u=n[a-l]+r[0]}switch(r[0]=u/10,!0){case l>=n.length:n=h(new Uint8Array([u%10]),n);break;default:n[a-l]=u%10}}return r[0]>0&&(n=h(r,n)),n.slice(0)}function e(t){if(t>=v.length)for(let e=v.length;e<=t;e++){const t=new Uint8Array([0]);let r=v[e-1].slice(0);for(let e=r.length-1;e>=0;e--){const s=new Uint8Array([(r[e]<<1)+t[0]]);t[0]=s[0]/10,r[e]=s[0]%10}t[0]>0&&(r=h(t,r)),v.push(r)}return v[t]}function r(t,e){let r=0,s=new Uint8Array(t),i=new Uint8Array(e),n=s.slice(0);const a=n.length-1;let o=i.slice(0);const h=o.length-1;let c,u=0;for(let l=h;l>=0;l--,u++)switch(c=n[a-u]-o[h-u]-r,!0){case c<0:r=1,n[a-u]=c+10;break;default:r=0,n[a-u]=c}if(r>0)for(let l=a-h+1;l>=0;l--,u++){if(!((c=n[a-u]-r)<0)){r=0,n[a-u]=c;break}r=1,n[a-u]=c+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let i,n=new Uint8Array(8*this._valueHex.byteLength/3),a=0;const o=new Uint8Array(this._valueHex);let c="",u=!1;for(let h=this._valueHex.byteLength-1;h>=0;h--){i=o[h];for(let o=0;o<8;o++){if(1==(1&i))switch(a){case s:n=r(e(a),n),c="-";break;default:n=t(n,e(a))}a++,i>>=1}}for(let h=0;h<n.length;h++)n[h]&&(u=!0),u&&(c+=S.charAt(n[h]));return!1===u&&(c+=S.charAt(0)),c}}class q extends B{constructor(t={}){super(t,F),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(t){return t instanceof q?this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly?u(this.valueBlock.valueHex,t.valueBlock.valueHex):this.valueBlock.isHexOnly===t.valueBlock.isHexOnly&&this.valueBlock.valueDec===t.valueBlock.valueDec:t instanceof ArrayBuffer&&u(this.valueBlock.valueHex,t)}convertToDER(){const t=new q({valueHex:this.valueBlock.valueHex});return t.valueBlock.toDER(),t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,e=new q({valueHex:this.valueBlock.valueHex});return e.valueBlock.fromDER(e.valueBlock.valueHex,0,e.valueBlock.valueHex.byteLength,t),e}}class W extends q{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class G extends(C(k)){constructor(t={}){super(t),this.valueDec=r(t,"valueDec",-1),this.isFirstSid=r(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===i(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let a=new Uint8Array(this.valueHex);for(let i=0;i<r&&(a[i]=127&s[i],this.blockLength++,0!=(128&s[i]));i++);const o=new ArrayBuffer(this.blockLength),h=new Uint8Array(o);for(let i=0;i<this.blockLength;i++)h[i]=a[i];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&s[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=n(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|s[t];return r[this.blockLength-1]=s[this.blockLength-1],e}const s=a(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(s.byteLength),!1===t){const t=new Uint8Array(s);r=new Uint8Array(e);for(let e=0;e<s.byteLength-1;e++)r[e]=128|t[e];r[s.byteLength-1]=t[s.byteLength-1]}return e}toString(){let t="";if(!0===this.isHexOnly)t=s(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t.isFirstSid=this.isFirstSid,t}}class _ extends N{constructor(t={}){super(t),this.fromString(r(t,"value",""))}fromBER(t,e,r){let s=e;for(;r>0;){const e=new G;if(-1===(s=e.fromBER(t,s,r)))return this.blockLength=0,this.error=e.error,s;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return s}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(t);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=o(e,s)}return e}fromString(t){this.value=[];let e=0,r=0,s="",i=!1;do{if(s=-1===(r=t.indexOf(".",e))?t.substr(e):t.substr(e,r-e),e=r+1,i){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;t.valueDec=r+e,i=!1}else{const t=new G;if(t.valueDec=parseInt(s,10),isNaN(t.valueDec))return!0;0===this.value.length&&(t.isFirstSid=!0,i=!0),this.value.push(t)}}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(t=`${t}.`),e?(s=`{${s}}`,this.value[r].isFirstSid?t=`2.{${s} - 80}`:t+=s):t+=s}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class Q extends B{constructor(t={}){super(t,_),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class Z extends(C(k)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class Y extends B{constructor(t={}){super(t,Z),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(t){const e=unescape(encodeURIComponent(t)),r=e.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<r;i++)s[i]=e.charCodeAt(i);this.valueBlock.value=t}}class z extends(C(k)){constructor(t={}){super(t),this.valueDec=r(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===i(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let a=new Uint8Array(this.valueHex);for(let i=0;i<r&&(a[i]=127&s[i],this.blockLength++,0!=(128&s[i]));i++);const o=new ArrayBuffer(this.blockLength),h=new Uint8Array(o);for(let i=0;i<this.blockLength;i++)h[i]=a[i];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&s[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=n(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|s[t];return r[this.blockLength-1]=s[this.blockLength-1],e}const s=a(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(s.byteLength),!1===t){const t=new Uint8Array(s);r=new Uint8Array(e);for(let e=0;e<s.byteLength-1;e++)r[e]=128|t[e];r[s.byteLength-1]=t[s.byteLength-1]}return e}toString(){return!0===this.isHexOnly?s(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString()}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}}class X extends N{constructor(t={}){super(t),this.fromString(r(t,"value",""))}fromBER(t,e,r){let s=e;for(;r>0;){const e=new z;if(-1===(s=e.fromBER(t,s,r)))return this.blockLength=0,this.error=e.error,s;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return s}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(t);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=o(e,s)}return e}fromString(t){this.value=[];let e=0,r=0,s="";do{s=-1===(r=t.indexOf(".",e))?t.substr(e):t.substr(e,r-e),e=r+1;const i=new z;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(t=`${t}.`),t+=e?s=`{${s}}`:s}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class tt extends B{constructor(t={}){super(t,X),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}class et extends(C(k)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class rt extends B{constructor(t={}){super(t,et),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let s=0;s<r.length;s+=2){const t=r[s];r[s]=r[s+1],r[s+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(2*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<e;s++){const e=a(t.charCodeAt(s),8),i=new Uint8Array(e);if(i.length>2)continue;const n=2-i.length;for(let t=i.length-1;t>=0;t--)r[2*s+t+n]=i[t]}this.valueBlock.value=t}}class st extends(C(k)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class it extends B{constructor(t={}){super(t,st),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let s=0;s<r.length;s+=4)r[s]=r[s+3],r[s+1]=r[s+2],r[s+2]=0,r[s+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(4*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<e;s++){const e=a(t.charCodeAt(s),8),i=new Uint8Array(e);if(i.length>4)continue;const n=4-i.length;for(let t=i.length-1;t>=0;t--)r[4*s+t+n]=i[t]}this.valueBlock.value=t}}class nt extends(C(k)){constructor(t={}){super(t),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class at extends B{constructor(t={}){super(t,nt),"value"in t&&this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(e);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<e;s++)r[s]=t.charCodeAt(s);this.valueBlock.value=t}}class ot extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class ht extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class ct extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class ut extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class lt extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class mt extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class ft extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class wt extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class dt extends at{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class yt extends ft{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for convertion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(){const t=new Array(7);return t[0]=l(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=l(this.month,2),t[2]=l(this.day,2),t[3]=l(this.hour,2),t[4]=l(this.minute,2),t[5]=l(this.second,2),t[6]="Z",t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t}}class bt extends ft{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,s="",i="",n=0,a=0,o=0;if("Z"===t[t.length-1])s=t.substr(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");s=t}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let t=1,e=s.indexOf("+"),r="";if(-1===e&&(e=s.indexOf("-"),t=-1),-1!==e){if(r=s.substr(e+1),s=s.substr(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let i=new Number(r.substr(0,2));if(isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");if(a=t*i,4===r.length){if(i=new Number(r.substr(2,2)),isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");o=t*i}}}let h=s.indexOf(".");if(-1===h&&(h=s.indexOf(",")),-1!==h){const t=new Number(`0${s.substr(h)}`);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");n=t.valueOf(),i=s.substr(0,h)}else i=s;switch(!0){case 8===i.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==h)throw new Error("Wrong input string for convertion");break;case 10===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==h){let t=60*n;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==h){let t=60*n;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===i.length:e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==h&&(this.millisecond=Math.floor(1e3*n));break;default:throw new Error("Wrong input string for convertion")}const c=e.exec(i);if(null===c)throw new Error("Wrong input string for convertion");for(let u=1;u<c.length;u++)switch(u){case 1:this.year=parseInt(c[u],10);break;case 2:this.month=parseInt(c[u],10);break;case 3:this.day=parseInt(c[u],10);break;case 4:this.hour=parseInt(c[u],10)+a;break;case 5:this.minute=parseInt(c[u],10)+o;break;case 6:this.second=parseInt(c[u],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];return t.push(l(this.year,4)),t.push(l(this.month,2)),t.push(l(this.day,2)),t.push(l(this.hour,2)),t.push(l(this.minute,2)),t.push(l(this.second,2)),0!==this.millisecond&&(t.push("."),t.push(l(this.millisecond,3))),t.push("Z"),t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t.millisecond=this.millisecond,t}}class pt extends Y{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class gt extends Y{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class At extends Y{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class vt extends Y{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class St extends Y{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class kt{constructor(t={}){this.value=r(t,"value",[]),this.optional=r(t,"optional",!1)}}class Ct{constructor(t={}){this.name=r(t,"name",""),this.optional=r(t,"optional",!1)}}class Pt{constructor(t={}){this.name=r(t,"name",""),this.optional=r(t,"optional",!1),this.value=r(t,"value",new Ct),this.local=r(t,"local",!1)}}class Et{constructor(t={}){this.data=r(t,"data",new ArrayBuffer(0))}fromBER(t,e,r){return this.data=t.slice(e,r),e+r}toBER(t=!1){return this.data}}function Nt(t,e,r){const s=e;let n=new B({},Object);const a=new k;if(!1===i(a,t,e,r))return n.error=a.error,{offset:-1,result:n};if(0===new Uint8Array(t,e,r).length)return this.error="Zero buffer length",{offset:-1,result:n};let o=n.idBlock.fromBER(t,e,r);if(n.warnings.concat(n.idBlock.warnings),-1===o)return n.error=n.idBlock.error,{offset:-1,result:n};if(o=n.lenBlock.fromBER(t,e=o,r-=n.idBlock.blockLength),n.warnings.concat(n.lenBlock.warnings),-1===o)return n.error=n.lenBlock.error,{offset:-1,result:n};if(e=o,r-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let h=B;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};h=H;break;case 1:h=j;break;case 2:h=q;break;case 3:h=L;break;case 4:h=M;break;case 5:h=T;break;case 6:h=Q;break;case 10:h=W;break;case 12:h=Y;break;case 13:h=tt;break;case 14:h=St;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:h=K;break;case 17:h=$;break;case 18:h=ot;break;case 19:h=ht;break;case 20:h=ct;break;case 21:h=ut;break;case 22:h=lt;break;case 23:h=yt;break;case 24:h=bt;break;case 25:h=mt;break;case 26:h=ft;break;case 27:h=wt;break;case 28:h=it;break;case 29:h=dt;break;case 30:h=rt;break;case 31:h=pt;break;case 32:h=gt;break;case 33:h=At;break;case 34:h=vt;break;default:{let s;(s=!0===n.idBlock.isConstructed?new D:new U).idBlock=n.idBlock,s.lenBlock=n.lenBlock,s.warnings=n.warnings,o=(n=s).fromBER(t,e,r)}}break;case 2:case 3:case 4:default:h=!0===n.idBlock.isConstructed?D:U}return o=(n=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecode=t.valueBeforeDecode.slice(0),r}(n,h)).fromBER(t,e,!0===n.lenBlock.isIndefiniteForm?r:n.lenBlock.length),n.valueBeforeDecode=t.slice(s,s+n.blockLength),{offset:o,result:n}}function Bt(t){if(0===t.byteLength){const t=new B({},Object);return t.error="Input buffer has zero length",{offset:-1,result:t}}return Nt(t,0,t.byteLength)}function It(t,e,r){if(r instanceof kt){for(let s=0;s<r.value.length;s++)if(!0===It(t,e,r.value[s]).verified)return{verified:!0,result:t};{const t={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(t.name=r.name),t}}if(r instanceof Ct)return r.hasOwnProperty("name")&&(t[r.name]=e),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=new Uint8Array(r.idBlock.valueHex),i=new Uint8Array(e.idBlock.valueHex);if(s.length!==i.length)return{verified:!1,result:t};for(let e=0;e<s.length;e++)if(s[e]!==i[1])return{verified:!1,result:t}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(t[r.name]=e)),!0===r.idBlock.isConstructed){let s=0,i={verified:!1},n=r.valueBlock.value.length;if(n>0&&r.valueBlock.value[0]instanceof Pt&&(n=e.valueBlock.value.length),0===n)return{verified:!0,result:t};if(0===e.valueBlock.value.length&&0!==r.valueBlock.value.length){let e=!0;for(let t=0;t<r.valueBlock.value.length;t++)e=e&&(r.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let a=0;a<n;a++)if(a-s>=e.valueBlock.value.length){if(!1===r.valueBlock.value[a].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}}else if(r.valueBlock.value[0]instanceof Pt){if(!1===(i=It(t,e.valueBlock.value[a],r.valueBlock.value[0].value)).verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),i;s++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};void 0===(s="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?e:t)[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(e.valueBlock.value[a])}}else if(!1===(i=It(t,e.valueBlock.value[a-s],r.valueBlock.value[a])).verified){if(!0!==r.valueBlock.value[a].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),i;s++}if(!1===i.verified){const e={verified:!1,result:t};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in r&&"valueHex"in e.valueBlock){const s=Bt(e.valueBlock.valueHex);if(-1===s.offset){const e={verified:!1,result:s.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return It(t,s.result,r.primitiveSchema)}return{verified:!0,result:t}}function Ut(t){return"undefined"!=typeof Buffer&&Buffer.isBuffer(t)?new Uint8Array(t):ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}class xt{static ToString(t,e="utf8"){const r=Ut(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=Ut(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){return t=t.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(t){return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let s=0;s<e.length;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToUtf8String(t){const e=Ut(t),r=String.fromCharCode.apply(null,e);return decodeURIComponent(escape(r))}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let s=0;s<e;s++)r[s]=t.charCodeAt(s);return r.buffer}static ToBinary(t){const e=Ut(t);let r="";const s=e.length;for(let i=0;i<s;i++)r+=String.fromCharCode(e[i]);return r}static ToHex(t){const e=Ut(t),r=[],s=e.length;for(let i=0;i<s;i++){const t=e[i].toString(16);r.push(1===t.length?"0"+t:t)}return r.join("")}static FromHex(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2){const s=t.slice(r,r+2);e[r/2]=parseInt(s,16)}return e.buffer}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}}class Dt{constructor(t){this.input=t,this.init()}static base64Clear(t){const e=atob(t.replace(/[\s\r\n]/g,""));return Dt.validation.isPem(e)?atob(e.replace(/-----.+-----/g,"").replace(/[\s\r\n]/g,"")):e}static pemTagCertificate(t){return`-----BEGIN CERTIFICATE-----\n${t}\n-----END CERTIFICATE-----`}static pemTagCertificateRequest(t){return`-----BEGIN CERTIFICATE REQUEST-----\n${t}\n-----END CERTIFICATE REQUEST-----`}static pemTagNewCertificateRequest(t){return`-----BEGIN NEW CERTIFICATE REQUEST-----\n${t}\n-----END NEW CERTIFICATE REQUEST-----`}static formatHex(t){return t.replace(/(.{32})/g,"$1\n").replace(/(.{4})/g,"$1 ").trim()}init(){let t;t=Dt.validation.isHex(this.input)?xt.FromHex(this.input):xt.FromBase64(this.input),this.schema=Bt(t).result,this.base64=xt.ToBase64(t),this.hex=Dt.formatHex(xt.ToHex(t))}static prepareSubject(t){return t?t.map(t=>{const e=Dt.subjectOIDs[t.type.toString()];return{name:e&&e.short?e.short:"",nameLong:e?e.long:"",oid:t.type,value:t.value.valueBlock.value}}):[]}static prepareAlgorithm(t){return t?Dt.algorithmOIDs[t.algorithmId]?Dt.algorithmOIDs[t.algorithmId]:{name:t.algorithmId}:{name:""}}}Dt.algorithmOIDs={"1.2.840.113549.1.1.5":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-1"},"1.2.840.113549.1.1.11":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},"1.2.840.113549.1.1.12":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-384"},"1.2.840.113549.1.1.13":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-512"},"1.2.840.10045.4.3.2":{name:"ECDSA",hash:"SHA-256"},"1.2.840.10045.4.1":{name:"ECDSA",hash:"SHA-1"}},Dt.subjectOIDs={"2.5.4.3":{short:"CN",long:"Common Name"},"2.5.4.6":{short:"C",long:"Country"},"2.5.4.5":{short:"serialNumber",long:"Serial Number"},"0.9.2342.19200300.100.1.25":{short:"DC",long:"Domain Component"},"1.2.840.113549.1.9.1":{short:"E",long:"Email"},"2.5.4.42":{short:"G",long:"Given Name"},"2.5.4.43":{short:"I",long:"Initials"},"2.5.4.7":{short:"L",long:"Locality"},"2.5.4.10":{short:"O",long:"Organization"},"2.5.4.11":{short:"OU",long:"Organization Unit"},"2.5.4.8":{short:"ST",long:"State"},"2.5.4.9":{short:"Street",long:"Street Address"},"2.5.4.4":{short:"SN",long:"Surname"},"2.5.4.12":{short:"T",long:"Title"},"1.2.840.113549.1.9.8":{long:"Unstructured Address"},"1.2.840.113549.1.9.2":{long:"Unstructured Name"},"1.3.6.1.4.1.311.60.2.1.3":{short:"jurisdictionCountry",long:"Jurisdiction Country"},"2.5.4.15":{short:"businessCategory",long:"Business Category"},"1.3.6.1.2.1.1.5":{long:"Host Name"}},Dt.validation={isHex:t=>/^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t),isPem:t=>/-----BEGIN.+-----/.test(t)};class Ot{constructor(t={}){this.algorithmId=r(t,"algorithmId",Ot.defaultValues("algorithmId")),"algorithmParams"in t&&(this.algorithmParams=r(t,"algorithmParams",Ot.defaultValues("algorithmParams"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"algorithmId":return"";case"algorithmParams":return new Ct;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"algorithmId":return""===e;case"algorithmParams":return e instanceof Ct;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",optional:e.optional||!1,value:[new Q({name:e.algorithmIdentifier||""}),new Ct({name:e.algorithmParams||"",optional:!0})]})}fromSchema(t){A(t,["algorithm","params"]);const e=It(t,t,Ot.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=e.result.algorithm.valueBlock.toString(),"params"in e.result&&(this.algorithmParams=e.result.params)}toSchema(){const t=[];return t.push(new Q({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof Ct==0&&t.push(this.algorithmParams),new K({value:t})}toJSON(){const t={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof Ct==0&&(t.algorithmParams=this.algorithmParams.toJSON()),t}isEqual(t){return t instanceof Ot!=0&&this.algorithmId===t.algorithmId&&("algorithmParams"in this?"algorithmParams"in t&&JSON.stringify(this.algorithmParams)===JSON.stringify(t.algorithmParams):!("algorithmParams"in t))}}class Ht{constructor(t={}){this.x=r(t,"x",Ht.defaultValues("x")),this.y=r(t,"y",Ht.defaultValues("y")),this.namedCurve=r(t,"namedCurve",Ht.defaultValues("namedCurve")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error(`Invalid member name for ECCPublicKey class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"x":case"y":return u(e,Ht.defaultValues(t));case"namedCurve":return""===e;default:throw new Error(`Invalid member name for ECCPublicKey class: ${t}`)}}static schema(t={}){return new Et}fromSchema(t){if(t instanceof ArrayBuffer==0)throw new Error("Object's schema was not verified against input data for ECPublicKey");if(4!==new Uint8Array(t)[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let e;switch(this.namedCurve){case"1.2.840.10045.3.1.7":e=32;break;case"1.3.132.0.34":e=48;break;case"1.3.132.0.35":e=66;break;default:throw new Error(`Incorrect curve OID: ${this.namedCurve}`)}if(t.byteLength!==2*e+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=t.slice(1,e+1),this.y=t.slice(1+e,2*e+1)}toSchema(){return new Et({data:o(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let t="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":t="P-256";break;case"1.3.132.0.34":t="P-384";break;case"1.3.132.0.35":t="P-521"}return{crv:t,x:w(y(this.x),!0,!0,!1),y:w(y(this.y),!0,!0,!1)}}fromJSON(t){let e=0;if(!("crv"in t))throw new Error('Absent mandatory parameter "crv"');switch(t.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",e=32;break;case"P-384":this.namedCurve="1.3.132.0.34",e=48;break;case"P-521":this.namedCurve="1.3.132.0.35",e=66}if(!("x"in t))throw new Error('Absent mandatory parameter "x"');{const r=b(d(t.x,!0));if(r.byteLength<e){this.x=new ArrayBuffer(e);const t=new Uint8Array(this.x),s=new Uint8Array(r);t.set(s,1)}else this.x=r.slice(0,e)}if(!("y"in t))throw new Error('Absent mandatory parameter "y"');{const r=b(d(t.y,!0));if(r.byteLength<e){this.y=new ArrayBuffer(e);const t=new Uint8Array(this.y),s=new Uint8Array(r);t.set(s,1)}else this.y=r.slice(0,e)}}}class Rt{constructor(t={}){this.modulus=r(t,"modulus",Rt.defaultValues("modulus")),this.publicExponent=r(t,"publicExponent",Rt.defaultValues("publicExponent")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"modulus":case"publicExponent":return new q;default:throw new Error(`Invalid member name for RSAPublicKey class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new q({name:e.modulus||""}),new q({name:e.publicExponent||""})]})}fromSchema(t){A(t,["modulus","publicExponent"]);const e=It(t,t,Rt.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=e.result.modulus.convertFromDER(256),this.publicExponent=e.result.publicExponent}toSchema(){return new K({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:w(y(this.modulus.valueBlock.valueHex),!0,!0,!0),e:w(y(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(t){if(!("n"in t))throw new Error('Absent mandatory parameter "n"');{const e=b(d(t.n,!0));this.modulus=new q({valueHex:e.slice(0,Math.pow(2,g(e.byteLength)))})}if(!("e"in t))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new q({valueHex:b(d(t.e,!0)).slice(0,3)})}}class jt{constructor(t={}){this.algorithm=r(t,"algorithm",jt.defaultValues("algorithm")),this.subjectPublicKey=r(t,"subjectPublicKey",jt.defaultValues("subjectPublicKey")),"parsedKey"in t&&(this.parsedKey=r(t,"parsedKey",jt.defaultValues("parsedKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"algorithm":return new Ot;case"subjectPublicKey":return new L;default:throw new Error(`Invalid member name for PublicKeyInfo class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[Ot.schema(e.algorithm||{}),new L({name:e.subjectPublicKey||""})]})}fromSchema(t){A(t,["algorithm","subjectPublicKey"]);const e=It(t,t,jt.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PublicKeyInfo");switch(this.algorithm=new Ot({schema:e.result.algorithm}),this.subjectPublicKey=e.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===Q.blockName())try{this.parsedKey=new Ht({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(r){}break;case"1.2.840.113549.1.1.1":{const t=Bt(this.subjectPublicKey.valueBlock.valueHex);if(-1!==t.offset)try{this.parsedKey=new Rt({schema:t.result})}catch(r){}}}}toSchema(){return new K({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==0)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const t={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":t.kty="EC";break;case"1.2.840.113549.1.1.1":t.kty="RSA"}const e=this.parsedKey.toJSON();for(const r of Object.keys(e))t[r]=e[r];return t}fromJSON(t){if("kty"in t){switch(t.kty.toUpperCase()){case"EC":this.parsedKey=new Ht({json:t}),this.algorithm=new Ot({algorithmId:"1.2.840.10045.2.1",algorithmParams:new Q({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Rt({json:t}),this.algorithm=new Ot({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new T});break;default:throw new Error(`Invalid value for "kty" parameter: ${t.kty}`)}this.subjectPublicKey=new L({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(t){let e=Promise.resolve();const r=this;if(void 0===t)return Promise.reject("Need to provide publicKey input parameter");const s=Zt();return void 0===s?Promise.reject("Unable to create WebCrypto object"):e=(e=e.then(()=>s.exportKey("spki",t))).then(t=>{const e=Bt(t);try{r.fromSchema(e.result)}catch(s){return Promise.reject("Error during initializing object from schema")}},t=>Promise.reject(`Error during exporting public key: ${t}`))}}class Kt{constructor(t={}){this.type=r(t,"type",Kt.defaultValues("type")),this.values=r(t,"values",Kt.defaultValues("values")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"type":return"";case"values":return[];default:throw new Error(`Invalid member name for Attribute class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"type":return""===e;case"values":return 0===e.length;default:throw new Error(`Invalid member name for Attribute class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.type||""}),new $({name:e.setName||"",value:[new Pt({name:e.values||"",value:new Ct})]})]})}fromSchema(t){A(t,["type","values"]);const e=It(t,t,Kt.schema({names:{type:"type",values:"values"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for Attribute");this.type=e.result.type.valueBlock.toString(),this.values=e.result.values}toSchema(){return new K({value:[new Q({value:this.type}),new $({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,t=>t.toJSON())}}}class $t{constructor(t={}){this.version=r(t,"version",$t.defaultValues("version")),this.privateKey=r(t,"privateKey",$t.defaultValues("privateKey")),"namedCurve"in t&&(this.namedCurve=r(t,"namedCurve",$t.defaultValues("namedCurve"))),"publicKey"in t&&(this.publicKey=r(t,"publicKey",$t.defaultValues("publicKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"version":return 1;case"privateKey":return new M;case"namedCurve":return"";case"publicKey":return new Ht;default:throw new Error(`Invalid member name for ECCPrivateKey class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"version":return e===$t.defaultValues(t);case"privateKey":return e.isEqual($t.defaultValues(t));case"namedCurve":return""===e;case"publicKey":return Ht.compareWithDefault("namedCurve",e.namedCurve)&&Ht.compareWithDefault("x",e.x)&&Ht.compareWithDefault("y",e.y);default:throw new Error(`Invalid member name for ECCPrivateKey class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new q({name:e.version||""}),new M({name:e.privateKey||""}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Q({name:e.namedCurve||""})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new L({name:e.publicKey||""})]})]})}fromSchema(t){A(t,["version","privateKey","namedCurve","publicKey"]);const e=It(t,t,$t.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=e.result.version.valueBlock.valueDec,this.privateKey=e.result.privateKey,"namedCurve"in e.result&&(this.namedCurve=e.result.namedCurve.valueBlock.toString()),"publicKey"in e.result){const t={schema:e.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(t.namedCurve=this.namedCurve),this.publicKey=new Ht(t)}}toSchema(){const t=[new q({value:this.version}),this.privateKey];return"namedCurve"in this&&t.push(new D({idBlock:{tagClass:3,tagNumber:0},value:[new Q({value:this.namedCurve})]})),"publicKey"in this&&t.push(new D({idBlock:{tagClass:3,tagNumber:1},value:[new L({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new K({value:t})}toJSON(){if("namedCurve"in this==0||$t.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let t="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":t="P-256";break;case"1.3.132.0.34":t="P-384";break;case"1.3.132.0.35":t="P-521"}const e={crv:t,d:w(y(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const t=this.publicKey.toJSON();e.x=t.x,e.y=t.y}return e}fromJSON(t){let e=0;if(!("crv"in t))throw new Error('Absent mandatory parameter "crv"');switch(t.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",e=32;break;case"P-384":this.namedCurve="1.3.132.0.34",e=48;break;case"P-521":this.namedCurve="1.3.132.0.35",e=66}if(!("d"in t))throw new Error('Absent mandatory parameter "d"');{const r=b(d(t.d,!0));if(r.byteLength<e){const t=new ArrayBuffer(e),s=new Uint8Array(t),i=new Uint8Array(r);s.set(i,1),this.privateKey=new M({valueHex:t})}else this.privateKey=new M({valueHex:r.slice(0,e)})}"x"in t&&"y"in t&&(this.publicKey=new Ht({json:t}))}}class Tt{constructor(t={}){this.prime=r(t,"prime",Tt.defaultValues("prime")),this.exponent=r(t,"exponent",Tt.defaultValues("exponent")),this.coefficient=r(t,"coefficient",Tt.defaultValues("coefficient")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"prime":case"exponent":case"coefficient":return new q;default:throw new Error(`Invalid member name for OtherPrimeInfo class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new q({name:e.prime||""}),new q({name:e.exponent||""}),new q({name:e.coefficient||""})]})}fromSchema(t){A(t,["prime","exponent","coefficient"]);const e=It(t,t,Tt.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=e.result.prime.convertFromDER(),this.exponent=e.result.exponent.convertFromDER(),this.coefficient=e.result.coefficient.convertFromDER()}toSchema(){return new K({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:w(y(this.prime.valueBlock.valueHex),!0,!0),d:w(y(this.exponent.valueBlock.valueHex),!0,!0),t:w(y(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(t){if(!("r"in t))throw new Error('Absent mandatory parameter "r"');if(this.prime=new q({valueHex:b(d(t.r,!0))}),!("d"in t))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new q({valueHex:b(d(t.d,!0))}),!("t"in t))throw new Error('Absent mandatory parameter "t"');this.coefficient=new q({valueHex:b(d(t.t,!0))})}}class Vt{constructor(t={}){this.version=r(t,"version",Vt.defaultValues("version")),this.modulus=r(t,"modulus",Vt.defaultValues("modulus")),this.publicExponent=r(t,"publicExponent",Vt.defaultValues("publicExponent")),this.privateExponent=r(t,"privateExponent",Vt.defaultValues("privateExponent")),this.prime1=r(t,"prime1",Vt.defaultValues("prime1")),this.prime2=r(t,"prime2",Vt.defaultValues("prime2")),this.exponent1=r(t,"exponent1",Vt.defaultValues("exponent1")),this.exponent2=r(t,"exponent2",Vt.defaultValues("exponent2")),this.coefficient=r(t,"coefficient",Vt.defaultValues("coefficient")),"otherPrimeInfos"in t&&(this.otherPrimeInfos=r(t,"otherPrimeInfos",Vt.defaultValues("otherPrimeInfos"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new q;case"otherPrimeInfos":return[];default:throw new Error(`Invalid member name for RSAPrivateKey class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new q({name:e.version||""}),new q({name:e.modulus||""}),new q({name:e.publicExponent||""}),new q({name:e.privateExponent||""}),new q({name:e.prime1||""}),new q({name:e.prime2||""}),new q({name:e.exponent1||""}),new q({name:e.exponent2||""}),new q({name:e.coefficient||""}),new K({optional:!0,value:[new Pt({name:e.otherPrimeInfosName||"",value:Tt.schema(e.otherPrimeInfo||{})})]})]})}fromSchema(t){A(t,["version","modulus","publicExponent","privateExponent","prime1","prime2","exponent1","exponent2","coefficient","otherPrimeInfos"]);const e=It(t,t,Vt.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=e.result.version.valueBlock.valueDec,this.modulus=e.result.modulus.convertFromDER(256),this.publicExponent=e.result.publicExponent,this.privateExponent=e.result.privateExponent.convertFromDER(256),this.prime1=e.result.prime1.convertFromDER(128),this.prime2=e.result.prime2.convertFromDER(128),this.exponent1=e.result.exponent1.convertFromDER(128),this.exponent2=e.result.exponent2.convertFromDER(128),this.coefficient=e.result.coefficient.convertFromDER(128),"otherPrimeInfos"in e.result&&(this.otherPrimeInfos=Array.from(e.result.otherPrimeInfos,t=>new Tt({schema:t})))}toSchema(){const t=[];return t.push(new q({value:this.version})),t.push(this.modulus.convertToDER()),t.push(this.publicExponent),t.push(this.privateExponent.convertToDER()),t.push(this.prime1.convertToDER()),t.push(this.prime2.convertToDER()),t.push(this.exponent1.convertToDER()),t.push(this.exponent2.convertToDER()),t.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&t.push(new K({value:Array.from(this.otherPrimeInfos,t=>t.toSchema())})),new K({value:t})}toJSON(){const t={n:w(y(this.modulus.valueBlock.valueHex),!0,!0,!0),e:w(y(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:w(y(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:w(y(this.prime1.valueBlock.valueHex),!0,!0,!0),q:w(y(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:w(y(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:w(y(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:w(y(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(t.oth=Array.from(this.otherPrimeInfos,t=>t.toJSON())),t}fromJSON(t){if(!("n"in t))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new q({valueHex:b(d(t.n,!0,!0))}),!("e"in t))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new q({valueHex:b(d(t.e,!0,!0))}),!("d"in t))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new q({valueHex:b(d(t.d,!0,!0))}),!("p"in t))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new q({valueHex:b(d(t.p,!0,!0))}),!("q"in t))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new q({valueHex:b(d(t.q,!0,!0))}),!("dp"in t))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new q({valueHex:b(d(t.dp,!0,!0))}),!("dq"in t))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new q({valueHex:b(d(t.dq,!0,!0))}),!("qi"in t))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new q({valueHex:b(d(t.qi,!0,!0))}),"oth"in t&&(this.otherPrimeInfos=Array.from(t.oth,t=>new Tt({json:t})))}}class Mt{constructor(t={}){this.version=r(t,"version",Mt.defaultValues("version")),this.privateKeyAlgorithm=r(t,"privateKeyAlgorithm",Mt.defaultValues("privateKeyAlgorithm")),this.privateKey=r(t,"privateKey",Mt.defaultValues("privateKey")),"attributes"in t&&(this.attributes=r(t,"attributes",Mt.defaultValues("attributes"))),"parsedKey"in t&&(this.parsedKey=r(t,"parsedKey",Mt.defaultValues("parsedKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(t){switch(t){case"version":return 0;case"privateKeyAlgorithm":return new Ot;case"privateKey":return new M;case"attributes":return[];case"parsedKey":return{};default:throw new Error(`Invalid member name for PrivateKeyInfo class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new q({name:e.version||""}),Ot.schema(e.privateKeyAlgorithm||{}),new M({name:e.privateKey||""}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Pt({name:e.attributes||"",value:Kt.schema()})]})]})}fromSchema(t){A(t,["version","privateKeyAlgorithm","privateKey","attributes"]);const e=It(t,t,Mt.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");switch(this.version=e.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new Ot({schema:e.result.privateKeyAlgorithm}),this.privateKey=e.result.privateKey,"attributes"in e.result&&(this.attributes=Array.from(e.result.attributes,t=>new Kt({schema:t}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const t=Bt(this.privateKey.valueBlock.valueHex);-1!==t.offset&&(this.parsedKey=new Vt({schema:t.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof Q){const t=Bt(this.privateKey.valueBlock.valueHex);-1!==t.offset&&(this.parsedKey=new $t({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:t.result}))}}}toSchema(){const t=[new q({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&t.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,t=>t.toSchema())})),new K({value:t})}toJSON(){if("parsedKey"in this==0){const t={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(t.attributes=Array.from(this.attributes,t=>t.toJSON())),t}const t={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":t.kty="EC";break;case"1.2.840.113549.1.1.1":t.kty="RSA"}const e=this.parsedKey.toJSON();for(const r of Object.keys(e))t[r]=e[r];return t}fromJSON(t){if("kty"in t){switch(t.kty.toUpperCase()){case"EC":this.parsedKey=new $t({json:t}),this.privateKeyAlgorithm=new Ot({algorithmId:"1.2.840.10045.2.1",algorithmParams:new Q({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Vt({json:t}),this.privateKeyAlgorithm=new Ot({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new T});break;default:throw new Error(`Invalid value for "kty" parameter: ${t.kty}`)}this.privateKey=new M({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class Jt{constructor(t={}){if(this.contentType=r(t,"contentType",Jt.defaultValues("contentType")),this.contentEncryptionAlgorithm=r(t,"contentEncryptionAlgorithm",Jt.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in t&&(this.encryptedContent=t.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const t=new M({idBlock:{isConstructed:!0},isConstructed:!0});let e=0,r=this.encryptedContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.encryptedContent.valueBlock.valueHex,e,e+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-e:1024),i=new ArrayBuffer(s.length),n=new Uint8Array(i);for(let t=0;t<n.length;t++)n[t]=s[t];t.valueBlock.value.push(new M({valueHex:i})),r-=s.length,e+=s.length}this.encryptedContent=t}"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"contentType":return"";case"contentEncryptionAlgorithm":return new Ot;case"encryptedContent":return new M;default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"contentType":return""===e;case"contentEncryptionAlgorithm":return""===e.algorithmId&&"algorithmParams"in e==0;case"encryptedContent":return e.isEqual(Jt.defaultValues(t));default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.contentType||""}),Ot.schema(e.contentEncryptionAlgorithm||{}),new kt({value:[new D({name:e.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new Pt({value:new M})]}),new U({name:e.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(t){A(t,["contentType","contentEncryptionAlgorithm","encryptedContent"]);const e=It(t,t,Jt.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=e.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new Ot({schema:e.result.contentEncryptionAlgorithm}),"encryptedContent"in e.result&&(this.encryptedContent=e.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const t={isIndefiniteForm:!1},e=[];if(e.push(new Q({value:this.contentType})),e.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){t.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,e.push(r)}return new K({lenBlock:t,value:e})}toJSON(){const t={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(t.encryptedContent=this.encryptedContent.toJSON()),t}}class Lt{constructor(t={}){this.hashAlgorithm=r(t,"hashAlgorithm",Lt.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=r(t,"maskGenAlgorithm",Lt.defaultValues("maskGenAlgorithm")),this.saltLength=r(t,"saltLength",Lt.defaultValues("saltLength")),this.trailerField=r(t,"trailerField",Lt.defaultValues("trailerField")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"hashAlgorithm":return new Ot({algorithmId:"1.3.14.3.2.26",algorithmParams:new T});case"maskGenAlgorithm":return new Ot({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Ot({algorithmId:"1.3.14.3.2.26",algorithmParams:new T}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error(`Invalid member name for RSASSAPSSParams class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new D({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Ot.schema(e.hashAlgorithm||{})]}),new D({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Ot.schema(e.maskGenAlgorithm||{})]}),new D({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new q({name:e.saltLength||""})]}),new D({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new q({name:e.trailerField||""})]})]})}fromSchema(t){A(t,["hashAlgorithm","maskGenAlgorithm","saltLength","trailerField"]);const e=It(t,t,Lt.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");"hashAlgorithm"in e.result&&(this.hashAlgorithm=new Ot({schema:e.result.hashAlgorithm})),"maskGenAlgorithm"in e.result&&(this.maskGenAlgorithm=new Ot({schema:e.result.maskGenAlgorithm})),"saltLength"in e.result&&(this.saltLength=e.result.saltLength.valueBlock.valueDec),"trailerField"in e.result&&(this.trailerField=e.result.trailerField.valueBlock.valueDec)}toSchema(){const t=[];return this.hashAlgorithm.isEqual(Lt.defaultValues("hashAlgorithm"))||t.push(new D({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Lt.defaultValues("maskGenAlgorithm"))||t.push(new D({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Lt.defaultValues("saltLength")&&t.push(new D({idBlock:{tagClass:3,tagNumber:2},value:[new q({value:this.saltLength})]})),this.trailerField!==Lt.defaultValues("trailerField")&&t.push(new D({idBlock:{tagClass:3,tagNumber:3},value:[new q({value:this.trailerField})]})),new K({value:t})}toJSON(){const t={};return this.hashAlgorithm.isEqual(Lt.defaultValues("hashAlgorithm"))||(t.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Lt.defaultValues("maskGenAlgorithm"))||(t.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Lt.defaultValues("saltLength")&&(t.saltLength=this.saltLength),this.trailerField!==Lt.defaultValues("trailerField")&&(t.trailerField=this.trailerField),t}}class Ft{constructor(t={}){this.salt=r(t,"salt",Ft.defaultValues("salt")),this.iterationCount=r(t,"iterationCount",Ft.defaultValues("iterationCount")),"keyLength"in t&&(this.keyLength=r(t,"keyLength",Ft.defaultValues("keyLength"))),"prf"in t&&(this.prf=r(t,"prf",Ft.defaultValues("prf"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new Ot({algorithmId:"1.3.14.3.2.26",algorithmParams:new T});default:throw new Error(`Invalid member name for PBKDF2Params class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new kt({value:[new M({name:e.saltPrimitive||""}),Ot.schema(e.saltConstructed||{})]}),new q({name:e.iterationCount||""}),new q({name:e.keyLength||"",optional:!0}),Ot.schema(e.prf||{names:{optional:!0}})]})}fromSchema(t){A(t,["salt","iterationCount","keyLength","prf"]);const e=It(t,t,Ft.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PBKDF2Params");this.salt=e.result.salt,this.iterationCount=e.result.iterationCount.valueBlock.valueDec,"keyLength"in e.result&&(this.keyLength=e.result.keyLength.valueBlock.valueDec),"prf"in e.result&&(this.prf=new Ot({schema:e.result.prf}))}toSchema(){const t=[];return t.push(this.salt),t.push(new q({value:this.iterationCount})),"keyLength"in this&&Ft.defaultValues("keyLength")!==this.keyLength&&t.push(new q({value:this.keyLength})),"prf"in this&&!1===Ft.defaultValues("prf").isEqual(this.prf)&&t.push(this.prf.toSchema()),new K({value:t})}toJSON(){const t={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&Ft.defaultValues("keyLength")!==this.keyLength&&(t.keyLength=this.keyLength),"prf"in this&&!1===Ft.defaultValues("prf").isEqual(this.prf)&&(t.prf=this.prf.toJSON()),t}}class qt{constructor(t={}){this.keyDerivationFunc=r(t,"keyDerivationFunc",qt.defaultValues("keyDerivationFunc")),this.encryptionScheme=r(t,"encryptionScheme",qt.defaultValues("encryptionScheme")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"keyDerivationFunc":case"encryptionScheme":return new Ot;default:throw new Error(`Invalid member name for PBES2Params class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[Ot.schema(e.keyDerivationFunc||{}),Ot.schema(e.encryptionScheme||{})]})}fromSchema(t){A(t,["keyDerivationFunc","encryptionScheme"]);const e=It(t,t,qt.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PBES2Params");this.keyDerivationFunc=new Ot({schema:e.result.keyDerivationFunc}),this.encryptionScheme=new Ot({schema:e.result.encryptionScheme})}toSchema(){return new K({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Wt(t,e,r,s,i,n){let a,o;const h=[];switch(e.toUpperCase()){case"SHA-1":a=20,o=64;break;case"SHA-256":a=32,o=64;break;case"SHA-384":a=48,o=128;break;case"SHA-512":a=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const c=new Uint8Array(s),u=new ArrayBuffer(2*s.byteLength+2),l=new Uint8Array(u);for(let B=0;B<c.length;B++)l[2*B]=0,l[2*B+1]=c[B];l[l.length-2]=0,l[l.length-1]=0,s=u.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let B=0;B<m.byteLength;B++)f[B]=3;const w=i.byteLength,d=o*Math.ceil(w/o),y=new ArrayBuffer(d),b=new Uint8Array(y),p=new Uint8Array(i);for(let B=0;B<d;B++)b[B]=p[B%w];const g=s.byteLength,A=o*Math.ceil(g/o),v=new ArrayBuffer(A),S=new Uint8Array(v),k=new Uint8Array(s);for(let B=0;B<A;B++)S[B]=k[B%g];let C=new ArrayBuffer(y.byteLength+v.byteLength),P=new Uint8Array(C);P.set(b),P.set(S,b.length);const E=Math.ceil((r>>3)/a);let N=Promise.resolve(C);for(let B=0;B<=E;B++){N=N.then(t=>{const e=new ArrayBuffer(m.byteLength+t.byteLength),r=new Uint8Array(e);return r.set(f),r.set(P,f.length),e});for(let r=0;r<n;r++)N=N.then(r=>t.digest({name:e},new Uint8Array(r)));N=N.then(t=>{const e=new ArrayBuffer(o),r=new Uint8Array(e);for(let o=0;o<e.byteLength;o++)r[o]=t[o%t.length];const s=Math.ceil(w/o)+Math.ceil(g/o),i=[];let n=0,a=o;for(let h=0;h<s;h++){const t=Array.from(new Uint8Array(C.slice(n,n+a)));(n+=o)+o>C.byteLength&&(a=C.byteLength-n);let s=511;for(let i=e.byteLength-1;i>=0;i--)s>>=8,t[i]=255&(s+=r[i]+t[i]);i.push(...t)}return C=new ArrayBuffer(i.length),(P=new Uint8Array(C)).set(i),h.push(...new Uint8Array(t)),C})}return N.then(()=>{const t=new ArrayBuffer(r>>3);return new Uint8Array(t).set(new Uint8Array(h).slice(0,r>>3)),t})}class Gt{constructor(t={}){this.crypto=r(t,"crypto",{}),this.subtle=r(t,"subtle",{}),this.name=r(t,"name","")}importKey(t,e,r,s,i){let n={};switch(e instanceof Uint8Array&&(e=e.buffer),t.toLowerCase()){case"raw":return this.subtle.importKey("raw",e,r,s,i);case"spki":{const t=Bt(e);if(-1===t.offset)return Promise.reject("Incorrect keyData");const o=new jt;try{o.fromSchema(t.result)}catch(a){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(i=["verify"],n.kty="RSA",n.ext=s,n.key_ops=i,"1.2.840.113549.1.1.1"!==o.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`);if("alg"in n==0)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`)}const t=o.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"ECDSA":i=["verify"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:i},"1.2.840.10045.2.1"!==o.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`);const t=o.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=i,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`)}const t=o.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"pkcs8":{const t=new Mt,o=Bt(e);if(-1===o.offset)return Promise.reject("Incorrect keyData");try{t.fromSchema(o.result)}catch(a){return Promise.reject("Incorrect keyData")}if("parsedKey"in t==0)return Promise.reject("Incorrect keyData");switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(i=["sign"],n.kty="RSA",n.ext=s,n.key_ops=i,"1.2.840.113549.1.1.1"!==t.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect private key algorithm: ${t.privateKeyAlgorithm.algorithmId}`);if("alg"in n==0)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const e=t.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"ECDSA":i=["sign"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:i},"1.2.840.10045.2.1"!==t.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect algorithm: ${t.privateKeyAlgorithm.algorithmId}`);const e=t.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=i,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const e=t.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"jwk":n=e;break;default:return Promise.reject(`Incorrect format: ${t}`)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",b(JSON.stringify(n)),r,s,i)).then(t=>t,()=>this.subtle.importKey("jwk",n,r,s,i)):this.subtle.importKey("jwk",n,r,s,i)}exportKey(t,e){let r=this.subtle.exportKey("jwk",e);switch("safari"===this.name.toLowerCase()&&(r=r.then(t=>t instanceof ArrayBuffer?JSON.parse(y(t)):t)),t.toLowerCase()){case"raw":return this.subtle.exportKey("raw",e);case"spki":r=r.then(t=>{const e=new jt;try{e.fromJSON(t)}catch(r){return Promise.reject("Incorrect key data")}return e.toSchema().toBER(!1)});break;case"pkcs8":r=r.then(t=>{const e=new Mt;try{e.fromJSON(t)}catch(r){return Promise.reject("Incorrect key data")}return e.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject(`Incorrect format: ${t}`)}return r}convert(t,e,r,s,i,n){switch(t.toLowerCase()){case"raw":switch(e.toLowerCase()){case"raw":return Promise.resolve(r);case"spki":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,n)).then(t=>this.exportKey("spki",t));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,n)).then(t=>this.exportKey("pkcs8",t));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,n)).then(t=>this.exportKey("jwk",t));default:return Promise.reject(`Incorrect outputFormat: ${e}`)}case"spki":switch(e.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",r,s,i,n)).then(t=>this.exportKey("raw",t));case"spki":return Promise.resolve(r);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",r,s,i,n)).then(t=>this.exportKey("jwk",t));default:return Promise.reject(`Incorrect outputFormat: ${e}`)}case"pkcs8":switch(e.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,i,n)).then(t=>this.exportKey("raw",t));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(r);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,i,n)).then(t=>this.exportKey("jwk",t));default:return Promise.reject(`Incorrect outputFormat: ${e}`)}case"jwk":switch(e.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,n)).then(t=>this.exportKey("raw",t));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,n)).then(t=>this.exportKey("spki",t));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,n)).then(t=>this.exportKey("pkcs8",t));case"jwk":return Promise.resolve(r);default:return Promise.reject(`Incorrect outputFormat: ${e}`)}default:return Promise.reject(`Incorrect inputFormat: ${t}`)}}encrypt(...t){return this.subtle.encrypt(...t)}decrypt(...t){return this.subtle.decrypt(...t)}sign(...t){return this.subtle.sign(...t)}verify(...t){return this.subtle.verify(...t)}digest(...t){return this.subtle.digest(...t)}generateKey(...t){return this.subtle.generateKey(...t)}deriveKey(...t){return this.subtle.deriveKey(...t)}deriveBits(...t){return this.subtle.deriveBits(...t)}wrapKey(...t){return this.subtle.wrapKey(...t)}unwrapKey(...t){return this.subtle.unwrapKey(...t)}getRandomValues(t){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(t)}getAlgorithmByOID(t){switch(t){case"1.2.840.113549.1.1.1":case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(t){let e="";switch(t.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(t.hash.name.toUpperCase()){case"SHA-1":e="1.2.840.113549.1.1.5";break;case"SHA-256":e="1.2.840.113549.1.1.11";break;case"SHA-384":e="1.2.840.113549.1.1.12";break;case"SHA-512":e="1.2.840.113549.1.1.13"}break;case"RSA-PSS":e="1.2.840.113549.1.1.10";break;case"RSA-OAEP":e="1.2.840.113549.1.1.7";break;case"ECDSA":switch(t.hash.name.toUpperCase()){case"SHA-1":e="1.2.840.10045.4.1";break;case"SHA-256":e="1.2.840.10045.4.3.2";break;case"SHA-384":e="1.2.840.10045.4.3.3";break;case"SHA-512":e="1.2.840.10045.4.3.4"}break;case"ECDH":switch(t.kdf.toUpperCase()){case"SHA-1":e="1.3.133.16.840.63.0.2";break;case"SHA-256":e="1.3.132.1.11.1";break;case"SHA-384":e="1.3.132.1.11.2";break;case"SHA-512":e="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(t.length){case 128:e="2.16.840.1.101.3.4.1.2";break;case 192:e="2.16.840.1.101.3.4.1.22";break;case 256:e="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(t.length){case 128:e="2.16.840.1.101.3.4.1.6";break;case 192:e="2.16.840.1.101.3.4.1.26";break;case 256:e="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(t.length){case 128:e="2.16.840.1.101.3.4.1.4";break;case 192:e="2.16.840.1.101.3.4.1.24";break;case 256:e="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(t.length){case 128:e="2.16.840.1.101.3.4.1.5";break;case 192:e="2.16.840.1.101.3.4.1.25";break;case 256:e="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(t.hash.name.toUpperCase()){case"SHA-1":e="1.2.840.113549.2.7";break;case"SHA-256":e="1.2.840.113549.2.9";break;case"SHA-384":e="1.2.840.113549.2.10";break;case"SHA-512":e="1.2.840.113549.2.11"}break;case"DH":e="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":e="1.3.14.3.2.26";break;case"SHA-256":e="2.16.840.1.101.3.4.2.1";break;case"SHA-384":e="2.16.840.1.101.3.4.2.2";break;case"SHA-512":e="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":e="1.2.840.113549.1.5.12";break;case"P-256":e="1.2.840.10045.3.1.7";break;case"P-384":e="1.3.132.0.34";break;case"P-521":e="1.3.132.0.35"}return e}getAlgorithmParameters(t,e){let r={algorithm:{},usages:[]};switch(t.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(e.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(e.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(e.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(e.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(e.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(e.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(e.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(e.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(e.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(e.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(e.toLowerCase()){case"derivekey":r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(e.toLowerCase()){case"derivekey":r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return r}getHashAlgorithm(t){let e="";switch(t.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":e="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":e="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":e="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":e="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new Lt({schema:t.algorithmParams});if("hashAlgorithm"in r){const t=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if("name"in t==0)return"";e=t.name}else e="SHA-1"}catch(r){}}return e}encryptEncryptedContentInfo(t){if(t instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in t==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in t==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in t==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in t==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in t==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in t==0)return Promise.reject('Absent mandatory parameter "contentType"');const e=this.getOIDByAlgorithm(t.contentEncryptionAlgorithm);if(""===e)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const r=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===r)return Promise.reject("Can not find OID for PBKDF2");const s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}});if(""===s)return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${t.hmacHashAlgorithm}`);let i=Promise.resolve();const n=new ArrayBuffer(16),a=new Uint8Array(n);this.getRandomValues(a);const o=new ArrayBuffer(64),h=new Uint8Array(o);this.getRandomValues(h);const c=new Uint8Array(t.contentToEncrypt),u=new Ft({salt:new M({valueHex:o}),iterationCount:t.iterationCount,prf:new Ot({algorithmId:s,algorithmParams:new T})});return(i=(i=(i=i.then(()=>{const e=new Uint8Array(t.password);return this.importKey("raw",e,"PBKDF2",!1,["deriveKey"])},t=>Promise.reject(t))).then(e=>this.deriveKey({name:"PBKDF2",hash:{name:t.hmacHashAlgorithm},salt:h,iterations:t.iterationCount},e,t.contentEncryptionAlgorithm,!1,["encrypt"]),t=>Promise.reject(t))).then(e=>this.encrypt({name:t.contentEncryptionAlgorithm.name,iv:a},e,c),t=>Promise.reject(t))).then(s=>{const i=new qt({keyDerivationFunc:new Ot({algorithmId:r,algorithmParams:u.toSchema()}),encryptionScheme:new Ot({algorithmId:e,algorithmParams:new M({valueHex:n})})});return new Jt({contentType:t.contentType,contentEncryptionAlgorithm:new Ot({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:i.toSchema()}),encryptedContent:new M({valueHex:s})})},t=>Promise.reject(t))}decryptEncryptedContentInfo(t){if(t instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in t==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in t==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==t.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${t.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let e,r,s=Promise.resolve();try{e=new qt({schema:t.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(u){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}try{r=new Ft({schema:e.keyDerivationFunc.algorithmParams})}catch(u){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const i=this.getAlgorithmByOID(e.encryptionScheme.algorithmId);if("name"in i==0)return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${e.encryptionScheme.algorithmId}`);const n=new Uint8Array(e.encryptionScheme.algorithmParams.valueBlock.valueHex),a=new Uint8Array(r.salt.valueBlock.valueHex),h=r.iterationCount;let c="SHA-1";if("prf"in r){const t=this.getAlgorithmByOID(r.prf.algorithmId);if("name"in t==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");c=t.hash.name}return(s=(s=s.then(()=>this.importKey("raw",t.password,"PBKDF2",!1,["deriveKey"]),t=>Promise.reject(t))).then(t=>this.deriveKey({name:"PBKDF2",hash:{name:c},salt:a,iterations:h},t,i,!1,["decrypt"]),t=>Promise.reject(t))).then(e=>{let r=new ArrayBuffer(0);if(!1===t.encryptedContentInfo.encryptedContent.idBlock.isConstructed)r=t.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const s of t.encryptedContentInfo.encryptedContent.valueBlock.value)r=o(r,s.valueBlock.valueHex);return this.decrypt({name:i.name,iv:n},e,r)},t=>Promise.reject(t))}stampDataWithPassword(t){if(t instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in t==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in t==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in t==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in t==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in t==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let e;switch(t.hashAlgorithm.toLowerCase()){case"sha-1":e=160;break;case"sha-256":e=256;break;case"sha-384":e=384;break;case"sha-512":e=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${t.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:e,hash:{name:t.hashAlgorithm}};return(r=(r=r.then(()=>Wt(this,t.hashAlgorithm,e,t.password,t.salt,t.iterationCount))).then(t=>this.importKey("raw",new Uint8Array(t),s,!1,["sign"]))).then(e=>this.sign(s,e,new Uint8Array(t.contentToStamp)),t=>Promise.reject(t))}verifyDataStampedWithPassword(t){if(t instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in t==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in t==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in t==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in t==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in t==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in t==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let e;switch(t.hashAlgorithm.toLowerCase()){case"sha-1":e=160;break;case"sha-256":e=256;break;case"sha-384":e=384;break;case"sha-512":e=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${t.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:e,hash:{name:t.hashAlgorithm}};return(r=(r=r.then(()=>Wt(this,t.hashAlgorithm,e,t.password,t.salt,t.iterationCount))).then(t=>this.importKey("raw",new Uint8Array(t),s,!1,["verify"]))).then(e=>this.verify(s,e,new Uint8Array(t.signatureToVerify),new Uint8Array(t.contentToVerify)),t=>Promise.reject(t))}getSignatureParameters(t,e="SHA-1"){if(""===this.getOIDByAlgorithm({name:e}))return Promise.reject(`Unsupported hash algorithm: ${e}`);const r=new Ot,s=this.getAlgorithmParameters(t.algorithm.name,"sign");switch(s.algorithm.hash.name=e,t.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":r.algorithmId=this.getOIDByAlgorithm(s.algorithm);break;case"RSA-PSS":{switch(e.toUpperCase()){case"SHA-256":s.algorithm.saltLength=32;break;case"SHA-384":s.algorithm.saltLength=48;break;case"SHA-512":s.algorithm.saltLength=64}const t={};if("SHA-1"!==e.toUpperCase()){const r=this.getOIDByAlgorithm({name:e});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${e}`);t.hashAlgorithm=new Ot({algorithmId:r,algorithmParams:new T}),t.maskGenAlgorithm=new Ot({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:t.hashAlgorithm.toSchema()})}20!==s.algorithm.saltLength&&(t.saltLength=s.algorithm.saltLength);const i=new Lt(t);r.algorithmId="1.2.840.113549.1.1.10",r.algorithmParams=i.toSchema()}break;default:return Promise.reject(`Unsupported signature algorithm: ${t.algorithm.name}`)}return Promise.resolve().then(()=>({signatureAlgorithm:r,parameters:s}))}signWithPrivateKey(t,e,r){return this.sign(r.algorithm,e,new Uint8Array(t)).then(t=>("ECDSA"===r.algorithm.name&&(t=function(t){if(t.byteLength%2!=0)return new ArrayBuffer(0);const e=t.byteLength/2,r=new ArrayBuffer(e);new Uint8Array(r).set(new Uint8Array(t,0,e));const s=new q({valueHex:r}),i=new ArrayBuffer(e);new Uint8Array(i).set(new Uint8Array(t,e,e));const n=new q({valueHex:i});return new K({value:[s.convertToDER(),n.convertToDER()]}).toBER(!1)}(t)),t),t=>Promise.reject(`Signing error: ${t}`))}fillPublicKeyParameters(t,e){const r={},s=this.getHashAlgorithm(e);if(""===s)return Promise.reject(`Unsupported signature algorithm: ${e.algorithmId}`);let i;const n=this.getAlgorithmByOID(i="1.2.840.113549.1.1.10"===e.algorithmId?e.algorithmId:t.algorithm.algorithmId);if("name"in n==="")return Promise.reject(`Unsupported public key algorithm: ${e.algorithmId}`);if(r.algorithm=this.getAlgorithmParameters(n.name,"importkey"),"hash"in r.algorithm.algorithm&&(r.algorithm.algorithm.hash.name=s),"ECDSA"===n.name){let e=!1;if("algorithmParams"in t.algorithm==1&&"idBlock"in t.algorithm.algorithmParams&&1===t.algorithm.algorithmParams.idBlock.tagClass&&6===t.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(t.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject(`Unsupported named curve algorithm: ${t.algorithm.algorithmParams.valueBlock.toString()}`);r.algorithm.algorithm.namedCurve=s.name}return r}getPublicKey(t,e,r=null){null===r&&(r=this.fillPublicKeyParameters(t,e));const s=t.toSchema().toBER(!1),i=new Uint8Array(s);return this.importKey("spki",i,r.algorithm.algorithm,!0,r.algorithm.usages)}verifyWithPublicKey(t,e,r,s,i=null){let n=Promise.resolve();if(null===i){if(""===(i=this.getHashAlgorithm(s)))return Promise.reject(`Unsupported signature algorithm: ${s.algorithmId}`);n=n.then(()=>this.getPublicKey(r,s))}else{const t={};let e;const a=this.getAlgorithmByOID(e="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:r.algorithm.algorithmId);if("name"in a==="")return Promise.reject(`Unsupported public key algorithm: ${s.algorithmId}`);if(t.algorithm=this.getAlgorithmParameters(a.name,"importkey"),"hash"in t.algorithm.algorithm&&(t.algorithm.algorithm.hash.name=i),"ECDSA"===a.name){let e=!1;if("algorithmParams"in r.algorithm==1&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject(`Unsupported named curve algorithm: ${r.algorithm.algorithmParams.valueBlock.toString()}`);t.algorithm.algorithm.namedCurve=s.name}n=n.then(()=>this.getPublicKey(r,null,t))}return n.then(r=>{const n=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=i);let a=e.valueBlock.valueHex;if("ECDSA"===r.algorithm.name&&(a=function(t){if(t instanceof K==0)return new ArrayBuffer(0);if(2!==t.valueBlock.value.length)return new ArrayBuffer(0);if(t.valueBlock.value[0]instanceof q==0)return new ArrayBuffer(0);if(t.valueBlock.value[1]instanceof q==0)return new ArrayBuffer(0);const e=t.valueBlock.value[0].convertFromDER(),r=t.valueBlock.value[1].convertFromDER();switch(!0){case e.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-e.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const t=r.valueBlock.valueHex.byteLength,s=new Uint8Array(e.valueBlock.valueHex),i=new ArrayBuffer(t),n=new Uint8Array(i);return n.set(s,1),n[0]=0,o(i,r.valueBlock.valueHex)}case e.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(e.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const t=e.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),i=new ArrayBuffer(t),n=new Uint8Array(i);return n.set(s,1),n[0]=0,o(e.valueBlock.valueHex,i)}default:if(e.valueBlock.valueHex.byteLength%2){const t=e.valueBlock.valueHex.byteLength+1,s=new Uint8Array(e.valueBlock.valueHex),i=new ArrayBuffer(t),n=new Uint8Array(i);n.set(s,1),n[0]=0;const a=new Uint8Array(r.valueBlock.valueHex),h=new ArrayBuffer(t),c=new Uint8Array(h);return c.set(a,1),c[0]=0,o(i,h)}}return o(e.valueBlock.valueHex,r.valueBlock.valueHex)}(Bt(a).result)),"RSA-PSS"===r.algorithm.name){let t;try{t=new Lt({schema:s.algorithmParams})}catch(h){return Promise.reject(h)}n.algorithm.saltLength="saltLength"in t?t.saltLength:20;let e="SHA-1";if("hashAlgorithm"in t){const r=this.getAlgorithmByOID(t.hashAlgorithm.algorithmId);if("name"in r==0)return Promise.reject(`Unrecognized hash algorithm: ${t.hashAlgorithm.algorithmId}`);e=r.name}n.algorithm.hash.name=e}return this.verify(n.algorithm,r,new Uint8Array(a),new Uint8Array(t))})}}let _t={name:"none",crypto:null,subtle:null};function Qt(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let e;try{e=global[process.pid].pkijs.engine}catch(t){throw new Error('Please call "setEngine" before call to "getEngine"')}return e}return _t}function Zt(){const t=Qt();if(null!==t.subtle)return t.subtle}function Yt(t){let e=!1,r="";const s=t.trim();for(let i=0;i<s.length;i++)32===s.charCodeAt(i)?!1===e&&(e=!0):(e&&(r+=" ",e=!1),r+=s[i]);return r.toLowerCase()}!function(){if("undefined"!=typeof self&&"crypto"in self){let e="webcrypto";const r=self.crypto;let s;if("webkitSubtle"in self.crypto){try{s=self.crypto.webkitSubtle}catch(t){s=self.crypto.subtle}e="safari"}"subtle"in self.crypto&&(s=self.crypto.subtle),_t=void 0===s?{name:e,crypto:r,subtle:null}:{name:e,crypto:r,subtle:new Gt({name:e,crypto:self.crypto,subtle:s})}}!function(t,e,r){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:t,crypto:e,subtle:r}}else _t={name:t,crypto:e,subtle:r}}(_t.name,_t.crypto,_t.subtle)}();class zt{constructor(t={}){this.type=r(t,"type",zt.defaultValues("type")),this.value=r(t,"value",zt.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"type":return"";case"value":return{};default:throw new Error(`Invalid member name for AttributeTypeAndValue class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.type||""}),new Ct({name:e.value||""})]})}static blockName(){return"AttributeTypeAndValue"}fromSchema(t){A(t,["type","typeValue"]);const e=It(t,t,zt.schema({names:{type:"type",value:"typeValue"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");this.type=e.result.type.valueBlock.toString(),this.value=e.result.typeValue}toSchema(){return new K({value:[new Q({value:this.type}),this.value]})}toJSON(){const t={type:this.type};return t.value=0!==Object.keys(this.value).length?this.value.toJSON():this.value,t}isEqual(t){const e=[Y.blockName(),rt.blockName(),it.blockName(),ot.blockName(),ht.blockName(),ct.blockName(),ut.blockName(),lt.blockName(),mt.blockName(),ft.blockName(),wt.blockName(),dt.blockName()];if(t.constructor.blockName()===zt.blockName()){if(this.type!==t.type)return!1;let r=!1;const s=this.value.constructor.blockName();if(s===t.value.constructor.blockName())for(const t of e)if(s===t){r=!0;break}if(r){const e=Yt(this.value.valueBlock.value),r=Yt(t.value.valueBlock.value);if(0!==e.localeCompare(r))return!1}else if(!1===u(this.value.valueBeforeDecode,t.value.valueBeforeDecode))return!1;return!0}return t instanceof ArrayBuffer&&u(this.value.valueBeforeDecode,t)}}class Xt{constructor(t={}){this.typesAndValues=r(t,"typesAndValues",Xt.defaultValues("typesAndValues")),this.valueBeforeDecode=r(t,"valueBeforeDecode",Xt.defaultValues("valueBeforeDecode")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"typesAndValues":return 0===e.length;case"valueBeforeDecode":return 0===e.byteLength;default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.repeatedSequence||"",value:new $({value:[new Pt({name:e.repeatedSet||"",value:zt.schema(e.typeAndValue||{})})]})})]})}fromSchema(t){A(t,["RDN","typesAndValues"]);const e=It(t,t,Xt.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");"typesAndValues"in e.result&&(this.typesAndValues=Array.from(e.result.typesAndValues,t=>new zt({schema:t}))),this.valueBeforeDecode=e.result.RDN.valueBeforeDecode}toSchema(){return 0===this.valueBeforeDecode.byteLength?new K({value:[new $({value:Array.from(this.typesAndValues,t=>t.toSchema())})]}):Bt(this.valueBeforeDecode).result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,t=>t.toJSON())}}isEqual(t){if(t instanceof Xt){if(this.typesAndValues.length!==t.typesAndValues.length)return!1;for(const[e,r]of this.typesAndValues.entries())if(!1===r.isEqual(t.typesAndValues[e]))return!1;return!0}return t instanceof ArrayBuffer&&u(this.valueBeforeDecode,t)}}class te{constructor(t={}){this.type=r(t,"type",te.defaultValues("type")),this.value=r(t,"value",te.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error(`Invalid member name for Time class: ${t}`)}}static schema(t={},e=!1){const s=r(t,"names",{});return new kt({optional:e,value:[new yt({name:s.utcTimeName||""}),new bt({name:s.generalTimeName||""})]})}fromSchema(t){A(t,["utcTimeName","generalTimeName"]);const e=It(t,t,te.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for Time");"utcTimeName"in e.result&&(this.type=0,this.value=e.result.utcTimeName.toDate()),"generalTimeName"in e.result&&(this.type=1,this.value=e.result.generalTimeName.toDate())}toSchema(){let t={};return 0===this.type&&(t=new yt({valueDate:this.value})),1===this.type&&(t=new bt({valueDate:this.value})),t}toJSON(){return{type:this.type,value:this.value}}}class ee{constructor(t={}){this.attributes=r(t,"attributes",ee.defaultValues("attributes")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"attributes":return[];default:throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.attributes||"",value:Kt.schema()})]})}fromSchema(t){A(t,["attributes"]);const e=It(t,t,ee.schema({names:{attributes:"attributes"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(e.result.attributes,t=>new Kt({schema:t}))}toSchema(){return new K({value:Array.from(this.attributes,t=>t.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,t=>t.toJSON())}}}class re{constructor(t={}){"notBefore"in t&&(this.notBefore=r(t,"notBefore",re.defaultValues("notBefore"))),"notAfter"in t&&(this.notAfter=r(t,"notAfter",re.defaultValues("notAfter"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"notBefore":case"notAfter":return new Date;default:throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new U({name:e.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new U({name:e.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(t){A(t,["notBefore","notAfter"]);const e=It(t,t,re.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in e.result){const t=new bt;t.fromBuffer(e.result.notBefore.valueBlock.valueHex),this.notBefore=t.toDate()}if("notAfter"in e.result){const t=new bt({valueHex:e.result.notAfter.valueBlock.valueHex});t.fromBuffer(e.result.notAfter.valueBlock.valueHex),this.notAfter=t.toDate()}}toSchema(){const t=[];return"notBefore"in this&&t.push(new U({idBlock:{tagClass:3,tagNumber:0},valueHex:new bt({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&t.push(new U({idBlock:{tagClass:3,tagNumber:1},valueHex:new bt({valueDate:this.notAfter}).valueBlock.valueHex})),new K({value:t})}toJSON(){const t={};return"notBefore"in this&&(t.notBefore=this.notBefore),"notAfter"in this&&(t.notAfter=this.notAfter),t}}function se(t={},e=!1){const s=r(t,"names",{});return new K({optional:e,value:[new D({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:s.country_name||"",value:[new kt({value:[new ot,new ht]})]}),new D({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:s.administration_domain_name||"",value:[new kt({value:[new ot,new ht]})]}),new U({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:s.network_address||"",isHexOnly:!0}),new U({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:s.terminal_identifier||"",isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:s.private_domain_name||"",value:[new kt({value:[new ot,new ht]})]}),new U({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:s.organization_name||"",isHexOnly:!0}),new U({optional:!0,name:s.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new D({optional:!0,name:s.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new U({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new U({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new U({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new U({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new D({optional:!0,name:s.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new Pt({value:new ht})]})]})}function ie(t=!1){return new K({optional:t,value:[new ht,new ht]})}function ne(t=!1){return new $({optional:t,value:[new U({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Ct]})]})}class ae{constructor(t={}){this.type=r(t,"type",ae.defaultValues("type")),this.value=r(t,"value",ae.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"type":return 9;case"value":return{};default:throw new Error(`Invalid member name for GeneralName class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"type":return e===ae.defaultValues(t);case"value":return 0===Object.keys(e).length;default:throw new Error(`Invalid member name for GeneralName class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new kt({value:[new D({idBlock:{tagClass:3,tagNumber:0},name:e.blockName||"",value:[new Q,new D({idBlock:{tagClass:3,tagNumber:0},value:[new Ct]})]}),new U({name:e.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new U({name:e.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new D({idBlock:{tagClass:3,tagNumber:3},name:e.blockName||"",value:[se(e.builtInStandardAttributes||{},!1),ie(!0),ne(!0)]}),new D({idBlock:{tagClass:3,tagNumber:4},name:e.blockName||"",value:[Xt.schema(e.directoryName||{})]}),new D({idBlock:{tagClass:3,tagNumber:5},name:e.blockName||"",value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new kt({value:[new ct,new ht,new it,new Y,new rt]})]}),new D({idBlock:{tagClass:3,tagNumber:1},value:[new kt({value:[new ct,new ht,new it,new Y,new rt]})]})]}),new U({name:e.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new U({name:e.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new U({name:e.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(t){A(t,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const e=It(t,t,ae.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for GeneralName");switch(this.type=e.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=e.result.blockName;break;case 1:case 2:case 6:{const t=e.result.blockName;t.idBlock.tagClass=1,t.idBlock.tagNumber=22;const r=t.toBER(!1);this.value=Bt(r).result.valueBlock.value}break;case 3:this.value=e.result.blockName;break;case 4:this.value=new Xt({schema:e.result.directoryName});break;case 5:this.value=e.result.ediPartyName;break;case 7:this.value=new M({valueHex:e.result.blockName.valueBlock.valueHex});break;case 8:{const t=e.result.blockName;t.idBlock.tagClass=1,t.idBlock.tagNumber=6;const r=t.toBER(!1);this.value=Bt(r).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new D({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const t=new lt({value:this.value});return t.idBlock.tagClass=3,t.idBlock.tagNumber=this.type,t}case 4:return new D({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const t=this.value;return t.idBlock.tagClass=3,t.idBlock.tagNumber=this.type,t}case 8:{const t=new Q({value:this.value});return t.idBlock.tagClass=3,t.idBlock.tagNumber=this.type,t}default:return ae.schema()}}toJSON(){const t={type:this.type,value:""};if("string"==typeof this.value)t.value=this.value;else try{t.value=this.value.toJSON()}catch(e){}return t}}class oe{constructor(t={}){this.altNames=r(t,"altNames",oe.defaultValues("altNames")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"altNames":return[];default:throw new Error(`Invalid member name for AltName class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.altNames||"",value:ae.schema()})]})}fromSchema(t){A(t,["altNames"]);const e=It(t,t,oe.schema({names:{altNames:"altNames"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in e.result&&(this.altNames=Array.from(e.result.altNames,t=>new ae({schema:t})))}toSchema(){return new K({value:Array.from(this.altNames,t=>t.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,t=>t.toJSON())}}}class he{constructor(t={}){this.cA=r(t,"cA",!1),"pathLenConstraint"in t&&(this.pathLenConstraint=r(t,"pathLenConstraint",0)),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"cA":return!1;default:throw new Error(`Invalid member name for BasicConstraints class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new j({optional:!0,name:e.cA||""}),new q({optional:!0,name:e.pathLenConstraint||""})]})}fromSchema(t){A(t,["cA","pathLenConstraint"]);const e=It(t,t,he.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in e.result&&(this.cA=e.result.cA.valueBlock.value),"pathLenConstraint"in e.result&&(this.pathLenConstraint=e.result.pathLenConstraint.valueBlock.isHexOnly?e.result.pathLenConstraint:e.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const t=[];return this.cA!==he.defaultValues("cA")&&t.push(new j({value:this.cA})),"pathLenConstraint"in this&&t.push(this.pathLenConstraint instanceof q?this.pathLenConstraint:new q({value:this.pathLenConstraint})),new K({value:t})}toJSON(){const t={};return this.cA!==he.defaultValues("cA")&&(t.cA=this.cA),"pathLenConstraint"in this&&(t.pathLenConstraint=this.pathLenConstraint instanceof q?this.pathLenConstraint.toJSON():this.pathLenConstraint),t}}class ce{constructor(t={}){"distributionPoint"in t&&(this.distributionPoint=r(t,"distributionPoint",ce.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=r(t,"onlyContainsUserCerts",ce.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=r(t,"onlyContainsCACerts",ce.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in t&&(this.onlySomeReasons=r(t,"onlySomeReasons",ce.defaultValues("onlySomeReasons"))),this.indirectCRL=r(t,"indirectCRL",ce.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=r(t,"onlyContainsAttributeCerts",ce.defaultValues("onlyContainsAttributeCerts")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error(`Invalid member name for IssuingDistributionPoint class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new kt({value:[new D({name:e.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new Pt({name:e.distributionPointNames||"",value:ae.schema()})]}),new D({name:e.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:Xt.schema().valueBlock.value})]})]}),new U({name:e.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new U({name:e.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new U({name:e.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new U({name:e.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new U({name:e.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(t){A(t,["distributionPoint","distributionPointNames","onlyContainsUserCerts","onlyContainsCACerts","onlySomeReasons","indirectCRL","onlyContainsAttributeCerts"]);const e=It(t,t,ce.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in e.result)switch(!0){case 0===e.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(e.result.distributionPointNames,t=>new ae({schema:t}));break;case 1===e.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new Xt({schema:new K({value:e.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in e.result){const t=new Uint8Array(e.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==t[0]}if("onlyContainsCACerts"in e.result){const t=new Uint8Array(e.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==t[0]}if("onlySomeReasons"in e.result){const t=new Uint8Array(e.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=t[0]}if("indirectCRL"in e.result){const t=new Uint8Array(e.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==t[0]}if("onlyContainsAttributeCerts"in e.result){const t=new Uint8Array(e.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==t[0]}}toSchema(){const t=[];if("distributionPoint"in this){let e;this.distributionPoint instanceof Array?e=new D({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,t=>t.toSchema())}):((e=this.distributionPoint.toSchema()).idBlock.tagClass=3,e.idBlock.tagNumber=1),t.push(new D({idBlock:{tagClass:3,tagNumber:0},value:[e]}))}if(this.onlyContainsUserCerts!==ce.defaultValues("onlyContainsUserCerts")&&t.push(new U({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==ce.defaultValues("onlyContainsCACerts")&&t.push(new U({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const e=new ArrayBuffer(1);new Uint8Array(e)[0]=this.onlySomeReasons,t.push(new U({idBlock:{tagClass:3,tagNumber:3},valueHex:e}))}return this.indirectCRL!==ce.defaultValues("indirectCRL")&&t.push(new U({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==ce.defaultValues("onlyContainsAttributeCerts")&&t.push(new U({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new K({value:t})}toJSON(){const t={};return"distributionPoint"in this&&(t.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,t=>t.toJSON()):this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==ce.defaultValues("onlyContainsUserCerts")&&(t.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==ce.defaultValues("onlyContainsCACerts")&&(t.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(t.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==ce.defaultValues("indirectCRL")&&(t.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==ce.defaultValues("onlyContainsAttributeCerts")&&(t.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),t}}class ue{constructor(t={}){this.names=r(t,"names",ue.defaultValues("names")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"names":return[];default:throw new Error(`Invalid member name for GeneralNames class: ${t}`)}}static schema(t={},e=!1){const s=r(t,"names",{});return new K({optional:e,name:s.blockName||"",value:[new Pt({name:s.generalNames||"",value:ae.schema()})]})}fromSchema(t){A(t,["names","generalNames"]);const e=It(t,t,ue.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(e.result.generalNames,t=>new ae({schema:t}))}toSchema(){return new K({value:Array.from(this.names,t=>t.toSchema())})}toJSON(){return{names:Array.from(this.names,t=>t.toJSON())}}}class le{constructor(t={}){this.base=r(t,"base",le.defaultValues("base")),this.minimum=r(t,"minimum",le.defaultValues("minimum")),"maximum"in t&&(this.maximum=r(t,"maximum",le.defaultValues("maximum"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"base":return new ae;case"minimum":case"maximum":return 0;default:throw new Error(`Invalid member name for GeneralSubtree class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[ae.schema(e.base||{}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new q({name:e.minimum||""})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new q({name:e.maximum||""})]})]})}fromSchema(t){A(t,["base","minimum","maximum"]);const e=It(t,t,le.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for GeneralSubtree");this.base=new ae({schema:e.result.base}),"minimum"in e.result&&(this.minimum=e.result.minimum.valueBlock.isHexOnly?e.result.minimum:e.result.minimum.valueBlock.valueDec),"maximum"in e.result&&(this.maximum=e.result.maximum.valueBlock.isHexOnly?e.result.maximum:e.result.maximum.valueBlock.valueDec)}toSchema(){const t=[];if(t.push(this.base.toSchema()),0!==this.minimum){let e=0;e=this.minimum instanceof q?this.minimum:new q({value:this.minimum}),t.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[e]}))}if("maximum"in this){let e=0;e=this.maximum instanceof q?this.maximum:new q({value:this.maximum}),t.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[e]}))}return new K({value:t})}toJSON(){const t={base:this.base.toJSON()};return 0!==this.minimum&&(t.minimum="number"==typeof this.minimum?this.minimum:this.minimum.toJSON()),"maximum"in this&&(t.maximum="number"==typeof this.maximum?this.maximum:this.maximum.toJSON()),t}}class me{constructor(t={}){"permittedSubtrees"in t&&(this.permittedSubtrees=r(t,"permittedSubtrees",me.defaultValues("permittedSubtrees"))),"excludedSubtrees"in t&&(this.excludedSubtrees=r(t,"excludedSubtrees",me.defaultValues("excludedSubtrees"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error(`Invalid member name for NameConstraints class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Pt({name:e.permittedSubtrees||"",value:le.schema()})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Pt({name:e.excludedSubtrees||"",value:le.schema()})]})]})}fromSchema(t){A(t,["permittedSubtrees","excludedSubtrees"]);const e=It(t,t,me.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in e.result&&(this.permittedSubtrees=Array.from(e.result.permittedSubtrees,t=>new le({schema:t}))),"excludedSubtrees"in e.result&&(this.excludedSubtrees=Array.from(e.result.excludedSubtrees,t=>new le({schema:t})))}toSchema(){const t=[];return"permittedSubtrees"in this&&t.push(new D({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,t=>t.toSchema())})),"excludedSubtrees"in this&&t.push(new D({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,t=>t.toSchema())})),new K({value:t})}toJSON(){const t={};return"permittedSubtrees"in this&&(t.permittedSubtrees=Array.from(this.permittedSubtrees,t=>t.toJSON())),"excludedSubtrees"in this&&(t.excludedSubtrees=Array.from(this.excludedSubtrees,t=>t.toJSON())),t}}class fe{constructor(t={}){"distributionPoint"in t&&(this.distributionPoint=r(t,"distributionPoint",fe.defaultValues("distributionPoint"))),"reasons"in t&&(this.reasons=r(t,"reasons",fe.defaultValues("reasons"))),"cRLIssuer"in t&&(this.cRLIssuer=r(t,"cRLIssuer",fe.defaultValues("cRLIssuer"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"distributionPoint":return[];case"reasons":return new L;case"cRLIssuer":return[];default:throw new Error(`Invalid member name for DistributionPoint class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new kt({value:[new D({name:e.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Pt({name:e.distributionPointNames||"",value:ae.schema()})]}),new D({name:e.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Xt.schema().valueBlock.value})]})]}),new U({name:e.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new D({name:e.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new Pt({name:e.cRLIssuerNames||"",value:ae.schema()})]})]})}fromSchema(t){A(t,["distributionPoint","distributionPointNames","reasons","cRLIssuer","cRLIssuerNames"]);const e=It(t,t,fe.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in e.result&&(0===e.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(e.result.distributionPointNames,t=>new ae({schema:t}))),1===e.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new Xt({schema:new K({value:e.result.distributionPoint.valueBlock.value})}))),"reasons"in e.result&&(this.reasons=new L({valueHex:e.result.reasons.valueBlock.valueHex})),"cRLIssuer"in e.result&&(this.cRLIssuer=Array.from(e.result.cRLIssuerNames,t=>new ae({schema:t})))}toSchema(){const t=[];if("distributionPoint"in this){let e;e=this.distributionPoint instanceof Array?new D({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,t=>t.toSchema())}):new D({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),t.push(new D({idBlock:{tagClass:3,tagNumber:0},value:[e]}))}return"reasons"in this&&t.push(new U({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&t.push(new D({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,t=>t.toSchema())})),new K({value:t})}toJSON(){const t={};return"distributionPoint"in this&&(t.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,t=>t.toJSON()):this.distributionPoint.toJSON()),"reasons"in this&&(t.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(t.cRLIssuer=Array.from(this.cRLIssuer,t=>t.toJSON())),t}}class we{constructor(t={}){this.distributionPoints=r(t,"distributionPoints",we.defaultValues("distributionPoints")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"distributionPoints":return[];default:throw new Error(`Invalid member name for CRLDistributionPoints class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.distributionPoints||"",value:fe.schema()})]})}fromSchema(t){A(t,["distributionPoints"]);const e=It(t,t,we.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(e.result.distributionPoints,t=>new fe({schema:t}))}toSchema(){return new K({value:Array.from(this.distributionPoints,t=>t.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,t=>t.toJSON())}}}class de{constructor(t={}){this.policyQualifierId=r(t,"policyQualifierId",de.defaultValues("policyQualifierId")),this.qualifier=r(t,"qualifier",de.defaultValues("qualifier")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"policyQualifierId":return"";case"qualifier":return new Ct;default:throw new Error(`Invalid member name for PolicyQualifierInfo class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.policyQualifierId||""}),new Ct({name:e.qualifier||""})]})}fromSchema(t){A(t,["policyQualifierId","qualifier"]);const e=It(t,t,de.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=e.result.policyQualifierId.valueBlock.toString(),this.qualifier=e.result.qualifier}toSchema(){return new K({value:[new Q({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class ye{constructor(t={}){this.policyIdentifier=r(t,"policyIdentifier",ye.defaultValues("policyIdentifier")),"policyQualifiers"in t&&(this.policyQualifiers=r(t,"policyQualifiers",ye.defaultValues("policyQualifiers"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error(`Invalid member name for PolicyInformation class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.policyIdentifier||""}),new K({optional:!0,value:[new Pt({name:e.policyQualifiers||"",value:de.schema()})]})]})}fromSchema(t){A(t,["policyIdentifier","policyQualifiers"]);const e=It(t,t,ye.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=e.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in e.result&&(this.policyQualifiers=Array.from(e.result.policyQualifiers,t=>new de({schema:t})))}toSchema(){const t=[];return t.push(new Q({value:this.policyIdentifier})),"policyQualifiers"in this&&t.push(new K({value:Array.from(this.policyQualifiers,t=>t.toSchema())})),new K({value:t})}toJSON(){const t={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(t.policyQualifiers=Array.from(this.policyQualifiers,t=>t.toJSON())),t}}class be{constructor(t={}){this.certificatePolicies=r(t,"certificatePolicies",be.defaultValues("certificatePolicies")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"certificatePolicies":return[];default:throw new Error(`Invalid member name for CertificatePolicies class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.certificatePolicies||"",value:ye.schema()})]})}fromSchema(t){A(t,["certificatePolicies"]);const e=It(t,t,be.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(e.result.certificatePolicies,t=>new ye({schema:t}))}toSchema(){return new K({value:Array.from(this.certificatePolicies,t=>t.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,t=>t.toJSON())}}}class pe{constructor(t={}){this.issuerDomainPolicy=r(t,"issuerDomainPolicy",pe.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=r(t,"subjectDomainPolicy",pe.defaultValues("subjectDomainPolicy")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error(`Invalid member name for PolicyMapping class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.issuerDomainPolicy||""}),new Q({name:e.subjectDomainPolicy||""})]})}fromSchema(t){A(t,["issuerDomainPolicy","subjectDomainPolicy"]);const e=It(t,t,pe.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=e.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=e.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new K({value:[new Q({value:this.issuerDomainPolicy}),new Q({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class ge{constructor(t={}){this.mappings=r(t,"mappings",ge.defaultValues("mappings")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"mappings":return[];default:throw new Error(`Invalid member name for PolicyMappings class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.mappings||"",value:pe.schema()})]})}fromSchema(t){A(t,["mappings"]);const e=It(t,t,ge.schema({names:{mappings:"mappings"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(e.result.mappings,t=>new pe({schema:t}))}toSchema(){return new K({value:Array.from(this.mappings,t=>t.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,t=>t.toJSON())}}}class Ae{constructor(t={}){"keyIdentifier"in t&&(this.keyIdentifier=r(t,"keyIdentifier",Ae.defaultValues("keyIdentifier"))),"authorityCertIssuer"in t&&(this.authorityCertIssuer=r(t,"authorityCertIssuer",Ae.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in t&&(this.authorityCertSerialNumber=r(t,"authorityCertSerialNumber",Ae.defaultValues("authorityCertSerialNumber"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"keyIdentifier":return new M;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new q;default:throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new U({name:e.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Pt({name:e.authorityCertIssuer||"",value:ae.schema()})]}),new U({name:e.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(t){A(t,["keyIdentifier","authorityCertIssuer","authorityCertSerialNumber"]);const e=It(t,t,Ae.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in e.result&&(this.keyIdentifier=new M({valueHex:e.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in e.result&&(this.authorityCertIssuer=Array.from(e.result.authorityCertIssuer,t=>new ae({schema:t}))),"authorityCertSerialNumber"in e.result&&(this.authorityCertSerialNumber=new q({valueHex:e.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const t=[];return"keyIdentifier"in this&&t.push(new U({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in this&&t.push(new D({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,t=>t.toSchema())})),"authorityCertSerialNumber"in this&&t.push(new U({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHex})),new K({value:t})}toJSON(){const t={};return"keyIdentifier"in this&&(t.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(t.authorityCertIssuer=Array.from(this.authorityCertIssuer,t=>t.toJSON())),"authorityCertSerialNumber"in this&&(t.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),t}}class ve{constructor(t={}){"requireExplicitPolicy"in t&&(this.requireExplicitPolicy=r(t,"requireExplicitPolicy",ve.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in t&&(this.inhibitPolicyMapping=r(t,"inhibitPolicyMapping",ve.defaultValues("inhibitPolicyMapping"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error(`Invalid member name for PolicyConstraints class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new U({name:e.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new U({name:e.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(t){A(t,["requireExplicitPolicy","inhibitPolicyMapping"]);const e=It(t,t,ve.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in e.result){const t=e.result.requireExplicitPolicy;t.idBlock.tagClass=1,t.idBlock.tagNumber=2;const r=Bt(t.toBER(!1));this.requireExplicitPolicy=r.result.valueBlock.valueDec}if("inhibitPolicyMapping"in e.result){const t=e.result.inhibitPolicyMapping;t.idBlock.tagClass=1,t.idBlock.tagNumber=2;const r=Bt(t.toBER(!1));this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const t=[];if("requireExplicitPolicy"in this){const e=new q({value:this.requireExplicitPolicy});e.idBlock.tagClass=3,e.idBlock.tagNumber=0,t.push(e)}if("inhibitPolicyMapping"in this){const e=new q({value:this.inhibitPolicyMapping});e.idBlock.tagClass=3,e.idBlock.tagNumber=1,t.push(e)}return new K({value:t})}toJSON(){const t={};return"requireExplicitPolicy"in this&&(t.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(t.inhibitPolicyMapping=this.inhibitPolicyMapping),t}}class Se{constructor(t={}){this.keyPurposes=r(t,"keyPurposes",Se.defaultValues("keyPurposes")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"keyPurposes":return[];default:throw new Error(`Invalid member name for ExtKeyUsage class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.keyPurposes||"",value:new Q})]})}fromSchema(t){A(t,["keyPurposes"]);const e=It(t,t,Se.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(e.result.keyPurposes,t=>t.valueBlock.toString())}toSchema(){return new K({value:Array.from(this.keyPurposes,t=>new Q({value:t}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class ke{constructor(t={}){this.accessMethod=r(t,"accessMethod",ke.defaultValues("accessMethod")),this.accessLocation=r(t,"accessLocation",ke.defaultValues("accessLocation")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"accessMethod":return"";case"accessLocation":return new ae;default:throw new Error(`Invalid member name for AccessDescription class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.accessMethod||""}),ae.schema(e.accessLocation||{})]})}fromSchema(t){A(t,["accessMethod","accessLocation"]);const e=It(t,t,ke.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=e.result.accessMethod.valueBlock.toString(),this.accessLocation=new ae({schema:e.result.accessLocation})}toSchema(){return new K({value:[new Q({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class Ce{constructor(t={}){this.accessDescriptions=r(t,"accessDescriptions",Ce.defaultValues("accessDescriptions")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"accessDescriptions":return[];default:throw new Error(`Invalid member name for InfoAccess class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.accessDescriptions||"",value:ke.schema()})]})}fromSchema(t){A(t,["accessDescriptions"]);const e=It(t,t,Ce.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(e.result.accessDescriptions,t=>new ke({schema:t}))}toSchema(){return new K({value:Array.from(this.accessDescriptions,t=>t.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,t=>t.toJSON())}}}class Pe{constructor(t={}){this.clear();for(const e of Object.keys(t))switch(e){case"length":this.length=t.length;break;case"stub":for(let e=0;e<this._view.length;e++)this._view[e]=t.stub;break;case"view":this.fromUint8Array(t.view);break;case"buffer":this.fromArrayBuffer(t.buffer);break;case"string":this.fromString(t.string);break;case"hexstring":this.fromHexString(t.hexstring)}}set buffer(t){this._buffer=t.slice(0),this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(t){this._buffer=new ArrayBuffer(t.length),this._view=new Uint8Array(this._buffer),this._view.set(t)}get view(){return this._view}get length(){return this._buffer.byteLength}set length(t){this._buffer=new ArrayBuffer(t),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(t){this.buffer=t}fromUint8Array(t){this._buffer=new ArrayBuffer(t.length),this._view=new Uint8Array(this._buffer),this._view.set(t)}fromString(t){const e=t.length;this.length=e;for(let r=0;r<e;r++)this.view[r]=t.charCodeAt(r)}toString(t=0,e=this.view.length-t){let r="";(t>=this.view.length||t<0)&&(t=0),(e>=this.view.length||e<0)&&(e=this.view.length-t);for(let s=t;s<t+e;s++)r+=String.fromCharCode(this.view[s]);return r}fromHexString(t){const e=t.length;this.buffer=new ArrayBuffer(e>>1),this.view=new Uint8Array(this.buffer);const r=new Map;r.set("0",0),r.set("1",1),r.set("2",2),r.set("3",3),r.set("4",4),r.set("5",5),r.set("6",6),r.set("7",7),r.set("8",8),r.set("9",9),r.set("A",10),r.set("a",10),r.set("B",11),r.set("b",11),r.set("C",12),r.set("c",12),r.set("D",13),r.set("d",13),r.set("E",14),r.set("e",14),r.set("F",15),r.set("f",15);let s=0,i=0;for(let n=0;n<e;n++)n%2?(i|=r.get(t.charAt(n)),this.view[s]=i,s++):i=r.get(t.charAt(n))<<4}toHexString(t=0,e=this.view.length-t){let r="";(t>=this.view.length||t<0)&&(t=0),(e>=this.view.length||e<0)&&(e=this.view.length-t);for(let s=t;s<t+e;s++){const t=this.view[s].toString(16).toUpperCase();r=r+(1==t.length?"0":"")+t}return r}copy(t=0,e=this._buffer.byteLength-t){if(0===t&&0===this._buffer.byteLength)return new Pe;if(t<0||t>this._buffer.byteLength-1)throw new Error(`Wrong start position: ${t}`);const r=new Pe;return r._buffer=this._buffer.slice(t,t+e),r._view=new Uint8Array(r._buffer),r}slice(t=0,e=this._buffer.byteLength){if(0===t&&0===this._buffer.byteLength)return new Pe;if(t<0||t>this._buffer.byteLength-1)throw new Error(`Wrong start position: ${t}`);const r=new Pe;return r._buffer=this._buffer.slice(t,e),r._view=new Uint8Array(r._buffer),r}realloc(t){const e=new ArrayBuffer(t);new Uint8Array(e).set(t>this._view.length?this._view:new Uint8Array(this._buffer,0,t)),this._buffer=e.slice(0),this._view=new Uint8Array(this._buffer)}append(t){const e=this._buffer.byteLength,r=t._buffer.byteLength,s=t._view.slice();this.realloc(e+r),this._view.set(s,e)}insert(t,e=0,r=this._buffer.byteLength-e){return!(e>this._buffer.byteLength-1||(r>this._buffer.byteLength-e&&(r=this._buffer.byteLength-e),r>t._buffer.byteLength&&(r=t._buffer.byteLength),this._view.set(r==t._buffer.byteLength?t._view:t._view.slice(0,r),e),0))}isEqual(t){if(this._buffer.byteLength!=t._buffer.byteLength)return!1;for(let e=0;e<t._buffer.byteLength;e++)if(this.view[e]!=t.view[e])return!1;return!0}isEqualView(t){if(t.length!=this.view.length)return!1;for(let e=0;e<t.length;e++)if(this.view[e]!=t[e])return!1;return!0}findPattern(t,e=null,r=null,s=!1){null==e&&(e=s?this.buffer.byteLength:0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),s?(null==r&&(r=e),r>e&&(r=e)):(null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e));const i=t.buffer.byteLength;if(i>r)return-1;const n=[];for(let a=0;a<i;a++)n.push(t.view[a]);for(let a=0;a<=r-i;a++){let t=!0;const r=s?e-i-a:e+a;for(let e=0;e<i;e++)if(this.view[e+r]!=n[e]){t=!1;break}if(t)return s?e-i-a:e+i+a}return-1}findFirstIn(t,e=null,r=null,s=!1){null==e&&(e=s?this.buffer.byteLength:0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),s?(null==r&&(r=e),r>e&&(r=e)):(null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e));const i={id:-1,position:s?0:e+r,length:0};for(let n=0;n<t.length;n++){const a=this.findPattern(t[n],e,r,s);if(-1!=a){let e=!1;const r=t[n].length;s?a-r>=i.position-i.length&&(e=!0):a-r<=i.position-i.length&&(e=!0),e&&(i.position=a,i.id=n,i.length=r)}}return i}findAllIn(t,e=0,r=this.buffer.byteLength-e){const s=[];if(null==e&&(e=0),e>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e);let i={id:-1,position:e};for(;;){const e=i.position;if(-1==(i=this.findFirstIn(t,i.position,r)).id)break;r-=i.position-e,s.push({id:i.id,position:i.position})}return s}findAllPatternIn(t,e=0,r=this.buffer.byteLength-e){null==e&&(e=0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e);const s=[],i=t.buffer.byteLength;if(i>r)return-1;const n=Array.from(t.view);for(let a=0;a<=r-i;a++){let t=!0;const r=e+a;for(let e=0;e<i;e++)if(this.view[e+r]!=n[e]){t=!1;break}t&&(s.push(e+i+a),a+=i-1)}return s}findFirstNotIn(t,e=null,r=null,s=!1){null==e&&(e=s?this.buffer.byteLength:0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),s?(null==r&&(r=e),r>e&&(r=e)):(null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e));const i={left:{id:-1,position:e},right:{id:-1,position:0},value:new Pe};let n=r;for(;n>0;){if(i.right=this.findFirstIn(t,s?e-r+n:e+r-n,n,s),-1==i.right.id){r=n,s?e-=r:e=i.left.position,i.value=new Pe,i.value._buffer=this._buffer.slice(e,e+r),i.value._view=new Uint8Array(i.value._buffer);break}if(i.right.position!=(s?i.left.position-t[i.right.id].buffer.byteLength:i.left.position+t[i.right.id].buffer.byteLength)){s?(e=i.right.position+t[i.right.id].buffer.byteLength,r=i.left.position-i.right.position-t[i.right.id].buffer.byteLength):(e=i.left.position,r=i.right.position-i.left.position-t[i.right.id].buffer.byteLength),i.value=new Pe,i.value._buffer=this._buffer.slice(e,e+r),i.value._view=new Uint8Array(i.value._buffer);break}i.left=i.right,n-=t[i.right.id]._buffer.byteLength}if(s){const t=i.right;i.right=i.left,i.left=t}return i}findAllNotIn(t,e=null,r=null){const s=[];if(null==e&&(e=0),e>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e);let i={left:{id:-1,position:e},right:{id:-1,position:e},value:new Pe};do{const e=i.right.position;r-=(i=this.findFirstNotIn(t,i.right.position,r)).right.position-e,s.push({left:{id:i.left.id,position:i.left.position},right:{id:i.right.id,position:i.right.position},value:i.value})}while(-1!=i.right.id);return s}findFirstSequence(t,e=null,r=null,s=!1){null==e&&(e=s?this.buffer.byteLength:0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),s?(null==r&&(r=e),r>e&&(r=e)):(null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e));const i=this.skipNotPatterns(t,e,r,s);if(-1==i)return{position:-1,value:new Pe};const n=this.skipPatterns(t,i,r-(s?e-i:i-e),s);s?(e=n,r=i-n):(e=i,r=n-i);const a=new Pe;return a._buffer=this._buffer.slice(e,e+r),a._view=new Uint8Array(a._buffer),{position:n,value:a}}findAllSequences(t,e=null,r=null){const s=[];if(null==e&&(e=0),e>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e);let i={position:e,value:new Pe};do{const e=i.position;-1!=(i=this.findFirstSequence(t,i.position,r)).position&&(r-=i.position-e,s.push({position:i.position,value:i.value}))}while(-1!=i.position);return s}findPairedPatterns(t,e,r=null,s=null){const i=[];if(t.isEqual(e))return i;if(null==r&&(r=0),r>this.buffer.byteLength-1)return i;null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r);let n=0;const a=this.findAllPatternIn(t,r,s);if(0==a.length)return i;const o=this.findAllPatternIn(e,r,s);if(0==o.length)return i;for(;n<a.length&&0!=o.length;)if(a[0]!=o[0]){if(a[n]>o[0])break;for(;a[n]<o[0]&&!(++n>=a.length););i.push({left:a[n-1],right:o[0]}),a.splice(n-1,1),o.splice(0,1),n=0}else i.push({left:a[0],right:o[0]}),a.splice(0,1),o.splice(0,1);return i.sort((t,e)=>t.left-e.left),i}findPairedArrays(t,e,r=null,s=null){const i=[];if(null==r&&(r=0),r>this.buffer.byteLength-1)return i;null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r);let n=0;const a=this.findAllIn(t,r,s);if(0==a.length)return i;const o=this.findAllIn(e,r,s);if(0==o.length)return i;for(;n<a.length&&0!=o.length;)if(a[0].position!=o[0].position){if(a[n].position>o[0].position)break;for(;a[n].position<o[0].position&&!(++n>=a.length););i.push({left:a[n-1],right:o[0]}),a.splice(n-1,1),o.splice(0,1),n=0}else i.push({left:a[0],right:o[0]}),a.splice(0,1),o.splice(0,1);return i.sort((t,e)=>t.left.position-e.left.position),i}replacePattern(t,e,r=null,s=null,i=null){let n,a;const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]};if(null==r&&(r=0),r>this.buffer.byteLength-1)return!1;if(null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r),null==i){if(0==(n=this.findAllIn([t],r,s)).length)return o}else n=i;o.searchPatternPositions.push(...Array.from(n,t=>t.position));const h=t.buffer.byteLength-e.buffer.byteLength,c=new ArrayBuffer(this.view.length-n.length*h),u=new Uint8Array(c);for(u.set(new Uint8Array(this.buffer,0,r)),a=0;a<n.length;a++){const s=0==a?r:n[a-1].position;u.set(new Uint8Array(this.buffer,s,n[a].position-t.buffer.byteLength-s),s-a*h),u.set(e.view,n[a].position-t.buffer.byteLength-a*h),o.replacePatternPositions.push(n[a].position-t.buffer.byteLength-a*h)}return a--,u.set(new Uint8Array(this.buffer,n[a].position,this.buffer.byteLength-n[a].position),n[a].position-t.buffer.byteLength+e.buffer.byteLength-a*h),this.buffer=c,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(t,e=null,r=null,s=!1){null==e&&(e=s?this.buffer.byteLength:0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),s?(null==r&&(r=e),r>e&&(r=e)):(null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e));let i=e;for(let n=0;n<t.length;n++){const a=t[n].buffer.byteLength,o=s?i-a:i;let h=!0;for(let e=0;e<a;e++)if(this.view[e+o]!=t[n].view[e]){h=!1;break}if(h)if(n=-1,s){if((i-=a)<=0)return i}else if((i+=a)>=e+r)return i}return i}skipNotPatterns(t,e=null,r=null,s=!1){null==e&&(e=s?this.buffer.byteLength:0),e>this.buffer.byteLength&&(e=this.buffer.byteLength),s?(null==r&&(r=e),r>e&&(r=e)):(null==r&&(r=this.buffer.byteLength-e),r>this.buffer.byteLength-e&&(r=this.buffer.byteLength-e));let i=-1;for(let n=0;n<r;n++){for(let r=0;r<t.length;r++){const a=t[r].buffer.byteLength,o=s?e-n-a:e+n;let h=!0;for(let e=0;e<a;e++)if(this.view[e+o]!=t[r].view[e]){h=!1;break}if(h){i=s?e-n:e+n;break}}if(-1!=i)break}return i}}class Ee{constructor(t={}){this.stream=new Pe,this._length=0,this.backward=!1,this._start=0,this.appendBlock=0,this.prevLength=0,this.prevStart=0;for(const e of Object.keys(t))switch(e){case"stream":this.stream=t.stream;break;case"backward":this.backward=t.backward,this._start=this.stream.buffer.byteLength;break;case"length":this._length=t.length;break;case"start":this._start=t.start;break;case"appendBlock":this.appendBlock=t.appendBlock;break;case"view":this.stream=new Pe({view:t.view});break;case"buffer":this.stream=new Pe({buffer:t.buffer});break;case"string":this.stream=new Pe({string:t.string});break;case"hexstring":this.stream=new Pe({hexstring:t.hexstring})}}set stream(t){this._stream=t,this.prevLength=this._length,this._length=t._buffer.byteLength,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(t){this.prevLength=this._length,this._length=t}get length(){return this.appendBlock?this.start:this._length}set start(t){t>this.stream.buffer.byteLength||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-t:t-this._start,this._start=t)}get start(){return this._start}get buffer(){return this._stream._buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(t,e=null){(null==e||e>this.length)&&(e=this.length);const r=this.stream.findPattern(t,this.start,this.length,this.backward);if(-1==r)return r;if(this.backward){if(r<this.start-t.buffer.byteLength-e)return-1}else if(r>this.start+t.buffer.byteLength+e)return-1;return this.start=r,r}findFirstIn(t,e=null){(null==e||e>this.length)&&(e=this.length);const r=this.stream.findFirstIn(t,this.start,this.length,this.backward);if(-1==r.id)return r;if(this.backward){if(r.position<this.start-t[r.id].buffer.byteLength-e)return{id:-1,position:this.backward?0:this.start+this.length}}else if(r.position>this.start+t[r.id].buffer.byteLength+e)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=r.position,r}findAllIn(t){return this.stream.findAllIn(t,this.backward?this.start-this.length:this.start,this.length)}findFirstNotIn(t,e=null){(null==e||e>this._length)&&(e=this._length);const r=this._stream.findFirstNotIn(t,this._start,this._length,this.backward);if(-1==r.left.id&&-1==r.right.id)return r;if(this.backward){if(-1!=r.right.id&&r.right.position<this._start-t[r.right.id]._buffer.byteLength-e)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Pe}}else if(-1!=r.left.id&&r.left.position>this._start+t[r.left.id]._buffer.byteLength+e)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Pe};return this.start=this.backward?-1==r.left.id?0:r.left.position:-1==r.right.id?this._start+this._length:r.right.position,r}findAllNotIn(t){return this._stream.findAllNotIn(t,this.backward?this._start-this._length:this._start,this._length)}findFirstSequence(t,e=null,r=null){(null==e||e>this._length)&&(e=this._length),(null==r||r>e)&&(r=e);const s=this._stream.findFirstSequence(t,this._start,e,this.backward);if(0==s.value.buffer.byteLength)return s;if(this.backward){if(s.position<this._start-s.value._buffer.byteLength-r)return{position:-1,value:new Pe}}else if(s.position>this._start+s.value._buffer.byteLength+r)return{position:-1,value:new Pe};return this.start=s.position,s}findAllSequences(t){return this.stream.findAllSequences(t,this.backward?this.start-this.length:this.start,this.length)}findPairedPatterns(t,e,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.stream.findPairedPatterns(t,e,this.backward?this.start-this.length:this.start,this.length);if(s.length)if(this.backward){if(s[0].right<this.start-e.buffer.byteLength-r)return[]}else if(s[0].left>this.start+t.buffer.byteLength+r)return[];return s}findPairedArrays(t,e,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.stream.findPairedArrays(t,e,this.backward?this.start-this.length:this.start,this.length);if(s.length)if(this.backward){if(s[0].right.position<this.start-e[s[0].right.id].buffer.byteLength-r)return[]}else if(s[0].left.position>this.start+t[s[0].left.id].buffer.byteLength+r)return[];return s}replacePattern(t,e){return this.stream.replacePattern(t,e,this.backward?this.start-this.length:this.start,this.length)}skipPatterns(t){const e=this.stream.skipPatterns(t,this.start,this.length,this.backward);return this.start=e,e}skipNotPatterns(t){const e=this.stream.skipNotPatterns(t,this.start,this.length,this.backward);return-1==e?-1:(this.start=e,e)}append(t){this._start+t._buffer.byteLength>this._stream._buffer.byteLength&&(t._buffer.byteLength>this.appendBlock&&(this.appendBlock=t._buffer.byteLength+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(t._view,this._start),this._length+=2*t._buffer.byteLength,this.start=this._start+t._buffer.byteLength,this.prevLength-=2*t._buffer.byteLength}appendView(t){this._start+t.length>this._stream._buffer.byteLength&&(t.length>this.appendBlock&&(this.appendBlock=t.length+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(t,this._start),this._length+=2*t.length,this.start=this._start+t.length,this.prevLength-=2*t.length}appendChar(t){this._start+1>this._stream._buffer.byteLength&&(1>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view[this._start]=t,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(t){this._start+2>this._stream._buffer.byteLength&&(2>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const e=new Uint16Array([t]),r=new Uint8Array(e.buffer);this._stream._view[this._start]=r[1],this._stream._view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(t){this._start+3>this._stream._buffer.byteLength&&(3>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const e=new Uint32Array([t]),r=new Uint8Array(e.buffer);this._stream._view[this._start]=r[2],this._stream._view[this._start+1]=r[1],this._stream._view[this._start+2]=r[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(t){this._start+4>this._stream._buffer.byteLength&&(4>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const e=new Uint32Array([t]),r=new Uint8Array(e.buffer);this._stream._view[this._start]=r[3],this._stream._view[this._start+1]=r[2],this._stream._view[this._start+2]=r[1],this._stream._view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(t,e=!0){if(this._length<=0)return[];let r;if(this._length<t&&(t=this._length),this.backward){const e=this._stream._buffer.slice(this._length-t,this._length),s=new Uint8Array(e);r=new Array(t);for(let i=0;i<t;i++)r[t-1-i]=s[i]}else{const e=this._stream._buffer.slice(this._start,this._start+t);r=Array.from(new Uint8Array(e))}return e&&(this.start+=this.backward?-1*t:t),r}getUint16(t=!0){const e=this.getBlock(2,t);if(e.length<2)return 0;const r=new Uint16Array(1),s=new Uint8Array(r.buffer);return s[0]=e[1],s[1]=e[0],r[0]}getInt16(t=!0){const e=this.getBlock(2,t);if(e.length<2)return 0;const r=new Int16Array(1),s=new Uint8Array(r.buffer);return s[0]=e[1],s[1]=e[0],r[0]}getUint24(t=!0){const e=this.getBlock(3,t);if(e.length<3)return 0;const r=new Uint32Array(1),s=new Uint8Array(r.buffer);for(let i=3;i>=1;i--)s[3-i]=e[i-1];return r[0]}getUint32(t=!0){const e=this.getBlock(4,t);if(e.length<4)return 0;const r=new Uint32Array(1),s=new Uint8Array(r.buffer);for(let i=3;i>=0;i--)s[3-i]=e[i];return r[0]}getInt32(t=!0){const e=this.getBlock(4,t);if(e.length<4)return 0;const r=new Int32Array(1),s=new Uint8Array(r.buffer);for(let i=3;i>=0;i--)s[3-i]=e[i];return r[0]}}class Ne{constructor(t={}){this.version=r(t,"version",Ne.defaultValues("version")),this.logID=r(t,"logID",Ne.defaultValues("logID")),this.timestamp=r(t,"timestamp",Ne.defaultValues("timestamp")),this.extensions=r(t,"extensions",Ne.defaultValues("extensions")),this.hashAlgorithm=r(t,"hashAlgorithm",Ne.defaultValues("hashAlgorithm")),this.signatureAlgorithm=r(t,"signatureAlgorithm",Ne.defaultValues("signatureAlgorithm")),this.signature=r(t,"signature",Ne.defaultValues("signature")),"schema"in t&&this.fromSchema(t.schema),"stream"in t&&this.fromStream(t.stream)}static defaultValues(t){switch(t){case"version":return 0;case"logID":case"extensions":return new ArrayBuffer(0);case"timestamp":return new Date(0);case"hashAlgorithm":case"signatureAlgorithm":return"";case"signature":return new Ct;default:throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${t}`)}}fromSchema(t){if(t instanceof Et==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const e=new Ee({stream:new Pe({buffer:t.data})});this.fromStream(e)}fromStream(t){const e=t.getUint16();if(this.version=t.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(t.getBlock(32)).buffer.slice(0),this.timestamp=new Date(n(new Uint8Array(t.getBlock(8)),8));const r=t.getUint16();switch(this.extensions=new Uint8Array(t.getBlock(r)).buffer.slice(0),t.getBlock(1)[0]){case 0:this.hashAlgorithm="none";break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm="sha1";break;case 3:this.hashAlgorithm="sha224";break;case 4:this.hashAlgorithm="sha256";break;case 5:this.hashAlgorithm="sha384";break;case 6:this.hashAlgorithm="sha512";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(t.getBlock(1)[0]){case 0:this.signatureAlgorithm="anonymous";break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm="ecdsa";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const s=t.getUint16(),i=Bt(new Uint8Array(t.getBlock(s)).buffer.slice(0));if(-1===i.offset)throw new Error("Object's stream was not correct for SignedCertificateTimestamp");if(this.signature=i.result,e!==47+r+s)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const t=this.toStream();return new Et({data:t.stream.buffer})}toStream(){const t=new Ee;t.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecode.byteLength),t.appendChar(this.version),t.appendView(new Uint8Array(this.logID));const e=new ArrayBuffer(8),r=new Uint8Array(e),s=a(this.timestamp.valueOf(),8);let i,n;switch(r.set(new Uint8Array(s),8-s.byteLength),t.appendView(r),t.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&t.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case"none":i=0;break;case"md5":i=1;break;case"sha1":i=2;break;case"sha224":i=3;break;case"sha256":i=4;break;case"sha384":i=5;break;case"sha512":i=6;break;default:throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(t.appendChar(i),this.signatureAlgorithm.toLowerCase()){case"anonymous":n=0;break;case"rsa":n=1;break;case"dsa":n=2;break;case"ecdsa":n=3;break;default:throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}t.appendChar(n);const o=this.signature.toBER(!1);return t.appendUint16(o.byteLength),t.appendView(new Uint8Array(o)),t}toJSON(){return{version:this.version,logID:s(this.logID),timestamp:this.timestamp,extensions:s(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(t,e,r=0){let s,i=w(y(this.logID)),n=null,o=new Ee;for(const a of t)if(a.log_id===i){n=a.key;break}if(null===n)throw new Error(`Public key not found for CT with logId: ${i}`);const h=Bt(b(d(n)));if(-1===h.offset)throw new Error(`Incorrect key value for CT Log with logId: ${i}`);s=new jt({schema:h.result}),o.appendChar(0),o.appendChar(0);const c=new ArrayBuffer(8),u=new Uint8Array(c),l=a(this.timestamp.valueOf(),8);return u.set(new Uint8Array(l),8-l.byteLength),o.appendView(u),o.appendUint16(r),0===r&&o.appendUint24(e.byteLength),o.appendView(new Uint8Array(e)),o.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&o.appendView(new Uint8Array(this.extensions)),Qt().subtle.verifyWithPublicKey(o._stream._buffer.slice(0,o._length),{valueBlock:{valueHex:this.signature.toBER(!1)}},s,{algorithmId:""},"SHA-256")}}class Be{constructor(t={}){this.timestamps=r(t,"timestamps",Be.defaultValues("timestamps")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"timestamps":return[];default:throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"timestamps":return 0===e.length;default:throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return"optional"in e==0&&(e.optional=!1),new M({name:e.blockName||"SignedCertificateTimestampList",optional:e.optional})}fromSchema(t){if(t instanceof M==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const e=new Ee({stream:new Pe({buffer:t.valueBlock.valueHex})});if(e.getUint16()!==e.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;e.length;)this.timestamps.push(new Ne({stream:e}))}toSchema(){const t=new Ee;let e=0;const r=[];for(const s of this.timestamps){const t=s.toStream();r.push(t),e+=t.stream.buffer.byteLength}t.appendUint16(e);for(const s of r)t.appendView(s.stream.view);return new M({valueHex:t.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,t=>t.toJSON())}}}class Ie{constructor(t={}){this.templateID=r(t,"templateID",Ie.defaultValues("templateID")),"templateMajorVersion"in t&&(this.templateMajorVersion=r(t,"templateMajorVersion",Ie.defaultValues("templateMajorVersion"))),"templateMinorVersion"in t&&(this.templateMinorVersion=r(t,"templateMinorVersion",Ie.defaultValues("templateMinorVersion"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"templateID":return"";case"templateMajorVersion":case"templateMinorVersion":return 0;default:throw new Error(`Invalid member name for CertificateTemplate class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.templateID||""}),new q({name:e.templateMajorVersion||"",optional:!0}),new q({name:e.templateMinorVersion||"",optional:!0})]})}fromSchema(t){A(t,["templateID","templateMajorVersion","templateMinorVersion"]);let e=It(t,t,Ie.schema({names:{templateID:"templateID",templateMajorVersion:"templateMajorVersion",templateMinorVersion:"templateMinorVersion"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for CertificateTemplate");this.templateID=e.result.templateID.valueBlock.toString(),"templateMajorVersion"in e.result&&(this.templateMajorVersion=e.result.templateMajorVersion.valueBlock.valueDec),"templateMinorVersion"in e.result&&(this.templateMinorVersion=e.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const t=[];return t.push(new Q({value:this.templateID})),"templateMajorVersion"in this&&t.push(new q({value:this.templateMajorVersion})),"templateMinorVersion"in this&&t.push(new q({value:this.templateMinorVersion})),new K({value:t})}toJSON(){const t={extnID:this.templateID};return"templateMajorVersion"in this&&(t.templateMajorVersion=this.templateMajorVersion),"templateMinorVersion"in this&&(t.templateMinorVersion=this.templateMinorVersion),t}}class Ue{constructor(t={}){this.certificateIndex=r(t,"certificateIndex",Ue.defaultValues("certificateIndex")),this.keyIndex=r(t,"keyIndex",Ue.defaultValues("keyIndex")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"certificateIndex":case"keyIndex":return 0;default:throw new Error(`Invalid member name for CAVersion class: ${t}`)}}static schema(t={}){return new q}fromSchema(t){if(t.constructor.blockName()!==q.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let e=t.valueBlock.valueHex.slice(0);const r=new Uint8Array(e);switch(!0){case e.byteLength<4:{const t=new ArrayBuffer(4);new Uint8Array(t).set(r,4-e.byteLength),e=t.slice(0)}break;case e.byteLength>4:{const t=new ArrayBuffer(4);new Uint8Array(t).set(r.slice(0,4)),e=t.slice(0)}}const s=e.slice(0,2),i=new Uint8Array(s);let n=i[0];i[0]=i[1],i[1]=n;const a=new Uint16Array(s);this.keyIndex=a[0];const o=e.slice(2),h=new Uint8Array(o);n=h[0],h[0]=h[1],h[1]=n;const c=new Uint16Array(o);this.certificateIndex=c[0]}toSchema(){const t=new ArrayBuffer(2);new Uint16Array(t)[0]=this.certificateIndex;const e=new Uint8Array(t);let r=e[0];e[0]=e[1],e[1]=r;const s=new ArrayBuffer(2);new Uint16Array(s)[0]=this.keyIndex;const i=new Uint8Array(s);return r=i[0],i[0]=i[1],i[1]=r,new q({valueHex:o(s,t)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}class xe{constructor(t={}){this.id=r(t,"id",xe.defaultValues("id")),"type"in t&&(this.type=r(t,"type",xe.defaultValues("type"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"id":return"";case"type":return new T;default:throw new Error(`Invalid member name for QCStatement class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"id":return""===e;case"type":return e instanceof T;default:throw new Error(`Invalid member name for QCStatement class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.id||""}),new Ct({name:e.type||"",optional:!0})]})}fromSchema(t){A(t,["id","type"]);const e=It(t,t,xe.schema({names:{id:"id",type:"type"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for QCStatement");this.id=e.result.id.valueBlock.toString(),"type"in e.result&&(this.type=e.result.type)}toSchema(){const t=[new Q({value:this.id})];return"type"in this&&t.push(this.type),new K({value:t})}toJSON(){const t={id:this.id};return"type"in this&&(t.type=this.type.toJSON()),t}}class De{constructor(t={}){this.values=r(t,"values",De.defaultValues("values")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"values":return[];default:throw new Error(`Invalid member name for QCStatements class: ${t}`)}}static compareWithDefault(t,e){switch(t){case"values":return 0===e.length;default:throw new Error(`Invalid member name for QCStatements class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Pt({name:e.values||"",value:xe.schema(e.value||{})})]})}fromSchema(t){A(t,["values"]);const e=It(t,t,De.schema({names:{values:"values"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for QCStatements");this.values=Array.from(e.result.values,t=>new xe({schema:t}))}toSchema(){return new K({value:Array.from(this.values,t=>t.toSchema())})}toJSON(){return{extensions:Array.from(this.values,t=>t.toJSON())}}}class Oe{constructor(t={}){this.extnID=r(t,"extnID",Oe.defaultValues("extnID")),this.critical=r(t,"critical",Oe.defaultValues("critical")),this.extnValue="extnValue"in t?new M({valueHex:t.extnValue}):Oe.defaultValues("extnValue"),"parsedValue"in t&&(this.parsedValue=r(t,"parsedValue",Oe.defaultValues("parsedValue"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"extnID":return"";case"critical":return!1;case"extnValue":return new M;case"parsedValue":return{};default:throw new Error(`Invalid member name for Extension class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[new Q({name:e.extnID||""}),new j({name:e.critical||"",optional:!0}),new M({name:e.extnValue||""})]})}fromSchema(t){A(t,["extnID","critical","extnValue"]);let e=It(t,t,Oe.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for Extension");if(this.extnID=e.result.extnID.valueBlock.toString(),"critical"in e.result&&(this.critical=e.result.critical.valueBlock.value),this.extnValue=e.result.extnValue,-1!==(e=Bt(this.extnValue.valueBlock.valueHex)).offset)switch(this.extnID){case"2.5.29.9":try{this.parsedValue=new ee({schema:e.result})}catch(r){this.parsedValue=new ee,this.parsedValue.parsingError="Incorrectly formated SubjectDirectoryAttributes"}break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=e.result;break;case"2.5.29.16":try{this.parsedValue=new re({schema:e.result})}catch(r){this.parsedValue=new re,this.parsedValue.parsingError="Incorrectly formated PrivateKeyUsagePeriod"}break;case"2.5.29.17":case"2.5.29.18":try{this.parsedValue=new oe({schema:e.result})}catch(r){this.parsedValue=new oe,this.parsedValue.parsingError="Incorrectly formated AltName"}break;case"2.5.29.19":try{this.parsedValue=new he({schema:e.result})}catch(r){this.parsedValue=new he,this.parsedValue.parsingError="Incorrectly formated BasicConstraints"}break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=e.result;break;case"2.5.29.28":try{this.parsedValue=new ce({schema:e.result})}catch(r){this.parsedValue=new ce,this.parsedValue.parsingError="Incorrectly formated IssuingDistributionPoint"}break;case"2.5.29.29":try{this.parsedValue=new ue({schema:e.result})}catch(r){this.parsedValue=new ue,this.parsedValue.parsingError="Incorrectly formated GeneralNames"}break;case"2.5.29.30":try{this.parsedValue=new me({schema:e.result})}catch(r){this.parsedValue=new me,this.parsedValue.parsingError="Incorrectly formated NameConstraints"}break;case"2.5.29.31":case"2.5.29.46":try{this.parsedValue=new we({schema:e.result})}catch(r){this.parsedValue=new we,this.parsedValue.parsingError="Incorrectly formated CRLDistributionPoints"}break;case"2.5.29.32":case"1.3.6.1.4.1.311.21.10":try{this.parsedValue=new be({schema:e.result})}catch(r){this.parsedValue=new be,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.33":try{this.parsedValue=new ge({schema:e.result})}catch(r){this.parsedValue=new ge,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.35":try{this.parsedValue=new Ae({schema:e.result})}catch(r){this.parsedValue=new Ae,this.parsedValue.parsingError="Incorrectly formated AuthorityKeyIdentifier"}break;case"2.5.29.36":try{this.parsedValue=new ve({schema:e.result})}catch(r){this.parsedValue=new ve,this.parsedValue.parsingError="Incorrectly formated PolicyConstraints"}break;case"2.5.29.37":try{this.parsedValue=new Se({schema:e.result})}catch(r){this.parsedValue=new Se,this.parsedValue.parsingError="Incorrectly formated ExtKeyUsage"}break;case"2.5.29.54":this.parsedValue=e.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":try{this.parsedValue=new Ce({schema:e.result})}catch(r){this.parsedValue=new Ce,this.parsedValue.parsingError="Incorrectly formated InfoAccess"}break;case"1.3.6.1.4.1.11129.2.4.2":try{this.parsedValue=new Be({schema:e.result})}catch(r){this.parsedValue=new Be,this.parsedValue.parsingError="Incorrectly formated SignedCertificateTimestampList"}break;case"1.3.6.1.4.1.311.20.2":case"1.3.6.1.4.1.311.21.2":this.parsedValue=e.result;break;case"1.3.6.1.4.1.311.21.7":try{this.parsedValue=new Ie({schema:e.result})}catch(r){this.parsedValue=new Ie,this.parsedValue.parsingError="Incorrectly formated CertificateTemplate"}break;case"1.3.6.1.4.1.311.21.1":try{this.parsedValue=new Ue({schema:e.result})}catch(r){this.parsedValue=new Ue,this.parsedValue.parsingError="Incorrectly formated CAVersion"}break;case"1.3.6.1.5.5.7.1.3":try{this.parsedValue=new De({schema:e.result})}catch(r){this.parsedValue=new De,this.parsedValue.parsingError="Incorrectly formated QCStatements"}}}toSchema(){const t=[];return t.push(new Q({value:this.extnID})),this.critical!==Oe.defaultValues("critical")&&t.push(new j({value:this.critical})),t.push(this.extnValue),new K({value:t})}toJSON(){const t={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Oe.defaultValues("critical")&&(t.critical=this.critical),"parsedValue"in this&&"toJSON"in this.parsedValue&&(t.parsedValue=this.parsedValue.toJSON()),t}}class He{constructor(t={}){this.extensions=r(t,"extensions",He.defaultValues("extensions")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"extensions":return[];default:throw new Error(`Invalid member name for Extensions class: ${t}`)}}static schema(t={},e=!1){const s=r(t,"names",{});return new K({optional:e,name:s.blockName||"",value:[new Pt({name:s.extensions||"",value:Oe.schema(s.extension||{})})]})}fromSchema(t){A(t,["extensions"]);const e=It(t,t,He.schema({names:{extensions:"extensions"}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for Extensions");this.extensions=Array.from(e.result.extensions,t=>new Oe({schema:t}))}toSchema(){return new K({value:Array.from(this.extensions,t=>t.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,t=>t.toJSON())}}}function Re(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"tbsCertificate",value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new q({name:e.tbsCertificateVersion||"tbsCertificate.version"})]}),new q({name:e.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),Ot.schema(e.signature||{names:{blockName:"tbsCertificate.signature"}}),Xt.schema(e.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new K({name:e.tbsCertificateValidity||"tbsCertificate.validity",value:[te.schema(e.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),te.schema(e.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),Xt.schema(e.subject||{names:{blockName:"tbsCertificate.subject"}}),jt.schema(e.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new U({name:e.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new U({name:e.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[He.schema(e.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}class je{constructor(t={}){this.tbs=r(t,"tbs",je.defaultValues("tbs")),this.version=r(t,"version",je.defaultValues("version")),this.serialNumber=r(t,"serialNumber",je.defaultValues("serialNumber")),this.signature=r(t,"signature",je.defaultValues("signature")),this.issuer=r(t,"issuer",je.defaultValues("issuer")),this.notBefore=r(t,"notBefore",je.defaultValues("notBefore")),this.notAfter=r(t,"notAfter",je.defaultValues("notAfter")),this.subject=r(t,"subject",je.defaultValues("subject")),this.subjectPublicKeyInfo=r(t,"subjectPublicKeyInfo",je.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in t&&(this.issuerUniqueID=r(t,"issuerUniqueID",je.defaultValues("issuerUniqueID"))),"subjectUniqueID"in t&&(this.subjectUniqueID=r(t,"subjectUniqueID",je.defaultValues("subjectUniqueID"))),"extensions"in t&&(this.extensions=r(t,"extensions",je.defaultValues("extensions"))),this.signatureAlgorithm=r(t,"signatureAlgorithm",je.defaultValues("signatureAlgorithm")),this.signatureValue=r(t,"signatureValue",je.defaultValues("signatureValue")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(t){switch(t){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new q;case"signature":return new Ot;case"issuer":return new Xt;case"notBefore":case"notAfter":return new te;case"subject":return new Xt;case"subjectPublicKeyInfo":return new jt;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new Ot;case"signatureValue":return new L;default:throw new Error(`Invalid member name for Certificate class: ${t}`)}}static schema(t={}){const e=r(t,"names",{});return new K({name:e.blockName||"",value:[Re(e.tbsCertificate),Ot.schema(e.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new L({name:e.signatureValue||"signatureValue"})]})}fromSchema(t){A(t,["tbsCertificate","tbsCertificate.extensions","tbsCertificate.version","tbsCertificate.serialNumber","tbsCertificate.signature","tbsCertificate.issuer","tbsCertificate.notBefore","tbsCertificate.notAfter","tbsCertificate.subject","tbsCertificate.subjectPublicKeyInfo","tbsCertificate.issuerUniqueID","tbsCertificate.subjectUniqueID","signatureAlgorithm","signatureValue"]);const e=It(t,t,je.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===e.verified)throw new Error("Object's schema was not verified against input data for Certificate");this.tbs=e.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in e.result&&(this.version=e.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=e.result["tbsCertificate.serialNumber"],this.signature=new Ot({schema:e.result["tbsCertificate.signature"]}),this.issuer=new Xt({schema:e.result["tbsCertificate.issuer"]}),this.notBefore=new te({schema:e.result["tbsCertificate.notBefore"]}),this.notAfter=new te({schema:e.result["tbsCertificate.notAfter"]}),this.subject=new Xt({schema:e.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new jt({schema:e.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in e.result&&(this.issuerUniqueID=e.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in e.result&&(this.subjectUniqueID=e.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in e.result&&(this.extensions=Array.from(e.result["tbsCertificate.extensions"],t=>new Oe({schema:t}))),this.signatureAlgorithm=new Ot({schema:e.result.signatureAlgorithm}),this.signatureValue=e.result.signatureValue}encodeTBS(){const t=[];return"version"in this&&this.version!==je.defaultValues("version")&&t.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new q({value:this.version})]})),t.push(this.serialNumber),t.push(this.signature.toSchema()),t.push(this.issuer.toSchema()),t.push(new K({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),t.push(this.subject.toSchema()),t.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&t.push(new U({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&t.push(new U({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"extensions"in this&&t.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new K({value:Array.from(this.extensions,t=>t.toSchema())})]})),new K({value:t})}toSchema(t=!1){let e={};if(!1===t){if(0===this.tbs.length)return je.schema().value[0];e=Bt(this.tbs).result}else e=this.encodeTBS();return new K({value:[e,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const t={tbs:s(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==je.defaultValues("version")&&(t.version=this.version),"issuerUniqueID"in this&&(t.issuerUniqueID=s(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(t.subjectUniqueID=s(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(t.extensions=Array.from(this.extensions,t=>t.toJSON())),t}getPublicKey(t=null){return Qt().subtle.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,t)}getKeyHash(t="SHA-1"){const e=Zt();return void 0===e?Promise.reject("Unable to create WebCrypto object"):e.digest({name:t},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(t,e="SHA-1"){if(void 0===t)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const i=Qt();return(s=(s=(s=(s=s.then(()=>i.subtle.getSignatureParameters(t,e))).then(t=>{r=t.parameters,this.signature=t.signatureAlgorithm,this.signatureAlgorithm=t.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>i.subtle.signWithPrivateKey(this.tbs,t,r))).then(t=>{this.signatureValue=new L({valueHex:t})})}verify(t=null){let e={};return null!==t?e=t.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(e=this.subjectPublicKeyInfo),e instanceof jt==0?Promise.reject("Please provide issuer certificate as a parameter"):Qt().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,e,this.signatureAlgorithm)}}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var Ke,$e=(function(t){t.exports=function(){var t="millisecond",e="second",r="minute",s="hour",i="day",n="week",a="month",o="quarter",h="year",c=/^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,u=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,l=function(t,e,r){var s=String(t);return!s||s.length>=e?t:""+Array(e+1-s.length).join(r)+t},m={s:l,z:function(t){var e=-t.utcOffset(),r=Math.abs(e),s=Math.floor(r/60),i=r%60;return(e<=0?"+":"-")+l(s,2,"0")+":"+l(i,2,"0")},m:function(t,e){var r=12*(e.year()-t.year())+(e.month()-t.month()),s=t.clone().add(r,a),i=e-s<0,n=t.clone().add(r+(i?-1:1),a);return Number(-(r+(e-s)/(i?s-n:n-s))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(c){return{M:a,y:h,w:n,d:i,h:s,m:r,s:e,ms:t,Q:o}[c]||String(c||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},f={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},w="en",d={};d[w]=f;var y=function(t){return t instanceof A},b=function(t,e,r){var s;if(!t)return w;if("string"==typeof t)d[t]&&(s=t),e&&(d[t]=e,s=t);else{var i=t.name;d[i]=t,s=i}return r||(w=s),s},p=function(t,e,r){if(y(t))return t.clone();var s=e?"string"==typeof e?{format:e,pl:r}:e:{};return s.date=t,new A(s)},g=m;g.l=b,g.i=y,g.w=function(t,e){return p(t,{locale:e.$L,utc:e.$u,$offset:e.$offset})};var A=function(){function l(t){this.$L=this.$L||b(t.locale,null,!0),this.parse(t)}var m=l.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,r=t.utc;if(null===e)return new Date(NaN);if(g.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var s=e.match(c);if(s)return r?new Date(Date.UTC(s[1],s[2]-1,s[3]||1,s[4]||0,s[5]||0,s[6]||0,s[7]||0)):new Date(s[1],s[2]-1,s[3]||1,s[4]||0,s[5]||0,s[6]||0,s[7]||0)}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return g},m.isValid=function(){return!("Invalid Date"===this.$d.toString())},m.isSame=function(t,e){var r=p(t);return this.startOf(e)<=r&&r<=this.endOf(e)},m.isAfter=function(t,e){return p(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<p(t)},m.$g=function(t,e,r){return g.u(t)?this[e]:this.set(r,t)},m.year=function(t){return this.$g(t,"$y",h)},m.month=function(t){return this.$g(t,"$M",a)},m.day=function(t){return this.$g(t,"$W",i)},m.date=function(t){return this.$g(t,"$D","date")},m.hour=function(t){return this.$g(t,"$H",s)},m.minute=function(t){return this.$g(t,"$m",r)},m.second=function(t){return this.$g(t,"$s",e)},m.millisecond=function(e){return this.$g(e,"$ms",t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,o){var c=this,u=!!g.u(o)||o,l=g.p(t),m=function(t,e){var r=g.w(c.$u?Date.UTC(c.$y,e,t):new Date(c.$y,e,t),c);return u?r:r.endOf(i)},f=function(t,e){return g.w(c.toDate()[t].apply(c.toDate(),(u?[0,0,0,0]:[23,59,59,999]).slice(e)),c)},w=this.$W,d=this.$M,y=this.$D,b="set"+(this.$u?"UTC":"");switch(l){case h:return u?m(1,0):m(31,11);case a:return u?m(1,d):m(0,d+1);case n:var p=this.$locale().weekStart||0,A=(w<p?w+7:w)-p;return m(u?y-A:y+(6-A),d);case i:case"date":return f(b+"Hours",0);case s:return f(b+"Minutes",1);case r:return f(b+"Seconds",2);case e:return f(b+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(n,o){var c,u=g.p(n),l="set"+(this.$u?"UTC":""),m=(c={},c[i]=l+"Date",c.date=l+"Date",c[a]=l+"Month",c[h]=l+"FullYear",c[s]=l+"Hours",c[r]=l+"Minutes",c[e]=l+"Seconds",c[t]=l+"Milliseconds",c)[u],f=u===i?this.$D+(o-this.$W):o;if(u===a||u===h){var w=this.clone().set("date",1);w.$d[m](f),w.init(),this.$d=w.set("date",Math.min(this.$D,w.daysInMonth())).toDate()}else m&&this.$d[m](f);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[g.p(t)]()},m.add=function(t,o){var c,u=this;t=Number(t);var l=g.p(o),m=function(e){var r=p(u);return g.w(r.date(r.date()+Math.round(e*t)),u)};if(l===a)return this.set(a,this.$M+t);if(l===h)return this.set(h,this.$y+t);if(l===i)return m(1);if(l===n)return m(7);var f=(c={},c[r]=6e4,c[s]=36e5,c[e]=1e3,c)[l]||1,w=this.$d.getTime()+t*f;return g.w(w,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this;if(!this.isValid())return"Invalid Date";var r=t||"YYYY-MM-DDTHH:mm:ssZ",s=g.z(this),i=this.$locale(),n=this.$H,a=this.$m,o=this.$M,h=i.weekdays,c=i.months,l=function(t,s,i,n){return t&&(t[s]||t(e,r))||i[s].substr(0,n)},m=function(t){return g.s(n%12||12,t,"0")},f=i.meridiem||function(t,e,r){var s=t<12?"AM":"PM";return r?s.toLowerCase():s},w={YY:String(this.$y).slice(-2),YYYY:this.$y,M:o+1,MM:g.s(o+1,2,"0"),MMM:l(i.monthsShort,o,c,3),MMMM:c[o]||c(this,r),D:this.$D,DD:g.s(this.$D,2,"0"),d:String(this.$W),dd:l(i.weekdaysMin,this.$W,h,2),ddd:l(i.weekdaysShort,this.$W,h,3),dddd:h[this.$W],H:String(n),HH:g.s(n,2,"0"),h:m(1),hh:m(2),a:f(n,a,!0),A:f(n,a,!1),m:String(a),mm:g.s(a,2,"0"),s:String(this.$s),ss:g.s(this.$s,2,"0"),SSS:g.s(this.$ms,3,"0"),Z:s};return r.replace(u,(function(t,e){return e||w[t]||s.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(t,c,u){var l,m=g.p(c),f=p(t),w=6e4*(f.utcOffset()-this.utcOffset()),d=this-f,y=g.m(this,f);return y=(l={},l[h]=y/12,l[a]=y,l[o]=y/3,l[n]=(d-w)/6048e5,l[i]=(d-w)/864e5,l[s]=d/36e5,l[r]=d/6e4,l[e]=d/1e3,l)[m]||d,u?y:g.a(y)},m.daysInMonth=function(){return this.endOf(a).$D},m.$locale=function(){return d[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var r=this.clone();return r.$L=b(t,e,!0),r},m.clone=function(){return g.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},l}();return p.prototype=A.prototype,p.extend=function(t,e){return t(e,A,p),p},p.locale=b,p.isDayjs=y,p.unix=function(t){return p(1e3*t)},p.en=d[w],p.Ls=d,p}()}(Ke={exports:{}}),Ke.exports);function Te(t,e,r,s,i){const n=`${r}.${s}`;let a="";if("string"!=typeof t){const r=new Blob([t],{type:e});if(navigator.msSaveBlob)return navigator.msSaveBlob(r,n),new Promise(t=>setTimeout(t,i||0));a=window.URL.createObjectURL(r)}else a=`data:${e};charset=utf-8,${encodeURIComponent(t)}`;const o=document.createElement("a");return o.style.display="none",o.href=a,o.download=n,document.body.appendChild(o),o.dispatchEvent(new MouseEvent("click")),document.body.removeChild(o),new Promise(t=>setTimeout(()=>(t=>{/^blob:/.test(a)&&window.URL.revokeObjectURL(a),t()})(t),i||0))}class Ve extends Dt{constructor(t){super(t),this.notBefore="",this.notAfter="",this.validity=0,this.subject=[],this.serialNumber="",this.version=0,this.decode()}static base64ToPem(t){return t=t.replace(/(.{64})/g,"$1\n"),Ve.pemTagCertificate(t)}decode(){this.pem=Ve.base64ToPem(this.base64);const t=new je({schema:this.schema}),e=t.toJSON();this.subject=Ve.prepareSubject(e.subject?e.subject.typesAndValues:e.subject),e.notBefore&&e.notBefore.value&&(this.notBefore=new Date(e.notBefore.value).toISOString()),e.notAfter&&e.notAfter.value&&(this.notAfter=new Date(e.notAfter.value).toISOString()),this.notBefore&&this.notAfter&&(this.validity=$e(this.notAfter).diff($e(this.notBefore),"day")),this.publicKey={algorithm:{name:""},value:xt.ToHex(t.subjectPublicKeyInfo.subjectPublicKey.valueBeforeDecode).toLowerCase(),oid:t.subjectPublicKeyInfo.algorithm.algorithmId},t.subjectPublicKeyInfo.parsedKey&&("1.2.840.10045.2.1"===t.subjectPublicKeyInfo.algorithm.algorithmId?(this.publicKey.algorithm.name="EC",this.publicKey.algorithm.namedCurve=e.subjectPublicKeyInfo.crv):(this.publicKey.algorithm.name="RSA","modulus"in t.subjectPublicKeyInfo.parsedKey&&(this.publicKey.algorithm.modulusBits=t.subjectPublicKeyInfo.parsedKey.modulus.valueBlock.valueHex.byteLength<<3),"publicExponent"in t.subjectPublicKeyInfo.parsedKey&&(this.publicKey.algorithm.publicExponent=3===t.subjectPublicKeyInfo.parsedKey.publicExponent.valueBlock.valueHex.byteLength?65537:3))),this.signature={algorithm:Ve.prepareAlgorithm(e.signatureAlgorithm),value:e.signatureValue.valueBlock.valueHex.toLowerCase(),oid:e.signatureAlgorithm.algorithmId},this.serialNumber=e.serialNumber?e.serialNumber.valueBlock.valueHex.toLowerCase():void 0,this.version=e.version}get commonName(){for(let t=0;t<=this.subject.length;t+=1){const e=this.subject[t];if("CN"===e.name)return e.value}}downloadAsPEM(){Te(this.pem,"text/plain",this.commonName,"crt")}downloadAsDER(){Te(this.hex,"application/octet-stream",this.commonName,"crt")}}const Me=class{constructor(e){t(this,e),this.certificates="",this.certificatesDecoded=[]}componentWillLoad(){const t=[];this.certificatesPropParsed.forEach(e=>{try{t.push(new Ve(e))}catch(r){console.error(r)}}),this.certificatesDecoded=t}get certificatesPropParsed(){return this.certificates.split(",")}render(){return e("section",null,e("h3",null,"Certificates:"),e("ul",null,this.certificatesDecoded.map(t=>e("li",null,t.serialNumber))))}static get style(){return":host{display:block;width:100%;word-wrap:break-word}"}};export{Me as pv_certificates_viewer};