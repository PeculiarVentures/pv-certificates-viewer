import{f as e}from"./p-036de598.js";function t(e,t,i){return e instanceof Object==0?i:t in e?e[t]:i}function i(e,t=0,i=e.byteLength-t,r=!1){let s="";for(const n of new Uint8Array(e,t,i)){const e=n.toString(16).toUpperCase();1===e.length&&(s+="0"),s+=e,r&&(s+=" ")}return s.trim()}function r(e,t,i,r){return t instanceof ArrayBuffer==0?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):i<0?(e.error="Wrong parameter: inputOffset less than zero",!1):r<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-i-r<0&&(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))}function s(e,t){let i=0;if(1===e.length)return e[0];for(let r=e.length-1;r>=0;r--)i+=e[e.length-1-r]*Math.pow(2,t*r);return i}function n(e,t,i=-1){const r=i;let s=e,n=0,a=Math.pow(2,t);for(let o=1;o<8;o++){if(e<a){let e;if(r<0)e=new ArrayBuffer(o),n=o;else{if(r<o)return new ArrayBuffer(0);e=new ArrayBuffer(r),n=r}const i=new Uint8Array(e);for(let r=o-1;r>=0;r--){const e=Math.pow(2,r*t);i[n-r-1]=Math.floor(s/e),s-=i[n-r-1]*e}return e}a*=Math.pow(2,t)}return new ArrayBuffer(0)}function a(...e){let t=0,i=0;for(const n of e)t+=n.byteLength;const r=new ArrayBuffer(t),s=new Uint8Array(r);for(const n of e)s.set(new Uint8Array(n),i),i+=n.byteLength;return r}function o(...e){let t=0,i=0;for(const n of e)t+=n.length;const r=new ArrayBuffer(t),s=new Uint8Array(r);for(const n of e)s.set(n,i),i+=n.length;return s}function c(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=0===e[0]&&0==(128&e[1]);(255===e[0]&&128&e[1]||t)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(t);for(let s=0;s<this.valueHex.byteLength;s++)i[s]=0;i[0]=128&e[0];const r=s(i,8),n=new ArrayBuffer(this.valueHex.byteLength),a=new Uint8Array(n);for(let s=0;s<this.valueHex.byteLength;s++)a[s]=e[s];return a[0]&=127,s(a,8)-r}function h(e,t){if(e.byteLength!==t.byteLength)return!1;const i=new Uint8Array(e),r=new Uint8Array(t);for(let s=0;s<i.length;s++)if(i[s]!==r[s])return!1;return!0}function l(e,t){const i=e.toString(10);if(t<i.length)return"";const r=t-i.length,s=new Array(r);for(let n=0;n<r;n++)s[n]="0";return s.join("").concat(i)}const u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function f(e,t=!1,i=!1,r=!1){let s=0,n=0,a=0,o="";const c=t?m:u;if(r){let t=0;for(let i=0;i<e.length;i++)if(0!==e.charCodeAt(i)){t=i;break}e=e.slice(t)}for(;s<e.length;){const t=e.charCodeAt(s++);s>=e.length&&(n=1);const r=e.charCodeAt(s++);s>=e.length&&(a=1);const h=e.charCodeAt(s++),l=t>>2,u=(3&t)<<4|r>>4;let m=(15&r)<<2|h>>6,f=63&h;1===n?m=f=64:1===a&&(f=64),o+=i?64===m?`${c.charAt(l)}${c.charAt(u)}`:64===f?`${c.charAt(l)}${c.charAt(u)}${c.charAt(m)}`:`${c.charAt(l)}${c.charAt(u)}${c.charAt(m)}${c.charAt(f)}`:`${c.charAt(l)}${c.charAt(u)}${c.charAt(m)}${c.charAt(f)}`}return o}function d(e,t=!1,i=!1){const r=t?m:u;function s(e){for(let t=0;t<64;t++)if(r.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let a=0,o="";for(;a<e.length;){const t=s(e.charAt(a++)),i=a>=e.length?0:s(e.charAt(a++)),r=a>=e.length?0:s(e.charAt(a++)),c=a>=e.length?0:s(e.charAt(a++)),h=n(t)<<2|n(i)>>4,l=(15&n(i))<<4|n(r)>>2,u=(3&n(r))<<6|n(c);o+=String.fromCharCode(h),64!==r&&(o+=String.fromCharCode(l)),64!==c&&(o+=String.fromCharCode(u))}if(i){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}o=-1!==e?o.slice(0,e+1):""}return o}function p(e){let t="";const i=new Uint8Array(e);for(const r of i)t+=String.fromCharCode(r);return t}function A(e){const t=e.length,i=new ArrayBuffer(t),r=new Uint8Array(i);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return i}const S=Math.log(2);function y(e){const t=Math.log(e)/S,i=Math.floor(t),r=Math.round(t);return i===r?i:r}function w(e,t){for(const i of t)delete e[i]}const C=[new Uint8Array([1])],g="0123456789";class b{constructor(e={}){this.blockLength=t(e,"blockLength",0),this.error=t(e,"error",""),this.warnings=t(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:i(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const P=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=t(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,i){return!1===r(this,e,t,i)?-1:0===new Uint8Array(e,t,i).length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+i),this.blockLength=i,t+i)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=i(this.valueHex,0,this.valueHex.byteLength),e}});class E extends(P(b)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=t(e.idBlock,"isHexOnly",!1),this.valueHex=t(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=t(e.idBlock,"tagClass",-1),this.tagNumber=t(e.idBlock,"tagNumber",-1),this.isConstructed=t(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,i,r=0;switch(this.tagClass){case 1:r|=0;break;case 2:r|=64;break;case 3:r|=128;break;case 4:r|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(r|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),i=new Uint8Array(t),!e){let e=this.tagNumber;i[0]=r|=e&=31}return t}if(!1===this.isHexOnly){const s=n(this.tagNumber,7),a=new Uint8Array(s),o=s.byteLength;if(t=new ArrayBuffer(o+1),(i=new Uint8Array(t))[0]=31|r,!e){for(let e=0;e<o-1;e++)i[e+1]=128|a[e];i[o]=a[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(i=new Uint8Array(t))[0]=31|r,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)i[t+1]=128|e[t];i[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const a=31&n[0];if(31!==a)this.tagNumber=a,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,i=new Uint8Array(this.valueHex);for(;128&n[e];){if(i[e-1]=127&n[e],++e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),r=new Uint8Array(e);for(let t=0;t<i.length;t++)r[t]=i[t];this.valueHex=new ArrayBuffer(t),i=new Uint8Array(this.valueHex)}}this.blockLength=e+1,i[e-1]=127&n[e];const r=new ArrayBuffer(e),a=new Uint8Array(r);for(let s=0;s<e;s++)a[s]=i[s];this.valueHex=new ArrayBuffer(e),(i=new Uint8Array(this.valueHex)).set(a),this.blockLength<=9?this.tagNumber=s(i,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class v extends b{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=t(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=t(e.lenBlock,"longFormUsed",!1),this.length=t(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const a=127&n[0];if(a>8)return this.error="Too big integer",-1;if(a+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(a);for(let r=0;r<a;r++)o[r]=n[r+1];return 0===o[a-1]&&this.warnings.push("Needlessly long encoded length"),this.length=s(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=a+1,t+this.blockLength}toBER(e=!1){let t,i;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((i=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const r=n(this.length,8);if(r.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(r.byteLength+1),!0===e)return t;const s=new Uint8Array(r);(i=new Uint8Array(t))[0]=128|r.byteLength;for(let e=0;e<r.byteLength;e++)i[e+1]=s[e];return t}return t=new ArrayBuffer(1),!1===e&&((i=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class k extends b{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,i){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}class B extends b{constructor(e={},t=k){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new E(e),this.lenBlock=new v(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}toBER(e=!1){let t;const i=this.idBlock.toBER(e),r=this.valueBlock.toBER(!0);let s;if(this.lenBlock.length=r.byteLength,t=a(i,this.lenBlock.toBER(e)),t=a(t,s=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const i=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(i);e[0]=0,e[1]=0}t=a(t,i)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class I extends k{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=t(e,"isHexOnly",!0)}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const s=new Uint8Array(e,t,i);if(0===s.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(s.length);const n=new Uint8Array(this.valueHex);for(let r=0;r<s.length;r++)n[r]=s[r];return this.blockLength=i,t+i}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueHex=i(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class D extends B{constructor(e={}){super(e,I),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class N extends k{constructor(e={}){super(e),this.value=t(e,"value",[]),this.isIndefiniteForm=t(e,"isIndefiniteForm",!1)}fromBER(e,t,i){const s=t,n=i;if(!1===r(this,e,t,i))return-1;if(0===new Uint8Array(e,t,i).length)return this.warnings.push("Zero buffer length"),t;let a=t;for(;(!0===this.isIndefiniteForm?1:i)>0;){const t=ke(e,a,i);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(a=t.offset,this.blockLength+=t.result.blockLength,i-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===K.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===K.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(s,s+n),a}toBER(e=!1){let t=new ArrayBuffer(0);for(let i=0;i<this.value.length;i++)t=a(t,this.value[i].toBER(e));return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let i=0;i<this.value.length;i++)e.value.push(this.value[i].toJSON());return e}}class R extends B{constructor(e={}){super(e,N),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,i){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}}class T extends k{constructor(e={}){super(e)}fromBER(e,t,i){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class K extends B{constructor(e={}){super(e,T),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class H extends k{constructor(e={}){super(e),this.value=t(e,"value",!1),this.isHexOnly=t(e,"isHexOnly",!1),"valueHex"in e?this.valueHex=e.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const s=new Uint8Array(e,t,i);i>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(s.length);const n=new Uint8Array(this.valueHex);for(let r=0;r<s.length;r++)n[r]=s[r];return this.value=0!==c.call(this),this.blockLength=i,t+i}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=i(this.valueHex,0,this.valueHex.byteLength),e}}class U extends B{constructor(e={}){super(e,H),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class x extends R{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class M extends R{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class O extends B{constructor(e={}){super(e,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,i){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=i,t+i>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+i}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const i=new Uint8Array(t);return i[0]=5,i[1]=0,t}}class F extends(P(N)){constructor(e={}){super(e),this.isConstructed=t(e,"isConstructed",!1)}fromBER(e,t,i){let r=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(r=N.prototype.fromBER.call(this,e,t,i)))return r;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===K.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==_.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,r=super.fromBER(e,t,i),this.blockLength=i;return r}toBER(e=!1){if(!0===this.isConstructed)return N.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=i(this.valueHex,0,this.valueHex.byteLength),e}}class _ extends B{constructor(e={}){super(e,F),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,i){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===i?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,i)}static blockName(){return"OctetString"}isEqual(e){return e instanceof _!=0&&JSON.stringify(this)===JSON.stringify(e)}}class W extends(P(N)){constructor(e={}){super(e),this.unusedBits=t(e,"unusedBits",0),this.isConstructed=t(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(e,t,i){if(0===i)return t;let s=-1;if(!0===this.isConstructed){if(-1===(s=N.prototype.fromBER.call(this,e,t,i)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===K.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==V.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return s}if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const a=new Uint8Array(this.valueHex);for(let r=0;r<i-1;r++)a[r]=n[r+1];return this.blockLength=n.length,t+i}toBER(e=!1){if(!0===this.isConstructed)return N.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),i=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(i);r[0]=this.unusedBits;for(let s=0;s<this.valueHex.byteLength;s++)r[s+1]=t[s];return i}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=i(this.valueHex,0,this.valueHex.byteLength),e}}class V extends B{constructor(e={}){super(e,W),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,i){return 0===i?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,i))}isEqual(e){return e instanceof V!=0&&JSON.stringify(this)===JSON.stringify(e)}}class L extends(P(k)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=c.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=function(e){const t=e<0?-1*e:e;let i=128;for(let r=1;r<8;r++){if(t<=i){if(e<0){const e=n(i-t,8,r);return new Uint8Array(e)[0]|=128,e}let s=n(t,8,r),a=new Uint8Array(s);if(128&a[0]){const e=s.slice(0),t=new Uint8Array(e);s=new ArrayBuffer(s.byteLength+1),a=new Uint8Array(s);for(let i=0;i<e.byteLength;i++)a[i+1]=t[i];a[0]=0}return s}i*=Math.pow(2,8)}return new ArrayBuffer(0)}(e)}get valueDec(){return this._valueDec}fromDER(e,t,i,r=0){const s=this.fromBER(e,t,i);if(-1===s)return s;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==r&&this._valueHex.byteLength<r){r-this._valueHex.byteLength>1&&(r=this._valueHex.byteLength+1);const e=new ArrayBuffer(r);new Uint8Array(e).set(n,r-this._valueHex.byteLength),this._valueHex=e.slice(0)}return s}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),i=new Uint8Array(e);i[0]=0,i.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,i){const r=super.fromBER(e,t,i);return-1===r?r:(this.blockLength=i,t+i)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const i=new Uint8Array([0]);let r=new Uint8Array(e),s=new Uint8Array(t),n=r.slice(0);const a=n.length-1;let c=s.slice(0);const h=c.length-1;let l=0,u=0;for(let m=h<a?a:h;m>=0;m--,u++){switch(!0){case u<c.length:l=n[a-u]+c[h-u]+i[0];break;default:l=n[a-u]+i[0]}switch(i[0]=l/10,!0){case u>=n.length:n=o(new Uint8Array([l%10]),n);break;default:n[a-u]=l%10}}return i[0]>0&&(n=o(i,n)),n.slice(0)}function t(e){if(e>=C.length)for(let t=C.length;t<=e;t++){const e=new Uint8Array([0]);let i=C[t-1].slice(0);for(let t=i.length-1;t>=0;t--){const r=new Uint8Array([(i[t]<<1)+e[0]]);e[0]=r[0]/10,i[t]=r[0]%10}e[0]>0&&(i=o(e,i)),C.push(i)}return C[e]}function i(e,t){let i=0,r=new Uint8Array(e),s=new Uint8Array(t),n=r.slice(0);const a=n.length-1;let o=s.slice(0);const c=o.length-1;let h,l=0;for(let u=c;u>=0;u--,l++)switch(h=n[a-l]-o[c-l]-i,!0){case h<0:i=1,n[a-l]=h+10;break;default:i=0,n[a-l]=h}if(i>0)for(let u=a-c+1;u>=0;u--,l++){if(!((h=n[a-l]-i)<0)){i=0,n[a-l]=h;break}i=1,n[a-l]=h+10}return n.slice()}const r=8*this._valueHex.byteLength-1;let s,n=new Uint8Array(8*this._valueHex.byteLength/3),a=0;const c=new Uint8Array(this._valueHex);let h="",l=!1;for(let o=this._valueHex.byteLength-1;o>=0;o--){s=c[o];for(let o=0;o<8;o++){if(1==(1&s))switch(a){case r:n=i(t(a),n),h="-";break;default:n=e(n,t(a))}a++,s>>=1}}for(let o=0;o<n.length;o++)n[o]&&(l=!0),l&&(h+=g.charAt(n[o]));return!1===l&&(h+=g.charAt(0)),h}}class j extends B{constructor(e={}){super(e,L),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof j?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?h(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&h(this.valueBlock.valueHex,e)}convertToDER(){const e=new j({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new j({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class G extends j{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class $ extends(P(b)){constructor(e={}){super(e),this.valueDec=t(e,"valueDec",-1),this.isFirstSid=t(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,i){if(0===i)return t;if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);this.valueHex=new ArrayBuffer(i);let a=new Uint8Array(this.valueHex);for(let r=0;r<i&&(a[r]=127&n[r],this.blockLength++,0!=(128&n[r]));r++);const o=new ArrayBuffer(this.blockLength),c=new Uint8Array(o);for(let r=0;r<this.blockLength;r++)c[r]=a[r];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=s(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,i;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const r=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),i=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)i[e]=128|r[e];return i[this.blockLength-1]=r[this.blockLength-1],t}const r=n(this.valueDec,7);if(0===r.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(r.byteLength),!1===e){const e=new Uint8Array(r);i=new Uint8Array(t);for(let t=0;t<r.byteLength-1;t++)i[t]=128|e[t];i[r.byteLength-1]=e[r.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=i(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class Q extends k{constructor(e={}){super(e),this.fromString(t(e,"value",""))}fromBER(e,t,i){let r=t;for(;i>0;){const t=new $;if(-1===(r=t.fromBER(e,r,i)))return this.blockLength=0,this.error=t.error,r;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,i-=t.blockLength,this.value.push(t)}return r}toBER(e=!1){let t=new ArrayBuffer(0);for(let i=0;i<this.value.length;i++){const r=this.value[i].toBER(e);if(0===r.byteLength)return this.error=this.value[i].error,new ArrayBuffer(0);t=a(t,r)}return t}fromString(e){this.value=[];let t=0,i=0,r="",s=!1;do{if(r=-1===(i=e.indexOf(".",t))?e.substr(t):e.substr(t,i-t),t=i+1,s){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const i=parseInt(r,10);if(isNaN(i))return!0;e.valueDec=i+t,s=!1}else{const e=new $;if(e.valueDec=parseInt(r,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,s=!0),this.value.push(e)}}while(-1!==i);return!0}toString(){let e="",t=!1;for(let i=0;i<this.value.length;i++){t=this.value[i].isHexOnly;let r=this.value[i].toString();0!==i&&(e=`${e}.`),t?(r=`{${r}}`,this.value[i].isFirstSid?e=`2.{${r} - 80}`:e+=r):e+=r}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}e.value=this.toString(),e.sidArray=[];for(let i=0;i<this.value.length;i++)e.sidArray.push(this.value[i].toJSON());return e}}class q extends B{constructor(e={}){super(e,Q),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class J extends(P(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class z extends B{constructor(e={}){super(e,J),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),i=t.length;this.valueBlock.valueHex=new ArrayBuffer(i);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<i;s++)r[s]=t.charCodeAt(s);this.valueBlock.value=e}}class Z extends(P(b)){constructor(e={}){super(e),this.valueDec=t(e,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(e,t,i){if(0===i)return t;if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);this.valueHex=new ArrayBuffer(i);let a=new Uint8Array(this.valueHex);for(let r=0;r<i&&(a[r]=127&n[r],this.blockLength++,0!=(128&n[r]));r++);const o=new ArrayBuffer(this.blockLength),c=new Uint8Array(o);for(let r=0;r<this.blockLength;r++)c[r]=a[r];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=s(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,i;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const r=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),i=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)i[e]=128|r[e];return i[this.blockLength-1]=r[this.blockLength-1],t}const r=n(this.valueDec,7);if(0===r.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(r.byteLength),!1===e){const e=new Uint8Array(r);i=new Uint8Array(t);for(let t=0;t<r.byteLength-1;t++)i[t]=128|e[t];i[r.byteLength-1]=e[r.byteLength-1]}return t}toString(){return!0===this.isHexOnly?i(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString()}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.valueDec=this.valueDec,e}}class X extends k{constructor(e={}){super(e),this.fromString(t(e,"value",""))}fromBER(e,t,i){let r=t;for(;i>0;){const t=new Z;if(-1===(r=t.fromBER(e,r,i)))return this.blockLength=0,this.error=t.error,r;this.blockLength+=t.blockLength,i-=t.blockLength,this.value.push(t)}return r}toBER(e=!1){let t=new ArrayBuffer(0);for(let i=0;i<this.value.length;i++){const r=this.value[i].toBER(e);if(0===r.byteLength)return this.error=this.value[i].error,new ArrayBuffer(0);t=a(t,r)}return t}fromString(e){this.value=[];let t=0,i=0,r="";do{r=-1===(i=e.indexOf(".",t))?e.substr(t):e.substr(t,i-t),t=i+1;const s=new Z;if(s.valueDec=parseInt(r,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(-1!==i);return!0}toString(){let e="",t=!1;for(let i=0;i<this.value.length;i++){t=this.value[i].isHexOnly;let r=this.value[i].toString();0!==i&&(e=`${e}.`),e+=t?r=`{${r}}`:r}return e}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}e.value=this.toString(),e.sidArray=[];for(let i=0;i<this.value.length;i++)e.sidArray.push(this.value[i].toJSON());return e}}class Y extends B{constructor(e={}){super(e,X),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}class ee extends(P(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class te extends B{constructor(e={}){super(e,ee),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}fromBuffer(e){const t=e.slice(0),i=new Uint8Array(t);for(let r=0;r<i.length;r+=2){const e=i[r];i[r]=i[r+1],i[r+1]=e}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const i=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t;r++){const t=n(e.charCodeAt(r),8),s=new Uint8Array(t);if(s.length>2)continue;const a=2-s.length;for(let e=s.length-1;e>=0;e--)i[2*r+e+a]=s[e]}this.valueBlock.value=e}}class ie extends(P(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class re extends B{constructor(e={}){super(e,ie),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}fromBuffer(e){const t=e.slice(0),i=new Uint8Array(t);for(let r=0;r<i.length;r+=4)i[r]=i[r+3],i[r+1]=i[r+2],i[r+2]=0,i[r+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const i=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t;r++){const t=n(e.charCodeAt(r),8),s=new Uint8Array(t);if(s.length>4)continue;const a=4-s.length;for(let e=s.length-1;e>=0;e--)i[4*r+e+a]=s[e]}this.valueBlock.value=e}}class se extends(P(b)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.value=this.value,e}}class ne extends B{constructor(e={}){super(e,se),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const i=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t;r++)i[r]=e.charCodeAt(r);this.valueBlock.value=e}}class ae extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class oe extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class ce extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class he extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class le extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class ue extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class me extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class fe extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class de extends ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class pe extends me{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e.value.length;i++)t[i]=e.value.charCodeAt(i)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),i=new Uint8Array(t);for(let r=0;r<e.length;r++)i[r]=e.charCodeAt(r);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for convertion");const i=parseInt(t[1],10);this.year=i>=50?1900+i:2e3+i,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(){const e=new Array(7);return e[0]=l(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=l(this.month,2),e[2]=l(this.day,2),e[3]=l(this.hour,2),e[4]=l(this.minute,2),e[5]=l(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class Ae extends me{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e.value.length;i++)t[i]=e.value.charCodeAt(i)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,i){const r=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?i:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),r)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),i=new Uint8Array(t);for(let r=0;r<e.length;r++)i[r]=e.charCodeAt(r);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,i=!1,r="",s="",n=0,a=0,o=0;if("Z"===e[e.length-1])r=e.substr(0,e.length-1),i=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");r=e}if(i){if(-1!==r.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==r.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=r.indexOf("+"),i="";if(-1===t&&(t=r.indexOf("-"),e=-1),-1!==t){if(i=r.substr(t+1),r=r.substr(0,t),2!==i.length&&4!==i.length)throw new Error("Wrong input string for convertion");let s=new Number(i.substr(0,2));if(isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");if(a=e*s,4===i.length){if(s=new Number(i.substr(2,2)),isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");o=e*s}}}let c=r.indexOf(".");if(-1===c&&(c=r.indexOf(",")),-1!==c){const e=new Number(`0${r.substr(c)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=e.valueOf(),s=r.substr(0,c)}else s=r;switch(!0){case 8===s.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for convertion");break;case 10===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===s.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===s.length:t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c&&(this.millisecond=Math.floor(1e3*n));break;default:throw new Error("Wrong input string for convertion")}const h=t.exec(s);if(null===h)throw new Error("Wrong input string for convertion");for(let l=1;l<h.length;l++)switch(l){case 1:this.year=parseInt(h[l],10);break;case 2:this.month=parseInt(h[l],10);break;case 3:this.day=parseInt(h[l],10);break;case 4:this.hour=parseInt(h[l],10)+a;break;case 5:this.minute=parseInt(h[l],10)+o;break;case 6:this.second=parseInt(h[l],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===i){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(l(this.year,4)),e.push(l(this.month,2)),e.push(l(this.day,2)),e.push(l(this.hour,2)),e.push(l(this.minute,2)),e.push(l(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(l(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(t){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class Se extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class ye extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class we extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class Ce extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class ge extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class be{constructor(e={}){this.value=t(e,"value",[]),this.optional=t(e,"optional",!1)}}class Pe{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1)}}class Ee{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1),this.value=t(e,"value",new Pe),this.local=t(e,"local",!1)}}class ve{constructor(e={}){this.data=t(e,"data",new ArrayBuffer(0))}fromBER(e,t,i){return this.data=e.slice(t,i),t+i}toBER(e=!1){return this.data}}function ke(e,t,i){const s=t;let n=new B({},Object);const a=new b;if(!1===r(a,e,t,i))return n.error=a.error,{offset:-1,result:n};if(0===new Uint8Array(e,t,i).length)return this.error="Zero buffer length",{offset:-1,result:n};let o=n.idBlock.fromBER(e,t,i);if(n.warnings.concat(n.idBlock.warnings),-1===o)return n.error=n.idBlock.error,{offset:-1,result:n};if(o=n.lenBlock.fromBER(e,t=o,i-=n.idBlock.blockLength),n.warnings.concat(n.lenBlock.warnings),-1===o)return n.error=n.lenBlock.error,{offset:-1,result:n};if(t=o,i-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let c=B;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};c=K;break;case 1:c=U;break;case 2:c=j;break;case 3:c=V;break;case 4:c=_;break;case 5:c=O;break;case 6:c=q;break;case 10:c=G;break;case 12:c=z;break;case 13:c=Y;break;case 14:c=ge;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:c=x;break;case 17:c=M;break;case 18:c=ae;break;case 19:c=oe;break;case 20:c=ce;break;case 21:c=he;break;case 22:c=le;break;case 23:c=pe;break;case 24:c=Ae;break;case 25:c=ue;break;case 26:c=me;break;case 27:c=fe;break;case 28:c=re;break;case 29:c=de;break;case 30:c=te;break;case 31:c=Se;break;case 32:c=ye;break;case 33:c=we;break;case 34:c=Ce;break;default:{let r;(r=!0===n.idBlock.isConstructed?new R:new D).idBlock=n.idBlock,r.lenBlock=n.lenBlock,r.warnings=n.warnings,o=(n=r).fromBER(e,t,i)}}break;case 2:case 3:case 4:default:c=!0===n.idBlock.isConstructed?R:D}return o=(n=function(e,t){if(e instanceof t)return e;const i=new t;return i.idBlock=e.idBlock,i.lenBlock=e.lenBlock,i.warnings=e.warnings,i.valueBeforeDecode=e.valueBeforeDecode.slice(0),i}(n,c)).fromBER(e,t,!0===n.lenBlock.isIndefiniteForm?i:n.lenBlock.length),n.valueBeforeDecode=e.slice(s,s+n.blockLength),{offset:o,result:n}}function Be(e){if(0===e.byteLength){const e=new B({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ke(e,0,e.byteLength)}function Ie(e,t,i){if(i instanceof be){for(let r=0;r<i.value.length;r++)if(!0===Ie(e,t,i.value[r]).verified)return{verified:!0,result:e};{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return i.hasOwnProperty("name")&&(e.name=i.name),e}}if(i instanceof Pe)return i.hasOwnProperty("name")&&(e[i.name]=t),{verified:!0,result:e};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(i instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in i==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in i.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in i.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=i.idBlock.toBER(!1);if(0===r.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===i.idBlock.fromBER(r,0,r.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===i.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(i.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===i.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(i.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===i.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(i.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in i.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(i.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===i.idBlock.isHexOnly){if("valueHex"in i.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=new Uint8Array(i.idBlock.valueHex),s=new Uint8Array(t.idBlock.valueHex);if(r.length!==s.length)return{verified:!1,result:e};for(let t=0;t<r.length;t++)if(r[t]!==s[1])return{verified:!1,result:e}}if(i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&(e[i.name]=t)),!0===i.idBlock.isConstructed){let r=0,s={verified:!1},n=i.valueBlock.value.length;if(n>0&&i.valueBlock.value[0]instanceof Ee&&(n=t.valueBlock.value.length),0===n)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==i.valueBlock.value.length){let t=!0;for(let e=0;e<i.valueBlock.value.length;e++)t=t&&(i.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&delete e[i.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let a=0;a<n;a++)if(a-r>=t.valueBlock.value.length){if(!1===i.valueBlock.value[a].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&(delete e[i.name],t.name=i.name)),t}}else if(i.valueBlock.value[0]instanceof Ee){if(!1===(s=Ie(e,t.valueBlock.value[a],i.valueBlock.value[0].value)).verified){if(!0!==i.valueBlock.value[0].optional)return i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&delete e[i.name]),s;r++}if("name"in i.valueBlock.value[0]&&i.valueBlock.value[0].name.length>0){let r={};void 0===(r="local"in i.valueBlock.value[0]&&!0===i.valueBlock.value[0].local?t:e)[i.valueBlock.value[0].name]&&(r[i.valueBlock.value[0].name]=[]),r[i.valueBlock.value[0].name].push(t.valueBlock.value[a])}}else if(!1===(s=Ie(e,t.valueBlock.value[a-r],i.valueBlock.value[a])).verified){if(!0!==i.valueBlock.value[a].optional)return i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&delete e[i.name]),s;r++}if(!1===s.verified){const t={verified:!1,result:e};return i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&(delete e[i.name],t.name=i.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in i&&"valueHex"in t.valueBlock){const r=Be(t.valueBlock.valueHex);if(-1===r.offset){const t={verified:!1,result:r.result};return i.hasOwnProperty("name")&&(i.name=i.name.replace(/^\s+|\s+$/g,""),""!==i.name&&(delete e[i.name],t.name=i.name)),t}return Ie(e,r.result,i.primitiveSchema)}return{verified:!0,result:e}}function De(e){return"undefined"!=typeof Buffer&&Buffer.isBuffer(e)?new Uint8Array(e):ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):new Uint8Array(e)}class Ne{static ToString(e,t="utf8"){const i=De(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(i);case"binary":return this.ToBinary(i);case"hex":return this.ToHex(i);case"base64":return this.ToBase64(i);case"base64url":return this.ToBase64Url(i);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=De(e);if("undefined"!=typeof btoa){const e=this.ToString(t,"binary");return btoa(e)}return Buffer.from(t).toString("base64")}static FromBase64(e){return e=e.replace(/\n/g,"").replace(/\r/g,"").replace(/\t/g,"").replace(/\s/g,""),"undefined"!=typeof atob?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(e){return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),i=new Uint8Array(t.length);for(let r=0;r<t.length;r++)i[r]=t.charCodeAt(r);return i.buffer}static ToUtf8String(e){const t=De(e),i=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(i))}static FromBinary(e){const t=e.length,i=new Uint8Array(t);for(let r=0;r<t;r++)i[r]=e.charCodeAt(r);return i.buffer}static ToBinary(e){const t=De(e);let i="";const r=t.length;for(let s=0;s<r;s++)i+=String.fromCharCode(t[s]);return i}static ToHex(e){const t=De(e),i=[],r=t.length;for(let s=0;s<r;s++){const e=t[s].toString(16);i.push(1===e.length?"0"+e:e)}return i.join("")}static FromHex(e){const t=new Uint8Array(e.length/2);for(let i=0;i<e.length;i+=2){const r=e.slice(i,i+2);t[i/2]=parseInt(r,16)}return t.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let i=0;i<t;i++)e+="=";return e}}class Re{constructor(e,t){this.input=e,this.name=t,this.init()}static base64Clear(e){const t=atob(e.replace(/[\s\r\n]/g,""));return Re.validation.isPem(t)?atob(t.replace(/-----.+-----/g,"").replace(/[\s\r\n]/g,"")):t}static pemTagCertificate(e){return`-----BEGIN CERTIFICATE-----\n${e}\n-----END CERTIFICATE-----`}static pemTagCertificateRequest(e){return`-----BEGIN CERTIFICATE REQUEST-----\n${e}\n-----END CERTIFICATE REQUEST-----`}static pemTagNewCertificateRequest(e){return`-----BEGIN NEW CERTIFICATE REQUEST-----\n${e}\n-----END NEW CERTIFICATE REQUEST-----`}static formatHex(e){return e.replace(/(.{32})/g,"$1\n").replace(/(.{4})/g,"$1 ").trim()}init(){let e;e=Re.validation.isHex(this.input)?Ne.FromHex(this.input):Ne.FromBase64(this.input),this.schema=Be(e).result,this.base64=Ne.ToBase64(e),this.hex=Re.formatHex(Ne.ToHex(e))}async getFingerprint(){try{const e=await crypto.subtle.digest("SHA-1",this.schema.valueBeforeDecode);this.fingerprint=Ne.ToHex(e)}catch(e){console.error(e)}}static prepareSubject(e){if(!e)return;const t={};return e.forEach(e=>{const i=Re.subjectOIDs[e.type.toString()],r=i&&i.short?i.short:e.type.toString();t[r]={nameLong:i?i.long:"",oid:e.type.toString(),value:e.value.valueBlock.value.toString()}}),t}static prepareAlgorithm(e){return e?Re.algorithmOIDs[e.algorithmId]?Re.algorithmOIDs[e.algorithmId]:{name:e.algorithmId}:{name:""}}}Re.algorithmOIDs={"1.2.840.113549.1.1.5":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-1"},"1.2.840.113549.1.1.11":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},"1.2.840.113549.1.1.12":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-384"},"1.2.840.113549.1.1.13":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-512"},"1.2.840.113549.1.1.14":{name:"RSASSA-PKCS1-v1_5",hash:"SHA-224"},"1.2.840.10045.4.1":{name:"ECDSA",hash:"SHA-1"},"1.2.840.10045.4.2":{name:"ECDSA",hash:"Recommended"},"1.2.840.10045.4.3":{name:"ECDSA",hash:"Specified"},"1.2.840.10045.4.3.1":{name:"ECDSA",hash:"SHA-224"},"1.2.840.10045.4.3.2":{name:"ECDSA",hash:"SHA-256"},"1.2.840.10045.4.3.3":{name:"ECDSA",hash:"SHA-384"},"1.2.840.10045.4.3.4":{name:"ECDSA",hash:"SHA-512"}},Re.subjectOIDs={"2.5.4.3":{short:"CN",long:"Common Name"},"2.5.4.6":{short:"C",long:"Country"},"2.5.4.5":{short:"serialNumber",long:"Serial Number"},"0.9.2342.19200300.100.1.25":{short:"DC",long:"Domain Component"},"1.2.840.113549.1.9.1":{short:"E",long:"Email"},"2.5.4.42":{short:"G",long:"Given Name"},"2.5.4.43":{short:"I",long:"Initials"},"2.5.4.7":{short:"L",long:"Locality"},"2.5.4.10":{short:"O",long:"Organization"},"2.5.4.11":{short:"OU",long:"Organization Unit"},"2.5.4.8":{short:"ST",long:"State"},"2.5.4.9":{short:"Street",long:"Street Address"},"2.5.4.4":{short:"SN",long:"Surname"},"2.5.4.12":{short:"T",long:"Title"},"1.2.840.113549.1.9.8":{long:"Unstructured Address"},"1.2.840.113549.1.9.2":{long:"Unstructured Name"},"1.3.6.1.4.1.311.60.2.1.3":{short:"jurisdictionCountry",long:"Jurisdiction Country"},"2.5.4.15":{short:"businessCategory",long:"Business Category"},"1.3.6.1.2.1.1.5":{long:"Host Name"}},Re.validation={isHex:e=>/^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(e),isPem:e=>/-----BEGIN.+-----/.test(e)};class Te{constructor(e={}){this.algorithmId=t(e,"algorithmId",Te.defaultValues("algorithmId")),"algorithmParams"in e&&(this.algorithmParams=t(e,"algorithmParams",Te.defaultValues("algorithmParams"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new Pe;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof Pe;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",optional:i.optional||!1,value:[new q({name:i.algorithmIdentifier||""}),new Pe({name:i.algorithmParams||"",optional:!0})]})}fromSchema(e){w(e,["algorithm","params"]);const t=Ie(e,e,Te.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new q({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof Pe==0&&e.push(this.algorithmParams),new x({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof Pe==0&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof Te!=0&&this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e))}}class Ke{constructor(e={}){this.x=t(e,"x",Ke.defaultValues("x")),this.y=t(e,"y",Ke.defaultValues("y")),this.namedCurve=t(e,"namedCurve",Ke.defaultValues("namedCurve")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return h(t,Ke.defaultValues(e));case"namedCurve":return""===t;default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static schema(e={}){return new ve}fromSchema(e){if(e instanceof ArrayBuffer==0)throw new Error("Object's schema was not verified against input data for ECPublicKey");if(4!==new Uint8Array(e)[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let t;switch(this.namedCurve){case"1.2.840.10045.3.1.7":t=32;break;case"1.3.132.0.34":t=48;break;case"1.3.132.0.35":t=66;break;default:throw new Error(`Incorrect curve OID: ${this.namedCurve}`)}if(e.byteLength!==2*t+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,t+1),this.y=e.slice(1+t,2*t+1)}toSchema(){return new ve({data:a(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:f(p(this.x),!0,!0,!1),y:f(p(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const i=A(d(e.x,!0));if(i.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),r=new Uint8Array(i);e.set(r,1)}else this.x=i.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const i=A(d(e.y,!0));if(i.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),r=new Uint8Array(i);e.set(r,1)}else this.y=i.slice(0,t)}}}class He{constructor(e={}){this.modulus=t(e,"modulus",He.defaultValues("modulus")),this.publicExponent=t(e,"publicExponent",He.defaultValues("publicExponent")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new j;default:throw new Error(`Invalid member name for RSAPublicKey class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new j({name:i.modulus||""}),new j({name:i.publicExponent||""})]})}fromSchema(e){w(e,["modulus","publicExponent"]);const t=Ie(e,e,He.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new x({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:f(p(this.modulus.valueBlock.valueHex),!0,!0,!0),e:f(p(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=A(d(e.n,!0));this.modulus=new j({valueHex:t.slice(0,Math.pow(2,y(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new j({valueHex:A(d(e.e,!0)).slice(0,3)})}}class Ue{constructor(e={}){this.algorithm=t(e,"algorithm",Ue.defaultValues("algorithm")),this.subjectPublicKey=t(e,"subjectPublicKey",Ue.defaultValues("subjectPublicKey")),"parsedKey"in e&&(this.parsedKey=t(e,"parsedKey",Ue.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"algorithm":return new Te;case"subjectPublicKey":return new V;default:throw new Error(`Invalid member name for PublicKeyInfo class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[Te.schema(i.algorithm||{}),new V({name:i.subjectPublicKey||""})]})}fromSchema(e){w(e,["algorithm","subjectPublicKey"]);const t=Ie(e,e,Ue.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PublicKeyInfo");switch(this.algorithm=new Te({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===q.blockName())try{this.parsedKey=new Ke({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(i){}break;case"1.2.840.113549.1.1.1":{const e=Be(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new He({schema:e.result})}catch(i){}}}}toSchema(){return new x({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==0)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const i of Object.keys(t))e[i]=t[i];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Ke({json:e}),this.algorithm=new Te({algorithmId:"1.2.840.10045.2.1",algorithmParams:new q({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new He({json:e}),this.algorithm=new Te({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new O});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new V({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const i=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const r=Je();return void 0===r?Promise.reject("Unable to create WebCrypto object"):t=(t=t.then(()=>r.exportKey("spki",e))).then(e=>{const t=Be(e);try{i.fromSchema(t.result)}catch(r){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject(`Error during exporting public key: ${e}`))}}class xe{constructor(e={}){this.type=t(e,"type",xe.defaultValues("type")),this.values=t(e,"values",xe.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.type||""}),new M({name:i.setName||"",value:[new Ee({name:i.values||"",value:new Pe})]})]})}fromSchema(e){w(e,["type","values"]);const t=Ie(e,e,xe.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Attribute");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new x({value:[new q({value:this.type}),new M({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class Me{constructor(e={}){this.version=t(e,"version",Me.defaultValues("version")),this.privateKey=t(e,"privateKey",Me.defaultValues("privateKey")),"namedCurve"in e&&(this.namedCurve=t(e,"namedCurve",Me.defaultValues("namedCurve"))),"publicKey"in e&&(this.publicKey=t(e,"publicKey",Me.defaultValues("publicKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new _;case"namedCurve":return"";case"publicKey":return new Ke;default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Me.defaultValues(e);case"privateKey":return t.isEqual(Me.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return Ke.compareWithDefault("namedCurve",t.namedCurve)&&Ke.compareWithDefault("x",t.x)&&Ke.compareWithDefault("y",t.y);default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new j({name:i.version||""}),new _({name:i.privateKey||""}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new q({name:i.namedCurve||""})]}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new V({name:i.publicKey||""})]})]})}fromSchema(e){w(e,["version","privateKey","namedCurve","publicKey"]);const t=Ie(e,e,Me.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new Ke(e)}}toSchema(){const e=[new j({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new R({idBlock:{tagClass:3,tagNumber:0},value:[new q({value:this.namedCurve})]})),"publicKey"in this&&e.push(new R({idBlock:{tagClass:3,tagNumber:1},value:[new V({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new x({value:e})}toJSON(){if("namedCurve"in this==0||Me.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:f(p(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const i=A(d(e.d,!0));if(i.byteLength<t){const e=new ArrayBuffer(t),r=new Uint8Array(e),s=new Uint8Array(i);r.set(s,1),this.privateKey=new _({valueHex:e})}else this.privateKey=new _({valueHex:i.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new Ke({json:e}))}}class Oe{constructor(e={}){this.prime=t(e,"prime",Oe.defaultValues("prime")),this.exponent=t(e,"exponent",Oe.defaultValues("exponent")),this.coefficient=t(e,"coefficient",Oe.defaultValues("coefficient")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new j;default:throw new Error(`Invalid member name for OtherPrimeInfo class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new j({name:i.prime||""}),new j({name:i.exponent||""}),new j({name:i.coefficient||""})]})}fromSchema(e){w(e,["prime","exponent","coefficient"]);const t=Ie(e,e,Oe.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new x({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:f(p(this.prime.valueBlock.valueHex),!0,!0),d:f(p(this.exponent.valueBlock.valueHex),!0,!0),t:f(p(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new j({valueHex:A(d(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new j({valueHex:A(d(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new j({valueHex:A(d(e.t,!0))})}}class Fe{constructor(e={}){this.version=t(e,"version",Fe.defaultValues("version")),this.modulus=t(e,"modulus",Fe.defaultValues("modulus")),this.publicExponent=t(e,"publicExponent",Fe.defaultValues("publicExponent")),this.privateExponent=t(e,"privateExponent",Fe.defaultValues("privateExponent")),this.prime1=t(e,"prime1",Fe.defaultValues("prime1")),this.prime2=t(e,"prime2",Fe.defaultValues("prime2")),this.exponent1=t(e,"exponent1",Fe.defaultValues("exponent1")),this.exponent2=t(e,"exponent2",Fe.defaultValues("exponent2")),this.coefficient=t(e,"coefficient",Fe.defaultValues("coefficient")),"otherPrimeInfos"in e&&(this.otherPrimeInfos=t(e,"otherPrimeInfos",Fe.defaultValues("otherPrimeInfos"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new j;case"otherPrimeInfos":return[];default:throw new Error(`Invalid member name for RSAPrivateKey class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new j({name:i.version||""}),new j({name:i.modulus||""}),new j({name:i.publicExponent||""}),new j({name:i.privateExponent||""}),new j({name:i.prime1||""}),new j({name:i.prime2||""}),new j({name:i.exponent1||""}),new j({name:i.exponent2||""}),new j({name:i.coefficient||""}),new x({optional:!0,value:[new Ee({name:i.otherPrimeInfosName||"",value:Oe.schema(i.otherPrimeInfo||{})})]})]})}fromSchema(e){w(e,["version","modulus","publicExponent","privateExponent","prime1","prime2","exponent1","exponent2","coefficient","otherPrimeInfos"]);const t=Ie(e,e,Fe.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new Oe({schema:e})))}toSchema(){const e=[];return e.push(new j({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new x({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={n:f(p(this.modulus.valueBlock.valueHex),!0,!0,!0),e:f(p(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:f(p(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:f(p(this.prime1.valueBlock.valueHex),!0,!0,!0),q:f(p(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:f(p(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:f(p(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:f(p(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new j({valueHex:A(d(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new j({valueHex:A(d(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new j({valueHex:A(d(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new j({valueHex:A(d(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new j({valueHex:A(d(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new j({valueHex:A(d(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new j({valueHex:A(d(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new j({valueHex:A(d(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new Oe({json:e})))}}class _e{constructor(e={}){this.version=t(e,"version",_e.defaultValues("version")),this.privateKeyAlgorithm=t(e,"privateKeyAlgorithm",_e.defaultValues("privateKeyAlgorithm")),this.privateKey=t(e,"privateKey",_e.defaultValues("privateKey")),"attributes"in e&&(this.attributes=t(e,"attributes",_e.defaultValues("attributes"))),"parsedKey"in e&&(this.parsedKey=t(e,"parsedKey",_e.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new Te;case"privateKey":return new _;case"attributes":return[];case"parsedKey":return{};default:throw new Error(`Invalid member name for PrivateKeyInfo class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new j({name:i.version||""}),Te.schema(i.privateKeyAlgorithm||{}),new _({name:i.privateKey||""}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ee({name:i.attributes||"",value:xe.schema()})]})]})}fromSchema(e){w(e,["version","privateKeyAlgorithm","privateKey","attributes"]);const t=Ie(e,e,_e.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new Te({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new xe({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=Be(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Fe({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof q){const e=Be(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Me({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new j({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new x({value:e})}toJSON(){if("parsedKey"in this==0){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const i of Object.keys(t))e[i]=t[i];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Me({json:e}),this.privateKeyAlgorithm=new Te({algorithmId:"1.2.840.10045.2.1",algorithmParams:new q({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Fe({json:e}),this.privateKeyAlgorithm=new Te({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new O});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new _({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class We{constructor(e={}){if(this.contentType=t(e,"contentType",We.defaultValues("contentType")),this.contentEncryptionAlgorithm=t(e,"contentEncryptionAlgorithm",We.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in e&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new _({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,i=this.encryptedContent.valueBlock.valueHex.byteLength;for(;i>0;){const r=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),s=new ArrayBuffer(r.length),n=new Uint8Array(s);for(let e=0;e<n.length;e++)n[e]=r[e];e.valueBlock.value.push(new _({valueHex:s})),i-=r.length,t+=r.length}this.encryptedContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new Te;case"encryptedContent":return new _;default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==0;case"encryptedContent":return t.isEqual(We.defaultValues(e));default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.contentType||""}),Te.schema(i.contentEncryptionAlgorithm||{}),new be({value:[new R({name:i.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new Ee({value:new _})]}),new D({name:i.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){w(e,["contentType","contentEncryptionAlgorithm","encryptedContent"]);const t=Ie(e,e,We.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new Te({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new q({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const i=this.encryptedContent;i.idBlock.tagClass=3,i.idBlock.tagNumber=0,i.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(i)}return new x({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Ve{constructor(e={}){this.hashAlgorithm=t(e,"hashAlgorithm",Ve.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=t(e,"maskGenAlgorithm",Ve.defaultValues("maskGenAlgorithm")),this.saltLength=t(e,"saltLength",Ve.defaultValues("saltLength")),this.trailerField=t(e,"trailerField",Ve.defaultValues("trailerField")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Te({algorithmId:"1.3.14.3.2.26",algorithmParams:new O});case"maskGenAlgorithm":return new Te({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Te({algorithmId:"1.3.14.3.2.26",algorithmParams:new O}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error(`Invalid member name for RSASSAPSSParams class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new R({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Te.schema(i.hashAlgorithm||{})]}),new R({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Te.schema(i.maskGenAlgorithm||{})]}),new R({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new j({name:i.saltLength||""})]}),new R({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new j({name:i.trailerField||""})]})]})}fromSchema(e){w(e,["hashAlgorithm","maskGenAlgorithm","saltLength","trailerField"]);const t=Ie(e,e,Ve.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Te({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Te({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Ve.defaultValues("hashAlgorithm"))||e.push(new R({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Ve.defaultValues("maskGenAlgorithm"))||e.push(new R({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Ve.defaultValues("saltLength")&&e.push(new R({idBlock:{tagClass:3,tagNumber:2},value:[new j({value:this.saltLength})]})),this.trailerField!==Ve.defaultValues("trailerField")&&e.push(new R({idBlock:{tagClass:3,tagNumber:3},value:[new j({value:this.trailerField})]})),new x({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Ve.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Ve.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Ve.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Ve.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class Le{constructor(e={}){this.salt=t(e,"salt",Le.defaultValues("salt")),this.iterationCount=t(e,"iterationCount",Le.defaultValues("iterationCount")),"keyLength"in e&&(this.keyLength=t(e,"keyLength",Le.defaultValues("keyLength"))),"prf"in e&&(this.prf=t(e,"prf",Le.defaultValues("prf"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new Te({algorithmId:"1.3.14.3.2.26",algorithmParams:new O});default:throw new Error(`Invalid member name for PBKDF2Params class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new be({value:[new _({name:i.saltPrimitive||""}),Te.schema(i.saltConstructed||{})]}),new j({name:i.iterationCount||""}),new j({name:i.keyLength||"",optional:!0}),Te.schema(i.prf||{names:{optional:!0}})]})}fromSchema(e){w(e,["salt","iterationCount","keyLength","prf"]);const t=Ie(e,e,Le.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2Params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new Te({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new j({value:this.iterationCount})),"keyLength"in this&&Le.defaultValues("keyLength")!==this.keyLength&&e.push(new j({value:this.keyLength})),"prf"in this&&!1===Le.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new x({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&Le.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===Le.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class je{constructor(e={}){this.keyDerivationFunc=t(e,"keyDerivationFunc",je.defaultValues("keyDerivationFunc")),this.encryptionScheme=t(e,"encryptionScheme",je.defaultValues("encryptionScheme")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new Te;default:throw new Error(`Invalid member name for PBES2Params class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[Te.schema(i.keyDerivationFunc||{}),Te.schema(i.encryptionScheme||{})]})}fromSchema(e){w(e,["keyDerivationFunc","encryptionScheme"]);const t=Ie(e,e,je.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2Params");this.keyDerivationFunc=new Te({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new Te({schema:t.result.encryptionScheme})}toSchema(){return new x({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Ge(e,t,i,r,s,n){let a,o;const c=[];switch(t.toUpperCase()){case"SHA-1":a=20,o=64;break;case"SHA-256":a=32,o=64;break;case"SHA-384":a=48,o=128;break;case"SHA-512":a=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const h=new Uint8Array(r),l=new ArrayBuffer(2*r.byteLength+2),u=new Uint8Array(l);for(let I=0;I<h.length;I++)u[2*I]=0,u[2*I+1]=h[I];u[u.length-2]=0,u[u.length-1]=0,r=l.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let I=0;I<m.byteLength;I++)f[I]=3;const d=s.byteLength,p=o*Math.ceil(d/o),A=new ArrayBuffer(p),S=new Uint8Array(A),y=new Uint8Array(s);for(let I=0;I<p;I++)S[I]=y[I%d];const w=r.byteLength,C=o*Math.ceil(w/o),g=new ArrayBuffer(C),b=new Uint8Array(g),P=new Uint8Array(r);for(let I=0;I<C;I++)b[I]=P[I%w];let E=new ArrayBuffer(A.byteLength+g.byteLength),v=new Uint8Array(E);v.set(S),v.set(b,S.length);const k=Math.ceil((i>>3)/a);let B=Promise.resolve(E);for(let I=0;I<=k;I++){B=B.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),i=new Uint8Array(t);return i.set(f),i.set(v,f.length),t});for(let i=0;i<n;i++)B=B.then(i=>e.digest({name:t},new Uint8Array(i)));B=B.then(e=>{const t=new ArrayBuffer(o),i=new Uint8Array(t);for(let o=0;o<t.byteLength;o++)i[o]=e[o%e.length];const r=Math.ceil(d/o)+Math.ceil(w/o),s=[];let n=0,a=o;for(let c=0;c<r;c++){const e=Array.from(new Uint8Array(E.slice(n,n+a)));(n+=o)+o>E.byteLength&&(a=E.byteLength-n);let r=511;for(let s=t.byteLength-1;s>=0;s--)r>>=8,e[s]=255&(r+=i[s]+e[s]);s.push(...e)}return E=new ArrayBuffer(s.length),(v=new Uint8Array(E)).set(s),c.push(...new Uint8Array(e)),E})}return B.then(()=>{const e=new ArrayBuffer(i>>3);return new Uint8Array(e).set(new Uint8Array(c).slice(0,i>>3)),e})}class $e{constructor(e={}){this.crypto=t(e,"crypto",{}),this.subtle=t(e,"subtle",{}),this.name=t(e,"name","")}importKey(e,t,i,r,s){let n={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,i,r,s);case"spki":{const e=Be(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const o=new Ue;try{o.fromSchema(e.result)}catch(a){return Promise.reject("Incorrect keyData")}switch(i.name.toUpperCase()){case"RSA-PSS":switch(i.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${i.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(s=["verify"],n.kty="RSA",n.ext=r,n.key_ops=s,"1.2.840.113549.1.1.1"!==o.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`);if("alg"in n==0)switch(i.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`)}const e=o.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"ECDSA":s=["verify"];case"ECDH":{if(n={kty:"EC",ext:r,key_ops:s},"1.2.840.10045.2.1"!==o.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`);const e=o.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=r,n.key_ops=s,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(i.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect public key algorithm: ${o.algorithm.algorithmId}`)}const e=o.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;default:return Promise.reject(`Incorrect algorithm name: ${i.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new _e,o=Be(t);if(-1===o.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(o.result)}catch(a){return Promise.reject("Incorrect keyData")}if("parsedKey"in e==0)return Promise.reject("Incorrect keyData");switch(i.name.toUpperCase()){case"RSA-PSS":switch(i.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${i.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(s=["sign"],n.kty="RSA",n.ext=r,n.key_ops=s,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in n==0)switch(i.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${i.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"ECDSA":s=["sign"];case"ECDH":{if(n={kty:"EC",ext:r,key_ops:s},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=r,n.key_ops=s,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(i.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect hash algorithm: ${i.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;default:return Promise.reject(`Incorrect algorithm name: ${i.name.toUpperCase()}`)}}break;case"jwk":n=t;break;default:return Promise.reject(`Incorrect format: ${e}`)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",A(JSON.stringify(n)),i,r,s)).then(e=>e,()=>this.subtle.importKey("jwk",n,i,r,s)):this.subtle.importKey("jwk",n,i,r,s)}exportKey(e,t){let i=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(i=i.then(e=>e instanceof ArrayBuffer?JSON.parse(p(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":i=i.then(e=>{const t=new Ue;try{t.fromJSON(e)}catch(i){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":i=i.then(e=>{const t=new _e;try{t.fromJSON(e)}catch(i){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject(`Incorrect format: ${e}`)}return i}convert(e,t,i,r,s,n){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(i);case"spki":return Promise.resolve().then(()=>this.importKey("raw",i,r,s,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",i,r,s,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",i,r,s,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",i,r,s,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(i);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",i,r,s,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",i,r,s,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(i);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",i,r,s,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",i,r,s,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",i,r,s,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",i,r,s,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(i);default:return Promise.reject(`Incorrect outputFormat: ${t}`)}default:return Promise.reject(`Incorrect inputFormat: ${e}`)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let i={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":i={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":i={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":i={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":i={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":i={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":i={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":i={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":i={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":i={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":i={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":i={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":i={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":i={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":i={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":i={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":i={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":i={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":i={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":i={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":i={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":i={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":i={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":i={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":i={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return i}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const i=new Ve({schema:e.algorithmParams});if("hashAlgorithm"in i){const e=this.getAlgorithmByOID(i.hashAlgorithm.algorithmId);if("name"in e==0)return"";t=e.name}else t="SHA-1"}catch(i){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==0)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const i=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===i)return Promise.reject("Can not find OID for PBKDF2");const r=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===r)return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${e.hmacHashAlgorithm}`);let s=Promise.resolve();const n=new ArrayBuffer(16),a=new Uint8Array(n);this.getRandomValues(a);const o=new ArrayBuffer(64),c=new Uint8Array(o);this.getRandomValues(c);const h=new Uint8Array(e.contentToEncrypt),l=new Le({salt:new _({valueHex:o}),iterationCount:e.iterationCount,prf:new Te({algorithmId:r,algorithmParams:new O})});return(s=(s=(s=s.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:c,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e))).then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:a},t,h),e=>Promise.reject(e))).then(r=>{const s=new je({keyDerivationFunc:new Te({algorithmId:i,algorithmParams:l.toSchema()}),encryptionScheme:new Te({algorithmId:t,algorithmParams:new _({valueHex:n})})});return new We({contentType:e.contentType,contentEncryptionAlgorithm:new Te({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:s.toSchema()}),encryptedContent:new _({valueHex:r})})},e=>Promise.reject(e))}decryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,i,r=Promise.resolve();try{t=new je({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(l){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}try{i=new Le({schema:t.keyDerivationFunc.algorithmParams})}catch(l){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const s=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in s==0)return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${t.encryptionScheme.algorithmId}`);const n=new Uint8Array(t.encryptionScheme.algorithmParams.valueBlock.valueHex),o=new Uint8Array(i.salt.valueBlock.valueHex),c=i.iterationCount;let h="SHA-1";if("prf"in i){const e=this.getAlgorithmByOID(i.prf.algorithmId);if("name"in e==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");h=e.hash.name}return(r=(r=r.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e))).then(e=>this.deriveKey({name:"PBKDF2",hash:{name:h},salt:o,iterations:c},e,s,!1,["decrypt"]),e=>Promise.reject(e))).then(t=>{let i=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)i=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const r of e.encryptedContentInfo.encryptedContent.valueBlock.value)i=a(i,r.valueBlock.valueHex);return this.decrypt({name:s.name,iv:n},t,i)},e=>Promise.reject(e))}stampDataWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let i=Promise.resolve();const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return(i=(i=i.then(()=>Ge(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),r,!1,["sign"]))).then(t=>this.sign(r,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e))}verifyDataStampedWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let i=Promise.resolve();const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return(i=(i=i.then(()=>Ge(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),r,!1,["verify"]))).then(t=>this.verify(r,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e))}getSignatureParameters(e,t="SHA-1"){if(""===this.getOIDByAlgorithm({name:t}))return Promise.reject(`Unsupported hash algorithm: ${t}`);const i=new Te,r=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(r.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":i.algorithmId=this.getOIDByAlgorithm(r.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":r.algorithm.saltLength=32;break;case"SHA-384":r.algorithm.saltLength=48;break;case"SHA-512":r.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const i=this.getOIDByAlgorithm({name:t});if(""===i)return Promise.reject(`Unsupported hash algorithm: ${t}`);e.hashAlgorithm=new Te({algorithmId:i,algorithmParams:new O}),e.maskGenAlgorithm=new Te({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==r.algorithm.saltLength&&(e.saltLength=r.algorithm.saltLength);const s=new Ve(e);i.algorithmId="1.2.840.113549.1.1.10",i.algorithmParams=s.toSchema()}break;default:return Promise.reject(`Unsupported signature algorithm: ${e.algorithm.name}`)}return Promise.resolve().then(()=>({signatureAlgorithm:i,parameters:r}))}signWithPrivateKey(e,t,i){return this.sign(i.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===i.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,i=new ArrayBuffer(t);new Uint8Array(i).set(new Uint8Array(e,0,t));const r=new j({valueHex:i}),s=new ArrayBuffer(t);new Uint8Array(s).set(new Uint8Array(e,t,t));const n=new j({valueHex:s});return new x({value:[r.convertToDER(),n.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject(`Signing error: ${e}`))}fillPublicKeyParameters(e,t){const i={},r=this.getHashAlgorithm(t);if(""===r)return Promise.reject(`Unsupported signature algorithm: ${t.algorithmId}`);let s;const n=this.getAlgorithmByOID(s="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId);if("name"in n==="")return Promise.reject(`Unsupported public key algorithm: ${t.algorithmId}`);if(i.algorithm=this.getAlgorithmParameters(n.name,"importkey"),"hash"in i.algorithm.algorithm&&(i.algorithm.algorithm.hash.name=r),"ECDSA"===n.name){let t=!1;if("algorithmParams"in e.algorithm==1&&"idBlock"in e.algorithm.algorithmParams&&1===e.algorithm.algorithmParams.idBlock.tagClass&&6===e.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=this.getAlgorithmByOID(e.algorithm.algorithmParams.valueBlock.toString());if("name"in r==0)return Promise.reject(`Unsupported named curve algorithm: ${e.algorithm.algorithmParams.valueBlock.toString()}`);i.algorithm.algorithm.namedCurve=r.name}return i}getPublicKey(e,t,i=null){null===i&&(i=this.fillPublicKeyParameters(e,t));const r=e.toSchema().toBER(!1),s=new Uint8Array(r);return this.importKey("spki",s,i.algorithm.algorithm,!0,i.algorithm.usages)}verifyWithPublicKey(e,t,i,r,s=null){let n=Promise.resolve();if(null===s){if(""===(s=this.getHashAlgorithm(r)))return Promise.reject(`Unsupported signature algorithm: ${r.algorithmId}`);n=n.then(()=>this.getPublicKey(i,r))}else{const e={};let t;const a=this.getAlgorithmByOID(t="1.2.840.113549.1.1.10"===r.algorithmId?r.algorithmId:i.algorithm.algorithmId);if("name"in a==="")return Promise.reject(`Unsupported public key algorithm: ${r.algorithmId}`);if(e.algorithm=this.getAlgorithmParameters(a.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=s),"ECDSA"===a.name){let t=!1;if("algorithmParams"in i.algorithm==1&&"idBlock"in i.algorithm.algorithmParams&&1===i.algorithm.algorithmParams.idBlock.tagClass&&6===i.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=this.getAlgorithmByOID(i.algorithm.algorithmParams.valueBlock.toString());if("name"in r==0)return Promise.reject(`Unsupported named curve algorithm: ${i.algorithm.algorithmParams.valueBlock.toString()}`);e.algorithm.algorithm.namedCurve=r.name}n=n.then(()=>this.getPublicKey(i,null,e))}return n.then(i=>{const n=this.getAlgorithmParameters(i.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=s);let o=t.valueBlock.valueHex;if("ECDSA"===i.algorithm.name&&(o=function(e){if(e instanceof x==0)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof j==0)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof j==0)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),i=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<i.valueBlock.valueHex.byteLength:{if(i.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=i.valueBlock.valueHex.byteLength,r=new Uint8Array(t.valueBlock.valueHex),s=new ArrayBuffer(e),n=new Uint8Array(s);return n.set(r,1),n[0]=0,a(s,i.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>i.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-i.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,r=new Uint8Array(i.valueBlock.valueHex),s=new ArrayBuffer(e),n=new Uint8Array(s);return n.set(r,1),n[0]=0,a(t.valueBlock.valueHex,s)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,r=new Uint8Array(t.valueBlock.valueHex),s=new ArrayBuffer(e),n=new Uint8Array(s);n.set(r,1),n[0]=0;const o=new Uint8Array(i.valueBlock.valueHex),c=new ArrayBuffer(e),h=new Uint8Array(c);return h.set(o,1),h[0]=0,a(s,c)}}return a(t.valueBlock.valueHex,i.valueBlock.valueHex)}(Be(o).result)),"RSA-PSS"===i.algorithm.name){let e;try{e=new Ve({schema:r.algorithmParams})}catch(c){return Promise.reject(c)}n.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const i=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in i==0)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);t=i.name}n.algorithm.hash.name=t}return this.verify(n.algorithm,i,new Uint8Array(o),new Uint8Array(e))})}}let Qe={name:"none",crypto:null,subtle:null};function qe(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let t;try{t=global[process.pid].pkijs.engine}catch(e){throw new Error('Please call "setEngine" before call to "getEngine"')}return t}return Qe}function Je(){const e=qe();if(null!==e.subtle)return e.subtle}function ze(e){let t=!1,i="";const r=e.trim();for(let s=0;s<r.length;s++)32===r.charCodeAt(s)?!1===t&&(t=!0):(t&&(i+=" ",t=!1),i+=r[s]);return i.toLowerCase()}!function(){if("undefined"!=typeof self&&"crypto"in self){let t="webcrypto";const i=self.crypto;let r;if("webkitSubtle"in self.crypto){try{r=self.crypto.webkitSubtle}catch(e){r=self.crypto.subtle}t="safari"}"subtle"in self.crypto&&(r=self.crypto.subtle),Qe=void 0===r?{name:t,crypto:i,subtle:null}:{name:t,crypto:i,subtle:new $e({name:t,crypto:self.crypto,subtle:r})}}!function(e,t,i){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:e,crypto:t,subtle:i}}else Qe={name:e,crypto:t,subtle:i}}(Qe.name,Qe.crypto,Qe.subtle)}();class Ze{constructor(e={}){this.type=t(e,"type",Ze.defaultValues("type")),this.value=t(e,"value",Ze.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error(`Invalid member name for AttributeTypeAndValue class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.type||""}),new Pe({name:i.value||""})]})}static blockName(){return"AttributeTypeAndValue"}fromSchema(e){w(e,["type","typeValue"]);const t=Ie(e,e,Ze.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new x({value:[new q({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return e.value=0!==Object.keys(this.value).length?this.value.toJSON():this.value,e}isEqual(e){const t=[z.blockName(),te.blockName(),re.blockName(),ae.blockName(),oe.blockName(),ce.blockName(),he.blockName(),le.blockName(),ue.blockName(),me.blockName(),fe.blockName(),de.blockName()];if(e.constructor.blockName()===Ze.blockName()){if(this.type!==e.type)return!1;let i=!1;const r=this.value.constructor.blockName();if(r===e.value.constructor.blockName())for(const e of t)if(r===e){i=!0;break}if(i){const t=ze(this.value.valueBlock.value),i=ze(e.value.valueBlock.value);if(0!==t.localeCompare(i))return!1}else if(!1===h(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&h(this.value.valueBeforeDecode,e)}}class Xe{constructor(e={}){this.typesAndValues=t(e,"typesAndValues",Xe.defaultValues("typesAndValues")),this.valueBeforeDecode=t(e,"valueBeforeDecode",Xe.defaultValues("valueBeforeDecode")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.repeatedSequence||"",value:new M({value:[new Ee({name:i.repeatedSet||"",value:Ze.schema(i.typeAndValue||{})})]})})]})}fromSchema(e){w(e,["RDN","typesAndValues"]);const t=Ie(e,e,Xe.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new Ze({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){return 0===this.valueBeforeDecode.byteLength?new x({value:[new M({value:Array.from(this.typesAndValues,e=>e.toSchema())})]}):Be(this.valueBeforeDecode).result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof Xe){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,i]of this.typesAndValues.entries())if(!1===i.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&h(this.valueBeforeDecode,e)}}class Ye{constructor(e={}){this.type=t(e,"type",Ye.defaultValues("type")),this.value=t(e,"value",Ye.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error(`Invalid member name for Time class: ${e}`)}}static schema(e={},i=!1){const r=t(e,"names",{});return new be({optional:i,value:[new pe({name:r.utcTimeName||""}),new Ae({name:r.generalTimeName||""})]})}fromSchema(e){w(e,["utcTimeName","generalTimeName"]);const t=Ie(e,e,Ye.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Time");"utcTimeName"in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),"generalTimeName"in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){let e={};return 0===this.type&&(e=new pe({valueDate:this.value})),1===this.type&&(e=new Ae({valueDate:this.value})),e}toJSON(){return{type:this.type,value:this.value}}}class et{constructor(e={}){this.attributes=t(e,"attributes",et.defaultValues("attributes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.attributes||"",value:xe.schema()})]})}fromSchema(e){w(e,["attributes"]);const t=Ie(e,e,et.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new xe({schema:e}))}toSchema(){return new x({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class tt{constructor(e={}){"notBefore"in e&&(this.notBefore=t(e,"notBefore",tt.defaultValues("notBefore"))),"notAfter"in e&&(this.notAfter=t(e,"notAfter",tt.defaultValues("notAfter"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new D({name:i.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new D({name:i.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){w(e,["notBefore","notAfter"]);const t=Ie(e,e,tt.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new Ae;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new Ae({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:0},valueHex:new Ae({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:new Ae({valueDate:this.notAfter}).valueBlock.valueHex})),new x({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}function it(e={},i=!1){const r=t(e,"names",{});return new x({optional:i,value:[new R({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:r.country_name||"",value:[new be({value:[new ae,new oe]})]}),new R({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:r.administration_domain_name||"",value:[new be({value:[new ae,new oe]})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:r.network_address||"",isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:r.terminal_identifier||"",isHexOnly:!0}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:r.private_domain_name||"",value:[new be({value:[new ae,new oe]})]}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:r.organization_name||"",isHexOnly:!0}),new D({optional:!0,name:r.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new R({optional:!0,name:r.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new D({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new D({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new R({optional:!0,name:r.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new Ee({value:new oe})]})]})}function rt(e=!1){return new x({optional:e,value:[new oe,new oe]})}function st(e=!1){return new M({optional:e,value:[new D({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Pe]})]})}class nt{constructor(e={}){this.type=t(e,"type",nt.defaultValues("type")),this.value=t(e,"value",nt.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return t===nt.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new be({value:[new R({idBlock:{tagClass:3,tagNumber:0},name:i.blockName||"",value:[new q,new R({idBlock:{tagClass:3,tagNumber:0},value:[new Pe]})]}),new D({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new D({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new R({idBlock:{tagClass:3,tagNumber:3},name:i.blockName||"",value:[it(i.builtInStandardAttributes||{},!1),rt(!0),st(!0)]}),new R({idBlock:{tagClass:3,tagNumber:4},name:i.blockName||"",value:[Xe.schema(i.directoryName||{})]}),new R({idBlock:{tagClass:3,tagNumber:5},name:i.blockName||"",value:[new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new be({value:[new ce,new oe,new re,new z,new te]})]}),new R({idBlock:{tagClass:3,tagNumber:1},value:[new be({value:[new ce,new oe,new re,new z,new te]})]})]}),new D({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new D({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new D({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){w(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=Ie(e,e,nt.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralName");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const i=e.toBER(!1);this.value=Be(i).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new Xe({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new _({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const i=e.toBER(!1);this.value=Be(i).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new R({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new le({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new R({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new q({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return nt.schema()}}toJSON(){const e={type:this.type,value:""};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(t){}return e}}class at{constructor(e={}){this.altNames=t(e,"altNames",at.defaultValues("altNames")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error(`Invalid member name for AltName class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.altNames||"",value:nt.schema()})]})}fromSchema(e){w(e,["altNames"]);const t=Ie(e,e,at.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new nt({schema:e})))}toSchema(){return new x({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class ot{constructor(e={}){this.cA=t(e,"cA",!1),"pathLenConstraint"in e&&(this.pathLenConstraint=t(e,"pathLenConstraint",0)),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error(`Invalid member name for BasicConstraints class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new U({optional:!0,name:i.cA||""}),new j({optional:!0,name:i.pathLenConstraint||""})]})}fromSchema(e){w(e,["cA","pathLenConstraint"]);const t=Ie(e,e,ot.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.isHexOnly?t.result.pathLenConstraint:t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==ot.defaultValues("cA")&&e.push(new U({value:this.cA})),"pathLenConstraint"in this&&e.push(this.pathLenConstraint instanceof j?this.pathLenConstraint:new j({value:this.pathLenConstraint})),new x({value:e})}toJSON(){const e={};return this.cA!==ot.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(e.pathLenConstraint=this.pathLenConstraint instanceof j?this.pathLenConstraint.toJSON():this.pathLenConstraint),e}}class ct{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=t(e,"distributionPoint",ct.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=t(e,"onlyContainsUserCerts",ct.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=t(e,"onlyContainsCACerts",ct.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in e&&(this.onlySomeReasons=t(e,"onlySomeReasons",ct.defaultValues("onlySomeReasons"))),this.indirectCRL=t(e,"indirectCRL",ct.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=t(e,"onlyContainsAttributeCerts",ct.defaultValues("onlyContainsAttributeCerts")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error(`Invalid member name for IssuingDistributionPoint class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new be({value:[new R({name:i.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new Ee({name:i.distributionPointNames||"",value:nt.schema()})]}),new R({name:i.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:Xe.schema().valueBlock.value})]})]}),new D({name:i.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new D({name:i.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new D({name:i.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new D({name:i.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new D({name:i.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){w(e,["distributionPoint","distributionPointNames","onlyContainsUserCerts","onlyContainsCACerts","onlySomeReasons","indirectCRL","onlyContainsAttributeCerts"]);const t=Ie(e,e,ct.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new nt({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new Xe({schema:new x({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new R({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):((t=this.distributionPoint.toSchema()).idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new R({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==ct.defaultValues("onlyContainsUserCerts")&&e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==ct.defaultValues("onlyContainsCACerts")&&e.push(new D({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new D({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==ct.defaultValues("indirectCRL")&&e.push(new D({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==ct.defaultValues("onlyContainsAttributeCerts")&&e.push(new D({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new x({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(e.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,e=>e.toJSON()):this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==ct.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==ct.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==ct.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==ct.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class ht{constructor(e={}){this.names=t(e,"names",ht.defaultValues("names")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error(`Invalid member name for GeneralNames class: ${e}`)}}static schema(e={},i=!1){const r=t(e,"names",{});return new x({optional:i,name:r.blockName||"",value:[new Ee({name:r.generalNames||"",value:nt.schema()})]})}fromSchema(e){w(e,["names","generalNames"]);const t=Ie(e,e,ht.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new nt({schema:e}))}toSchema(){return new x({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class lt{constructor(e={}){this.base=t(e,"base",lt.defaultValues("base")),this.minimum=t(e,"minimum",lt.defaultValues("minimum")),"maximum"in e&&(this.maximum=t(e,"maximum",lt.defaultValues("maximum"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"base":return new nt;case"minimum":case"maximum":return 0;default:throw new Error(`Invalid member name for GeneralSubtree class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[nt.schema(i.base||{}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new j({name:i.minimum||""})]}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new j({name:i.maximum||""})]})]})}fromSchema(e){w(e,["base","minimum","maximum"]);const t=Ie(e,e,lt.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralSubtree");this.base=new nt({schema:t.result.base}),"minimum"in t.result&&(this.minimum=t.result.minimum.valueBlock.isHexOnly?t.result.minimum:t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(this.maximum=t.result.maximum.valueBlock.isHexOnly?t.result.maximum:t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof j?this.minimum:new j({value:this.minimum}),e.push(new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof j?this.maximum:new j({value:this.maximum}),e.push(new R({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new x({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&(e.minimum="number"==typeof this.minimum?this.minimum:this.minimum.toJSON()),"maximum"in this&&(e.maximum="number"==typeof this.maximum?this.maximum:this.maximum.toJSON()),e}}class ut{constructor(e={}){"permittedSubtrees"in e&&(this.permittedSubtrees=t(e,"permittedSubtrees",ut.defaultValues("permittedSubtrees"))),"excludedSubtrees"in e&&(this.excludedSubtrees=t(e,"excludedSubtrees",ut.defaultValues("excludedSubtrees"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error(`Invalid member name for NameConstraints class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ee({name:i.permittedSubtrees||"",value:lt.schema()})]}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Ee({name:i.excludedSubtrees||"",value:lt.schema()})]})]})}fromSchema(e){w(e,["permittedSubtrees","excludedSubtrees"]);const t=Ie(e,e,ut.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new lt({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new lt({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new R({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),"excludedSubtrees"in this&&e.push(new R({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class mt{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=t(e,"distributionPoint",mt.defaultValues("distributionPoint"))),"reasons"in e&&(this.reasons=t(e,"reasons",mt.defaultValues("reasons"))),"cRLIssuer"in e&&(this.cRLIssuer=t(e,"cRLIssuer",mt.defaultValues("cRLIssuer"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new V;case"cRLIssuer":return[];default:throw new Error(`Invalid member name for DistributionPoint class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new be({value:[new R({name:i.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ee({name:i.distributionPointNames||"",value:nt.schema()})]}),new R({name:i.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Xe.schema().valueBlock.value})]})]}),new D({name:i.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new R({name:i.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new Ee({name:i.cRLIssuerNames||"",value:nt.schema()})]})]})}fromSchema(e){w(e,["distributionPoint","distributionPointNames","reasons","cRLIssuer","cRLIssuerNames"]);const t=Ie(e,e,mt.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new nt({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new Xe({schema:new x({value:t.result.distributionPoint.valueBlock.value})}))),"reasons"in t.result&&(this.reasons=new V({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new nt({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=this.distributionPoint instanceof Array?new R({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new R({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new R({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new R({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(e.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,e=>e.toJSON()):this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class ft{constructor(e={}){this.distributionPoints=t(e,"distributionPoints",ft.defaultValues("distributionPoints")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error(`Invalid member name for CRLDistributionPoints class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.distributionPoints||"",value:mt.schema()})]})}fromSchema(e){w(e,["distributionPoints"]);const t=Ie(e,e,ft.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new mt({schema:e}))}toSchema(){return new x({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class dt{constructor(e={}){this.policyQualifierId=t(e,"policyQualifierId",dt.defaultValues("policyQualifierId")),this.qualifier=t(e,"qualifier",dt.defaultValues("qualifier")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new Pe;default:throw new Error(`Invalid member name for PolicyQualifierInfo class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.policyQualifierId||""}),new Pe({name:i.qualifier||""})]})}fromSchema(e){w(e,["policyQualifierId","qualifier"]);const t=Ie(e,e,dt.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new x({value:[new q({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class pt{constructor(e={}){this.policyIdentifier=t(e,"policyIdentifier",pt.defaultValues("policyIdentifier")),"policyQualifiers"in e&&(this.policyQualifiers=t(e,"policyQualifiers",pt.defaultValues("policyQualifiers"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error(`Invalid member name for PolicyInformation class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.policyIdentifier||""}),new x({optional:!0,value:[new Ee({name:i.policyQualifiers||"",value:dt.schema()})]})]})}fromSchema(e){w(e,["policyIdentifier","policyQualifiers"]);const t=Ie(e,e,pt.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new dt({schema:e})))}toSchema(){const e=[];return e.push(new q({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new x({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class At{constructor(e={}){this.certificatePolicies=t(e,"certificatePolicies",At.defaultValues("certificatePolicies")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error(`Invalid member name for CertificatePolicies class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.certificatePolicies||"",value:pt.schema()})]})}fromSchema(e){w(e,["certificatePolicies"]);const t=Ie(e,e,At.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new pt({schema:e}))}toSchema(){return new x({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class St{constructor(e={}){this.issuerDomainPolicy=t(e,"issuerDomainPolicy",St.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=t(e,"subjectDomainPolicy",St.defaultValues("subjectDomainPolicy")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error(`Invalid member name for PolicyMapping class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.issuerDomainPolicy||""}),new q({name:i.subjectDomainPolicy||""})]})}fromSchema(e){w(e,["issuerDomainPolicy","subjectDomainPolicy"]);const t=Ie(e,e,St.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new x({value:[new q({value:this.issuerDomainPolicy}),new q({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class yt{constructor(e={}){this.mappings=t(e,"mappings",yt.defaultValues("mappings")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error(`Invalid member name for PolicyMappings class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.mappings||"",value:St.schema()})]})}fromSchema(e){w(e,["mappings"]);const t=Ie(e,e,yt.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new St({schema:e}))}toSchema(){return new x({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class wt{constructor(e={}){"keyIdentifier"in e&&(this.keyIdentifier=t(e,"keyIdentifier",wt.defaultValues("keyIdentifier"))),"authorityCertIssuer"in e&&(this.authorityCertIssuer=t(e,"authorityCertIssuer",wt.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in e&&(this.authorityCertSerialNumber=t(e,"authorityCertSerialNumber",wt.defaultValues("authorityCertSerialNumber"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new _;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new j;default:throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new D({name:i.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Ee({name:i.authorityCertIssuer||"",value:nt.schema()})]}),new D({name:i.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){w(e,["keyIdentifier","authorityCertIssuer","authorityCertSerialNumber"]);const t=Ie(e,e,wt.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new _({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new nt({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new j({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return"keyIdentifier"in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in this&&e.push(new R({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this&&e.push(new D({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHex})),new x({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class Ct{constructor(e={}){"requireExplicitPolicy"in e&&(this.requireExplicitPolicy=t(e,"requireExplicitPolicy",Ct.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in e&&(this.inhibitPolicyMapping=t(e,"inhibitPolicyMapping",Ct.defaultValues("inhibitPolicyMapping"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error(`Invalid member name for PolicyConstraints class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new D({name:i.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new D({name:i.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){w(e,["requireExplicitPolicy","inhibitPolicyMapping"]);const t=Ie(e,e,Ct.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const i=Be(e.toBER(!1));this.requireExplicitPolicy=i.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const i=Be(e.toBER(!1));this.inhibitPolicyMapping=i.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new j({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new j({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new x({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class gt{constructor(e={}){this.keyPurposes=t(e,"keyPurposes",gt.defaultValues("keyPurposes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error(`Invalid member name for ExtKeyUsage class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.keyPurposes||"",value:new q})]})}fromSchema(e){w(e,["keyPurposes"]);const t=Ie(e,e,gt.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new x({value:Array.from(this.keyPurposes,e=>new q({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class bt{constructor(e={}){this.accessMethod=t(e,"accessMethod",bt.defaultValues("accessMethod")),this.accessLocation=t(e,"accessLocation",bt.defaultValues("accessLocation")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new nt;default:throw new Error(`Invalid member name for AccessDescription class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.accessMethod||""}),nt.schema(i.accessLocation||{})]})}fromSchema(e){w(e,["accessMethod","accessLocation"]);const t=Ie(e,e,bt.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new nt({schema:t.result.accessLocation})}toSchema(){return new x({value:[new q({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class Pt{constructor(e={}){this.accessDescriptions=t(e,"accessDescriptions",Pt.defaultValues("accessDescriptions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error(`Invalid member name for InfoAccess class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.accessDescriptions||"",value:bt.schema()})]})}fromSchema(e){w(e,["accessDescriptions"]);const t=Ie(e,e,Pt.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new bt({schema:e}))}toSchema(){return new x({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class Et{constructor(e={}){this.clear();for(const t of Object.keys(e))switch(t){case"length":this.length=e.length;break;case"stub":for(let t=0;t<this._view.length;t++)this._view[t]=e.stub;break;case"view":this.fromUint8Array(e.view);break;case"buffer":this.fromArrayBuffer(e.buffer);break;case"string":this.fromString(e.string);break;case"hexstring":this.fromHexString(e.hexstring)}}set buffer(e){this._buffer=e.slice(0),this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this._buffer.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this.buffer=e}fromUint8Array(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}fromString(e){const t=e.length;this.length=t;for(let i=0;i<t;i++)this.view[i]=e.charCodeAt(i)}toString(e=0,t=this.view.length-e){let i="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let r=e;r<e+t;r++)i+=String.fromCharCode(this.view[r]);return i}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const i=new Map;i.set("0",0),i.set("1",1),i.set("2",2),i.set("3",3),i.set("4",4),i.set("5",5),i.set("6",6),i.set("7",7),i.set("8",8),i.set("9",9),i.set("A",10),i.set("a",10),i.set("B",11),i.set("b",11),i.set("C",12),i.set("c",12),i.set("D",13),i.set("d",13),i.set("E",14),i.set("e",14),i.set("F",15),i.set("f",15);let r=0,s=0;for(let n=0;n<t;n++)n%2?(s|=i.get(e.charAt(n)),this.view[r]=s,r++):s=i.get(e.charAt(n))<<4}toHexString(e=0,t=this.view.length-e){let i="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let r=e;r<e+t;r++){const e=this.view[r].toString(16).toUpperCase();i=i+(1==e.length?"0":"")+e}return i}copy(e=0,t=this._buffer.byteLength-e){if(0===e&&0===this._buffer.byteLength)return new Et;if(e<0||e>this._buffer.byteLength-1)throw new Error(`Wrong start position: ${e}`);const i=new Et;return i._buffer=this._buffer.slice(e,e+t),i._view=new Uint8Array(i._buffer),i}slice(e=0,t=this._buffer.byteLength){if(0===e&&0===this._buffer.byteLength)return new Et;if(e<0||e>this._buffer.byteLength-1)throw new Error(`Wrong start position: ${e}`);const i=new Et;return i._buffer=this._buffer.slice(e,t),i._view=new Uint8Array(i._buffer),i}realloc(e){const t=new ArrayBuffer(e);new Uint8Array(t).set(e>this._view.length?this._view:new Uint8Array(this._buffer,0,e)),this._buffer=t.slice(0),this._view=new Uint8Array(this._buffer)}append(e){const t=this._buffer.byteLength,i=e._buffer.byteLength,r=e._view.slice();this.realloc(t+i),this._view.set(r,t)}insert(e,t=0,i=this._buffer.byteLength-t){return!(t>this._buffer.byteLength-1||(i>this._buffer.byteLength-t&&(i=this._buffer.byteLength-t),i>e._buffer.byteLength&&(i=e._buffer.byteLength),this._view.set(i==e._buffer.byteLength?e._view:e._view.slice(0,i),t),0))}isEqual(e){if(this._buffer.byteLength!=e._buffer.byteLength)return!1;for(let t=0;t<e._buffer.byteLength;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t=null,i=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==i&&(i=t),i>t&&(i=t)):(null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t));const s=e.buffer.byteLength;if(s>i)return-1;const n=[];for(let a=0;a<s;a++)n.push(e.view[a]);for(let a=0;a<=i-s;a++){let e=!0;const i=r?t-s-a:t+a;for(let t=0;t<s;t++)if(this.view[t+i]!=n[t]){e=!1;break}if(e)return r?t-s-a:t+s+a}return-1}findFirstIn(e,t=null,i=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==i&&(i=t),i>t&&(i=t)):(null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t));const s={id:-1,position:r?0:t+i,length:0};for(let n=0;n<e.length;n++){const a=this.findPattern(e[n],t,i,r);if(-1!=a){let t=!1;const i=e[n].length;r?a-i>=s.position-s.length&&(t=!0):a-i<=s.position-s.length&&(t=!0),t&&(s.position=a,s.id=n,s.length=i)}}return s}findAllIn(e,t=0,i=this.buffer.byteLength-t){const r=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return r;null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t);let s={id:-1,position:t};for(;;){const t=s.position;if(-1==(s=this.findFirstIn(e,s.position,i)).id)break;i-=s.position-t,r.push({id:s.id,position:s.position})}return r}findAllPatternIn(e,t=0,i=this.buffer.byteLength-t){null==t&&(t=0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t);const r=[],s=e.buffer.byteLength;if(s>i)return-1;const n=Array.from(e.view);for(let a=0;a<=i-s;a++){let e=!0;const i=t+a;for(let t=0;t<s;t++)if(this.view[t+i]!=n[t]){e=!1;break}e&&(r.push(t+s+a),a+=s-1)}return r}findFirstNotIn(e,t=null,i=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==i&&(i=t),i>t&&(i=t)):(null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t));const s={left:{id:-1,position:t},right:{id:-1,position:0},value:new Et};let n=i;for(;n>0;){if(s.right=this.findFirstIn(e,r?t-i+n:t+i-n,n,r),-1==s.right.id){i=n,r?t-=i:t=s.left.position,s.value=new Et,s.value._buffer=this._buffer.slice(t,t+i),s.value._view=new Uint8Array(s.value._buffer);break}if(s.right.position!=(r?s.left.position-e[s.right.id].buffer.byteLength:s.left.position+e[s.right.id].buffer.byteLength)){r?(t=s.right.position+e[s.right.id].buffer.byteLength,i=s.left.position-s.right.position-e[s.right.id].buffer.byteLength):(t=s.left.position,i=s.right.position-s.left.position-e[s.right.id].buffer.byteLength),s.value=new Et,s.value._buffer=this._buffer.slice(t,t+i),s.value._view=new Uint8Array(s.value._buffer);break}s.left=s.right,n-=e[s.right.id]._buffer.byteLength}if(r){const e=s.right;s.right=s.left,s.left=e}return s}findAllNotIn(e,t=null,i=null){const r=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return r;null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t);let s={left:{id:-1,position:t},right:{id:-1,position:t},value:new Et};do{const t=s.right.position;i-=(s=this.findFirstNotIn(e,s.right.position,i)).right.position-t,r.push({left:{id:s.left.id,position:s.left.position},right:{id:s.right.id,position:s.right.position},value:s.value})}while(-1!=s.right.id);return r}findFirstSequence(e,t=null,i=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==i&&(i=t),i>t&&(i=t)):(null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t));const s=this.skipNotPatterns(e,t,i,r);if(-1==s)return{position:-1,value:new Et};const n=this.skipPatterns(e,s,i-(r?t-s:s-t),r);r?(t=n,i=s-n):(t=s,i=n-s);const a=new Et;return a._buffer=this._buffer.slice(t,t+i),a._view=new Uint8Array(a._buffer),{position:n,value:a}}findAllSequences(e,t=null,i=null){const r=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return r;null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t);let s={position:t,value:new Et};do{const t=s.position;-1!=(s=this.findFirstSequence(e,s.position,i)).position&&(i-=s.position-t,r.push({position:s.position,value:s.value}))}while(-1!=s.position);return r}findPairedPatterns(e,t,i=null,r=null){const s=[];if(e.isEqual(t))return s;if(null==i&&(i=0),i>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-i),r>this.buffer.byteLength-i&&(r=this.buffer.byteLength-i);let n=0;const a=this.findAllPatternIn(e,i,r);if(0==a.length)return s;const o=this.findAllPatternIn(t,i,r);if(0==o.length)return s;for(;n<a.length&&0!=o.length;)if(a[0]!=o[0]){if(a[n]>o[0])break;for(;a[n]<o[0]&&!(++n>=a.length););s.push({left:a[n-1],right:o[0]}),a.splice(n-1,1),o.splice(0,1),n=0}else s.push({left:a[0],right:o[0]}),a.splice(0,1),o.splice(0,1);return s.sort((e,t)=>e.left-t.left),s}findPairedArrays(e,t,i=null,r=null){const s=[];if(null==i&&(i=0),i>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-i),r>this.buffer.byteLength-i&&(r=this.buffer.byteLength-i);let n=0;const a=this.findAllIn(e,i,r);if(0==a.length)return s;const o=this.findAllIn(t,i,r);if(0==o.length)return s;for(;n<a.length&&0!=o.length;)if(a[0].position!=o[0].position){if(a[n].position>o[0].position)break;for(;a[n].position<o[0].position&&!(++n>=a.length););s.push({left:a[n-1],right:o[0]}),a.splice(n-1,1),o.splice(0,1),n=0}else s.push({left:a[0],right:o[0]}),a.splice(0,1),o.splice(0,1);return s.sort((e,t)=>e.left.position-t.left.position),s}replacePattern(e,t,i=null,r=null,s=null){let n,a;const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]};if(null==i&&(i=0),i>this.buffer.byteLength-1)return!1;if(null==r&&(r=this.buffer.byteLength-i),r>this.buffer.byteLength-i&&(r=this.buffer.byteLength-i),null==s){if(0==(n=this.findAllIn([e],i,r)).length)return o}else n=s;o.searchPatternPositions.push(...Array.from(n,e=>e.position));const c=e.buffer.byteLength-t.buffer.byteLength,h=new ArrayBuffer(this.view.length-n.length*c),l=new Uint8Array(h);for(l.set(new Uint8Array(this.buffer,0,i)),a=0;a<n.length;a++){const r=0==a?i:n[a-1].position;l.set(new Uint8Array(this.buffer,r,n[a].position-e.buffer.byteLength-r),r-a*c),l.set(t.view,n[a].position-e.buffer.byteLength-a*c),o.replacePatternPositions.push(n[a].position-e.buffer.byteLength-a*c)}return a--,l.set(new Uint8Array(this.buffer,n[a].position,this.buffer.byteLength-n[a].position),n[a].position-e.buffer.byteLength+t.buffer.byteLength-a*c),this.buffer=h,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t=null,i=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==i&&(i=t),i>t&&(i=t)):(null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t));let s=t;for(let n=0;n<e.length;n++){const a=e[n].buffer.byteLength,o=r?s-a:s;let c=!0;for(let t=0;t<a;t++)if(this.view[t+o]!=e[n].view[t]){c=!1;break}if(c)if(n=-1,r){if((s-=a)<=0)return s}else if((s+=a)>=t+i)return s}return s}skipNotPatterns(e,t=null,i=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==i&&(i=t),i>t&&(i=t)):(null==i&&(i=this.buffer.byteLength-t),i>this.buffer.byteLength-t&&(i=this.buffer.byteLength-t));let s=-1;for(let n=0;n<i;n++){for(let i=0;i<e.length;i++){const a=e[i].buffer.byteLength,o=r?t-n-a:t+n;let c=!0;for(let t=0;t<a;t++)if(this.view[t+o]!=e[i].view[t]){c=!1;break}if(c){s=r?t-n:t+n;break}}if(-1!=s)break}return s}}class vt{constructor(e={}){this.stream=new Et,this._length=0,this.backward=!1,this._start=0,this.appendBlock=0,this.prevLength=0,this.prevStart=0;for(const t of Object.keys(e))switch(t){case"stream":this.stream=e.stream;break;case"backward":this.backward=e.backward,this._start=this.stream.buffer.byteLength;break;case"length":this._length=e.length;break;case"start":this._start=e.start;break;case"appendBlock":this.appendBlock=e.appendBlock;break;case"view":this.stream=new Et({view:e.view});break;case"buffer":this.stream=new Et({buffer:e.buffer});break;case"string":this.stream=new Et({string:e.string});break;case"hexstring":this.stream=new Et({hexstring:e.hexstring})}}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e._buffer.byteLength,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.buffer.byteLength||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream._buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const i=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==i)return i;if(this.backward){if(i<this.start-e.buffer.byteLength-t)return-1}else if(i>this.start+e.buffer.byteLength+t)return-1;return this.start=i,i}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const i=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==i.id)return i;if(this.backward){if(i.position<this.start-e[i.id].buffer.byteLength-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(i.position>this.start+e[i.id].buffer.byteLength+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=i.position,i}findAllIn(e){return this.stream.findAllIn(e,this.backward?this.start-this.length:this.start,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const i=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==i.left.id&&-1==i.right.id)return i;if(this.backward){if(-1!=i.right.id&&i.right.position<this._start-e[i.right.id]._buffer.byteLength-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Et}}else if(-1!=i.left.id&&i.left.position>this._start+e[i.left.id]._buffer.byteLength+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Et};return this.start=this.backward?-1==i.left.id?0:i.left.position:-1==i.right.id?this._start+this._length:i.right.position,i}findAllNotIn(e){return this._stream.findAllNotIn(e,this.backward?this._start-this._length:this._start,this._length)}findFirstSequence(e,t=null,i=null){(null==t||t>this._length)&&(t=this._length),(null==i||i>t)&&(i=t);const r=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==r.value.buffer.byteLength)return r;if(this.backward){if(r.position<this._start-r.value._buffer.byteLength-i)return{position:-1,value:new Et}}else if(r.position>this._start+r.value._buffer.byteLength+i)return{position:-1,value:new Et};return this.start=r.position,r}findAllSequences(e){return this.stream.findAllSequences(e,this.backward?this.start-this.length:this.start,this.length)}findPairedPatterns(e,t,i=null){(null==i||i>this.length)&&(i=this.length);const r=this.stream.findPairedPatterns(e,t,this.backward?this.start-this.length:this.start,this.length);if(r.length)if(this.backward){if(r[0].right<this.start-t.buffer.byteLength-i)return[]}else if(r[0].left>this.start+e.buffer.byteLength+i)return[];return r}findPairedArrays(e,t,i=null){(null==i||i>this.length)&&(i=this.length);const r=this.stream.findPairedArrays(e,t,this.backward?this.start-this.length:this.start,this.length);if(r.length)if(this.backward){if(r[0].right.position<this.start-t[r[0].right.id].buffer.byteLength-i)return[]}else if(r[0].left.position>this.start+e[r[0].left.id].buffer.byteLength+i)return[];return r}replacePattern(e,t){return this.stream.replacePattern(e,t,this.backward?this.start-this.length:this.start,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this._start+e._buffer.byteLength>this._stream._buffer.byteLength&&(e._buffer.byteLength>this.appendBlock&&(this.appendBlock=e._buffer.byteLength+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e._view,this._start),this._length+=2*e._buffer.byteLength,this.start=this._start+e._buffer.byteLength,this.prevLength-=2*e._buffer.byteLength}appendView(e){this._start+e.length>this._stream._buffer.byteLength&&(e.length>this.appendBlock&&(this.appendBlock=e.length+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this._start+1>this._stream._buffer.byteLength&&(1>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this._start+2>this._stream._buffer.byteLength&&(2>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint16Array([e]),i=new Uint8Array(t.buffer);this._stream._view[this._start]=i[1],this._stream._view[this._start+1]=i[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this._start+3>this._stream._buffer.byteLength&&(3>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),i=new Uint8Array(t.buffer);this._stream._view[this._start]=i[2],this._stream._view[this._start+1]=i[1],this._stream._view[this._start+2]=i[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this._start+4>this._stream._buffer.byteLength&&(4>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),i=new Uint8Array(t.buffer);this._stream._view[this._start]=i[3],this._stream._view[this._start+1]=i[2],this._stream._view[this._start+2]=i[1],this._stream._view[this._start+3]=i[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return[];let i;if(this._length<e&&(e=this._length),this.backward){const t=this._stream._buffer.slice(this._length-e,this._length),r=new Uint8Array(t);i=new Array(e);for(let s=0;s<e;s++)i[e-1-s]=r[s]}else{const t=this._stream._buffer.slice(this._start,this._start+e);i=Array.from(new Uint8Array(t))}return t&&(this.start+=this.backward?-1*e:e),i}getUint16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const i=new Uint16Array(1),r=new Uint8Array(i.buffer);return r[0]=t[1],r[1]=t[0],i[0]}getInt16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const i=new Int16Array(1),r=new Uint8Array(i.buffer);return r[0]=t[1],r[1]=t[0],i[0]}getUint24(e=!0){const t=this.getBlock(3,e);if(t.length<3)return 0;const i=new Uint32Array(1),r=new Uint8Array(i.buffer);for(let s=3;s>=1;s--)r[3-s]=t[s-1];return i[0]}getUint32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const i=new Uint32Array(1),r=new Uint8Array(i.buffer);for(let s=3;s>=0;s--)r[3-s]=t[s];return i[0]}getInt32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const i=new Int32Array(1),r=new Uint8Array(i.buffer);for(let s=3;s>=0;s--)r[3-s]=t[s];return i[0]}}class kt{constructor(e={}){this.version=t(e,"version",kt.defaultValues("version")),this.logID=t(e,"logID",kt.defaultValues("logID")),this.timestamp=t(e,"timestamp",kt.defaultValues("timestamp")),this.extensions=t(e,"extensions",kt.defaultValues("extensions")),this.hashAlgorithm=t(e,"hashAlgorithm",kt.defaultValues("hashAlgorithm")),this.signatureAlgorithm=t(e,"signatureAlgorithm",kt.defaultValues("signatureAlgorithm")),this.signature=t(e,"signature",kt.defaultValues("signature")),"schema"in e&&this.fromSchema(e.schema),"stream"in e&&this.fromStream(e.stream)}static defaultValues(e){switch(e){case"version":return 0;case"logID":case"extensions":return new ArrayBuffer(0);case"timestamp":return new Date(0);case"hashAlgorithm":case"signatureAlgorithm":return"";case"signature":return new Pe;default:throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${e}`)}}fromSchema(e){if(e instanceof ve==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new vt({stream:new Et({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(s(new Uint8Array(e.getBlock(8)),8));const i=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(i)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm="none";break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm="sha1";break;case 3:this.hashAlgorithm="sha224";break;case 4:this.hashAlgorithm="sha256";break;case 5:this.hashAlgorithm="sha384";break;case 6:this.hashAlgorithm="sha512";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm="anonymous";break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm="ecdsa";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const r=e.getUint16(),n=Be(new Uint8Array(e.getBlock(r)).buffer.slice(0));if(-1===n.offset)throw new Error("Object's stream was not correct for SignedCertificateTimestamp");if(this.signature=n.result,t!==47+i+r)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new ve({data:e.stream.buffer})}toStream(){const e=new vt;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecode.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),i=new Uint8Array(t),r=n(this.timestamp.valueOf(),8);let s,a;switch(i.set(new Uint8Array(r),8-r.byteLength),e.appendView(i),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case"none":s=0;break;case"md5":s=1;break;case"sha1":s=2;break;case"sha224":s=3;break;case"sha256":s=4;break;case"sha384":s=5;break;case"sha512":s=6;break;default:throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(e.appendChar(s),this.signatureAlgorithm.toLowerCase()){case"anonymous":a=0;break;case"rsa":a=1;break;case"dsa":a=2;break;case"ecdsa":a=3;break;default:throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}e.appendChar(a);const o=this.signature.toBER(!1);return e.appendUint16(o.byteLength),e.appendView(new Uint8Array(o)),e}toJSON(){return{version:this.version,logID:i(this.logID),timestamp:this.timestamp,extensions:i(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,i=0){let r,s=f(p(this.logID)),a=null,o=new vt;for(const n of e)if(n.log_id===s){a=n.key;break}if(null===a)throw new Error(`Public key not found for CT with logId: ${s}`);const c=Be(A(d(a)));if(-1===c.offset)throw new Error(`Incorrect key value for CT Log with logId: ${s}`);r=new Ue({schema:c.result}),o.appendChar(0),o.appendChar(0);const h=new ArrayBuffer(8),l=new Uint8Array(h),u=n(this.timestamp.valueOf(),8);return l.set(new Uint8Array(u),8-u.byteLength),o.appendView(l),o.appendUint16(i),0===i&&o.appendUint24(t.byteLength),o.appendView(new Uint8Array(t)),o.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&o.appendView(new Uint8Array(this.extensions)),qe().subtle.verifyWithPublicKey(o._stream._buffer.slice(0,o._length),{valueBlock:{valueHex:this.signature.toBER(!1)}},r,{algorithmId:""},"SHA-256")}}class Bt{constructor(e={}){this.timestamps=t(e,"timestamps",Bt.defaultValues("timestamps")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"timestamps":return[];default:throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"timestamps":return 0===t.length;default:throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return"optional"in i==0&&(i.optional=!1),new _({name:i.blockName||"SignedCertificateTimestampList",optional:i.optional})}fromSchema(e){if(e instanceof _==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new vt({stream:new Et({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new kt({stream:t}))}toSchema(){const e=new vt;let t=0;const i=[];for(const r of this.timestamps){const e=r.toStream();i.push(e),t+=e.stream.buffer.byteLength}e.appendUint16(t);for(const r of i)e.appendView(r.stream.view);return new _({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}class It{constructor(e={}){this.templateID=t(e,"templateID",It.defaultValues("templateID")),"templateMajorVersion"in e&&(this.templateMajorVersion=t(e,"templateMajorVersion",It.defaultValues("templateMajorVersion"))),"templateMinorVersion"in e&&(this.templateMinorVersion=t(e,"templateMinorVersion",It.defaultValues("templateMinorVersion"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"templateID":return"";case"templateMajorVersion":case"templateMinorVersion":return 0;default:throw new Error(`Invalid member name for CertificateTemplate class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.templateID||""}),new j({name:i.templateMajorVersion||"",optional:!0}),new j({name:i.templateMinorVersion||"",optional:!0})]})}fromSchema(e){w(e,["templateID","templateMajorVersion","templateMinorVersion"]);let t=Ie(e,e,It.schema({names:{templateID:"templateID",templateMajorVersion:"templateMajorVersion",templateMinorVersion:"templateMinorVersion"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificateTemplate");this.templateID=t.result.templateID.valueBlock.toString(),"templateMajorVersion"in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),"templateMinorVersion"in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new q({value:this.templateID})),"templateMajorVersion"in this&&e.push(new j({value:this.templateMajorVersion})),"templateMinorVersion"in this&&e.push(new j({value:this.templateMinorVersion})),new x({value:e})}toJSON(){const e={extnID:this.templateID};return"templateMajorVersion"in this&&(e.templateMajorVersion=this.templateMajorVersion),"templateMinorVersion"in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}class Dt{constructor(e={}){this.certificateIndex=t(e,"certificateIndex",Dt.defaultValues("certificateIndex")),this.keyIndex=t(e,"keyIndex",Dt.defaultValues("keyIndex")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificateIndex":case"keyIndex":return 0;default:throw new Error(`Invalid member name for CAVersion class: ${e}`)}}static schema(e={}){return new j}fromSchema(e){if(e.constructor.blockName()!==j.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const i=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(i,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(i.slice(0,4)),t=e.slice(0)}}const r=t.slice(0,2),s=new Uint8Array(r);let n=s[0];s[0]=s[1],s[1]=n;const a=new Uint16Array(r);this.keyIndex=a[0];const o=t.slice(2),c=new Uint8Array(o);n=c[0],c[0]=c[1],c[1]=n;const h=new Uint16Array(o);this.certificateIndex=h[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let i=t[0];t[0]=t[1],t[1]=i;const r=new ArrayBuffer(2);new Uint16Array(r)[0]=this.keyIndex;const s=new Uint8Array(r);return i=s[0],s[0]=s[1],s[1]=i,new j({valueHex:a(r,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}class Nt{constructor(e={}){this.id=t(e,"id",Nt.defaultValues("id")),"type"in e&&(this.type=t(e,"type",Nt.defaultValues("type"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"id":return"";case"type":return new O;default:throw new Error(`Invalid member name for QCStatement class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"id":return""===t;case"type":return t instanceof O;default:throw new Error(`Invalid member name for QCStatement class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.id||""}),new Pe({name:i.type||"",optional:!0})]})}fromSchema(e){w(e,["id","type"]);const t=Ie(e,e,Nt.schema({names:{id:"id",type:"type"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatement");this.id=t.result.id.valueBlock.toString(),"type"in t.result&&(this.type=t.result.type)}toSchema(){const e=[new q({value:this.id})];return"type"in this&&e.push(this.type),new x({value:e})}toJSON(){const e={id:this.id};return"type"in this&&(e.type=this.type.toJSON()),e}}class Rt{constructor(e={}){this.values=t(e,"values",Rt.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"values":return[];default:throw new Error(`Invalid member name for QCStatements class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"values":return 0===t.length;default:throw new Error(`Invalid member name for QCStatements class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new Ee({name:i.values||"",value:Nt.schema(i.value||{})})]})}fromSchema(e){w(e,["values"]);const t=Ie(e,e,Rt.schema({names:{values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatements");this.values=Array.from(t.result.values,e=>new Nt({schema:e}))}toSchema(){return new x({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.values,e=>e.toJSON())}}}class Tt{constructor(e={}){this.extnID=t(e,"extnID",Tt.defaultValues("extnID")),this.critical=t(e,"critical",Tt.defaultValues("critical")),this.extnValue="extnValue"in e?new _({valueHex:e.extnValue}):Tt.defaultValues("extnValue"),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",Tt.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new _;case"parsedValue":return{};default:throw new Error(`Invalid member name for Extension class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[new q({name:i.extnID||""}),new U({name:i.critical||"",optional:!0}),new _({name:i.extnValue||""})]})}fromSchema(e){w(e,["extnID","critical","extnValue"]);let t=Ie(e,e,Tt.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extension");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,-1!==(t=Be(this.extnValue.valueBlock.valueHex)).offset)switch(this.extnID){case"2.5.29.9":try{this.parsedValue=new et({schema:t.result})}catch(i){this.parsedValue=new et,this.parsedValue.parsingError="Incorrectly formated SubjectDirectoryAttributes"}break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":try{this.parsedValue=new tt({schema:t.result})}catch(i){this.parsedValue=new tt,this.parsedValue.parsingError="Incorrectly formated PrivateKeyUsagePeriod"}break;case"2.5.29.17":case"2.5.29.18":try{this.parsedValue=new at({schema:t.result})}catch(i){this.parsedValue=new at,this.parsedValue.parsingError="Incorrectly formated AltName"}break;case"2.5.29.19":try{this.parsedValue=new ot({schema:t.result})}catch(i){this.parsedValue=new ot,this.parsedValue.parsingError="Incorrectly formated BasicConstraints"}break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":try{this.parsedValue=new ct({schema:t.result})}catch(i){this.parsedValue=new ct,this.parsedValue.parsingError="Incorrectly formated IssuingDistributionPoint"}break;case"2.5.29.29":try{this.parsedValue=new ht({schema:t.result})}catch(i){this.parsedValue=new ht,this.parsedValue.parsingError="Incorrectly formated GeneralNames"}break;case"2.5.29.30":try{this.parsedValue=new ut({schema:t.result})}catch(i){this.parsedValue=new ut,this.parsedValue.parsingError="Incorrectly formated NameConstraints"}break;case"2.5.29.31":case"2.5.29.46":try{this.parsedValue=new ft({schema:t.result})}catch(i){this.parsedValue=new ft,this.parsedValue.parsingError="Incorrectly formated CRLDistributionPoints"}break;case"2.5.29.32":case"1.3.6.1.4.1.311.21.10":try{this.parsedValue=new At({schema:t.result})}catch(i){this.parsedValue=new At,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.33":try{this.parsedValue=new yt({schema:t.result})}catch(i){this.parsedValue=new yt,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.35":try{this.parsedValue=new wt({schema:t.result})}catch(i){this.parsedValue=new wt,this.parsedValue.parsingError="Incorrectly formated AuthorityKeyIdentifier"}break;case"2.5.29.36":try{this.parsedValue=new Ct({schema:t.result})}catch(i){this.parsedValue=new Ct,this.parsedValue.parsingError="Incorrectly formated PolicyConstraints"}break;case"2.5.29.37":try{this.parsedValue=new gt({schema:t.result})}catch(i){this.parsedValue=new gt,this.parsedValue.parsingError="Incorrectly formated ExtKeyUsage"}break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":try{this.parsedValue=new Pt({schema:t.result})}catch(i){this.parsedValue=new Pt,this.parsedValue.parsingError="Incorrectly formated InfoAccess"}break;case"1.3.6.1.4.1.11129.2.4.2":try{this.parsedValue=new Bt({schema:t.result})}catch(i){this.parsedValue=new Bt,this.parsedValue.parsingError="Incorrectly formated SignedCertificateTimestampList"}break;case"1.3.6.1.4.1.311.20.2":case"1.3.6.1.4.1.311.21.2":this.parsedValue=t.result;break;case"1.3.6.1.4.1.311.21.7":try{this.parsedValue=new It({schema:t.result})}catch(i){this.parsedValue=new It,this.parsedValue.parsingError="Incorrectly formated CertificateTemplate"}break;case"1.3.6.1.4.1.311.21.1":try{this.parsedValue=new Dt({schema:t.result})}catch(i){this.parsedValue=new Dt,this.parsedValue.parsingError="Incorrectly formated CAVersion"}break;case"1.3.6.1.5.5.7.1.3":try{this.parsedValue=new Rt({schema:t.result})}catch(i){this.parsedValue=new Rt,this.parsedValue.parsingError="Incorrectly formated QCStatements"}}}toSchema(){const e=[];return e.push(new q({value:this.extnID})),this.critical!==Tt.defaultValues("critical")&&e.push(new U({value:this.critical})),e.push(this.extnValue),new x({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Tt.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&"toJSON"in this.parsedValue&&(e.parsedValue=this.parsedValue.toJSON()),e}}class Kt{constructor(e={}){this.extensions=t(e,"extensions",Kt.defaultValues("extensions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error(`Invalid member name for Extensions class: ${e}`)}}static schema(e={},i=!1){const r=t(e,"names",{});return new x({optional:i,name:r.blockName||"",value:[new Ee({name:r.extensions||"",value:Tt.schema(r.extension||{})})]})}fromSchema(e){w(e,["extensions"]);const t=Ie(e,e,Kt.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extensions");this.extensions=Array.from(t.result.extensions,e=>new Tt({schema:e}))}toSchema(){return new x({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}function Ht(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"tbsCertificate",value:[new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new j({name:i.tbsCertificateVersion||"tbsCertificate.version"})]}),new j({name:i.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),Te.schema(i.signature||{names:{blockName:"tbsCertificate.signature"}}),Xe.schema(i.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new x({name:i.tbsCertificateValidity||"tbsCertificate.validity",value:[Ye.schema(i.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),Ye.schema(i.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),Xe.schema(i.subject||{names:{blockName:"tbsCertificate.subject"}}),Ue.schema(i.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new D({name:i.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new D({name:i.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new R({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Kt.schema(i.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}class Ut{constructor(e={}){this.tbs=t(e,"tbs",Ut.defaultValues("tbs")),this.version=t(e,"version",Ut.defaultValues("version")),this.serialNumber=t(e,"serialNumber",Ut.defaultValues("serialNumber")),this.signature=t(e,"signature",Ut.defaultValues("signature")),this.issuer=t(e,"issuer",Ut.defaultValues("issuer")),this.notBefore=t(e,"notBefore",Ut.defaultValues("notBefore")),this.notAfter=t(e,"notAfter",Ut.defaultValues("notAfter")),this.subject=t(e,"subject",Ut.defaultValues("subject")),this.subjectPublicKeyInfo=t(e,"subjectPublicKeyInfo",Ut.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in e&&(this.issuerUniqueID=t(e,"issuerUniqueID",Ut.defaultValues("issuerUniqueID"))),"subjectUniqueID"in e&&(this.subjectUniqueID=t(e,"subjectUniqueID",Ut.defaultValues("subjectUniqueID"))),"extensions"in e&&(this.extensions=t(e,"extensions",Ut.defaultValues("extensions"))),this.signatureAlgorithm=t(e,"signatureAlgorithm",Ut.defaultValues("signatureAlgorithm")),this.signatureValue=t(e,"signatureValue",Ut.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new j;case"signature":return new Te;case"issuer":return new Xe;case"notBefore":case"notAfter":return new Ye;case"subject":return new Xe;case"subjectPublicKeyInfo":return new Ue;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new Te;case"signatureValue":return new V;default:throw new Error(`Invalid member name for Certificate class: ${e}`)}}static schema(e={}){const i=t(e,"names",{});return new x({name:i.blockName||"",value:[Ht(i.tbsCertificate),Te.schema(i.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new V({name:i.signatureValue||"signatureValue"})]})}fromSchema(e){w(e,["tbsCertificate","tbsCertificate.extensions","tbsCertificate.version","tbsCertificate.serialNumber","tbsCertificate.signature","tbsCertificate.issuer","tbsCertificate.notBefore","tbsCertificate.notAfter","tbsCertificate.subject","tbsCertificate.subjectPublicKeyInfo","tbsCertificate.issuerUniqueID","tbsCertificate.subjectUniqueID","signatureAlgorithm","signatureValue"]);const t=Ie(e,e,Ut.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Certificate");this.tbs=t.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in t.result&&(this.version=t.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=t.result["tbsCertificate.serialNumber"],this.signature=new Te({schema:t.result["tbsCertificate.signature"]}),this.issuer=new Xe({schema:t.result["tbsCertificate.issuer"]}),this.notBefore=new Ye({schema:t.result["tbsCertificate.notBefore"]}),this.notAfter=new Ye({schema:t.result["tbsCertificate.notAfter"]}),this.subject=new Xe({schema:t.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new Ue({schema:t.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in t.result&&(this.subjectUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in t.result&&(this.extensions=Array.from(t.result["tbsCertificate.extensions"],e=>new Tt({schema:e}))),this.signatureAlgorithm=new Te({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return"version"in this&&this.version!==Ut.defaultValues("version")&&e.push(new R({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new j({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new x({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&e.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&e.push(new D({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"extensions"in this&&e.push(new R({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new x({value:Array.from(this.extensions,e=>e.toSchema())})]})),new x({value:e})}toSchema(e=!1){let t={};if(!1===e){if(0===this.tbs.length)return Ut.schema().value[0];t=Be(this.tbs).result}else t=this.encodeTBS();return new x({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:i(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==Ut.defaultValues("version")&&(e.version=this.version),"issuerUniqueID"in this&&(e.issuerUniqueID=i(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(e.subjectUniqueID=i(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}getPublicKey(e=null){return qe().subtle.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}getKeyHash(e="SHA-1"){const t=Je();return void 0===t?Promise.reject("Unable to create WebCrypto object"):t.digest({name:e},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let i,r=Promise.resolve();const s=qe();return(r=(r=(r=(r=r.then(()=>s.subtle.getSignatureParameters(e,t))).then(e=>{i=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>s.subtle.signWithPrivateKey(this.tbs,e,i))).then(e=>{this.signatureValue=new V({valueHex:e})})}verify(e=null){let t={};return null!==e?t=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(t=this.subjectPublicKeyInfo),t instanceof Ue==0?Promise.reject("Please provide issuer certificate as a parameter"):qe().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,t,this.signatureAlgorithm)}}function xt(e,t,i,r,s){const n=`${i}.${r}`;let a="";if("string"!=typeof e){const i=new Blob([e],{type:t});if(navigator.msSaveBlob)return navigator.msSaveBlob(i,n),new Promise(e=>setTimeout(e,s||0));a=window.URL.createObjectURL(i)}else a=`data:${t};charset=utf-8,${encodeURIComponent(e)}`;const o=document.createElement("a");return o.style.display="none",o.href=a,o.download=n,document.body.appendChild(o),o.dispatchEvent(new MouseEvent("click")),document.body.removeChild(o),new Promise(e=>setTimeout(()=>(e=>{/^blob:/.test(a)&&window.URL.revokeObjectURL(a),e()})(e),s||0))}const Mt={"0.2.262.1.10":"Telesec","0.2.262.1.10.0":"Extension","0.2.262.1.10.1":"Mechanism","0.2.262.1.10.1.0":"Authentication","0.2.262.1.10.1.0.1":"Password Authentication","0.2.262.1.10.1.0.2":"Protected Password Authentication","0.2.262.1.10.1.0.3":"One Way x509 Authentication","0.2.262.1.10.1.0.4":"Two Way x509 Authentication","0.2.262.1.10.1.0.5":"Three Way x509 Authentication","0.2.262.1.10.1.0.6":"One Way IS O9798 Authentication","0.2.262.1.10.1.0.7":"Two Way IS O9798 Authentication","0.2.262.1.10.1.0.8":"Telekom Authentication","0.2.262.1.10.1.1":"Signature","0.2.262.1.10.1.1.1":"MD4 With RSA And IS O9697","0.2.262.1.10.1.1.2":"MD4 With RSA And Telesec Signature Standard","0.2.262.1.10.1.1.3":"MD5 With RSA And IS O9697","0.2.262.1.10.1.1.4":"MD5 With RSA And Telesec Signature Standard","0.2.262.1.10.1.1.5":"Ripemd160 With RSA And Telekom Signature Standard","0.2.262.1.10.1.1.9":"HBCI RSA Signature","0.2.262.1.10.1.2":"Encryption","0.2.262.1.10.1.2.0":"None","0.2.262.1.10.1.2.1":"RSA Telesec","0.2.262.1.10.1.2.2":"DES","0.2.262.1.10.1.2.2.1":"DES ECB","0.2.262.1.10.1.2.2.2":"DES CBC","0.2.262.1.10.1.2.2.3":"DES OFB","0.2.262.1.10.1.2.2.4":"DES CFB8","0.2.262.1.10.1.2.2.5":"DES CFB64","0.2.262.1.10.1.2.3":"DES3","0.2.262.1.10.1.2.3.1":"DES3 ECB","0.2.262.1.10.1.2.3.2":"DES3 CBC","0.2.262.1.10.1.2.3.3":"DES3 OFB","0.2.262.1.10.1.2.3.4":"DES3 CFB8","0.2.262.1.10.1.2.3.5":"DES3 CFB64","0.2.262.1.10.1.2.4":"Magenta","0.2.262.1.10.1.2.5":"Idea","0.2.262.1.10.1.2.5.1":"Idea ECB","0.2.262.1.10.1.2.5.2":"Idea CBC","0.2.262.1.10.1.2.5.3":"Idea OFB","0.2.262.1.10.1.2.5.4":"Idea CFB8","0.2.262.1.10.1.2.5.5":"Idea CFB64","0.2.262.1.10.1.3":"One Way Function","0.2.262.1.10.1.3.1":"MD4","0.2.262.1.10.1.3.2":"MD5","0.2.262.1.10.1.3.3":"SQ ModNx509","0.2.262.1.10.1.3.4":"SQ ModNISO","0.2.262.1.10.1.3.5":"Ripemd128","0.2.262.1.10.1.3.6":"Hash Using Block Cipher","0.2.262.1.10.1.3.7":"Mac","0.2.262.1.10.1.3.8":"Ripemd160","0.2.262.1.10.1.4":"Fec Function","0.2.262.1.10.1.4.1":"Reed Solomon","0.2.262.1.10.2":"Module","0.2.262.1.10.2.0":"Algorithms","0.2.262.1.10.2.1":"Attribute Types","0.2.262.1.10.2.2":"Certificate Types","0.2.262.1.10.2.3":"Message Types","0.2.262.1.10.2.4":"Pl Protocol","0.2.262.1.10.2.5":"Sme And Components Of Sme","0.2.262.1.10.2.6":"Fec","0.2.262.1.10.2.7":"Useful Definitions","0.2.262.1.10.2.8":"Stefiles","0.2.262.1.10.2.9":"Sadmib","0.2.262.1.10.2.10":"Electronic Order","0.2.262.1.10.2.11":"Telesec Ttp Asymmetric Application","0.2.262.1.10.2.12":"Telesec Ttp Basis Application","0.2.262.1.10.2.13":"Telesec Ttp Messages","0.2.262.1.10.2.14":"Telesec Ttp Time Stamp Application","0.2.262.1.10.3":"Object Class","0.2.262.1.10.3.0":"Telesec Other Name","0.2.262.1.10.3.1":"Directory","0.2.262.1.10.3.2":"Directory Type","0.2.262.1.10.3.3":"Directory Group","0.2.262.1.10.3.4":"Directory User","0.2.262.1.10.3.5":"Symmetric Key Entry","0.2.262.1.10.4":"Package","0.2.262.1.10.5":"Parameter","0.2.262.1.10.6":"Name Binding","0.2.262.1.10.7":"Attribute","0.2.262.1.10.7.0":"Application Group Identifier","0.2.262.1.10.7.1":"Certificate Type","0.2.262.1.10.7.2":"Telesec Certificate","0.2.262.1.10.7.3":"Certificate Number","0.2.262.1.10.7.4":"Certificate Revocation List","0.2.262.1.10.7.5":"Creation Date","0.2.262.1.10.7.6":"Issuer","0.2.262.1.10.7.7":"Naming Authority","0.2.262.1.10.7.8":"Public Key Directory","0.2.262.1.10.7.9":"Security Domain","0.2.262.1.10.7.10":"Subject","0.2.262.1.10.7.11":"Time Of Revocation","0.2.262.1.10.7.12":"User Group Reference","0.2.262.1.10.7.13":"alidity","0.2.262.1.10.7.14":"Zert93","0.2.262.1.10.7.15":"Security Mess Env","0.2.262.1.10.7.16":"Anonymized Public Key Directory","0.2.262.1.10.7.17":"Telesec Given Name","0.2.262.1.10.7.18":"Name Additions","0.2.262.1.10.7.19":"Telesec Postal Code","0.2.262.1.10.7.20":"Name Distinguisher","0.2.262.1.10.7.21":"Telesec Certificate List","0.2.262.1.10.7.22":"Teletrust Certificate List","0.2.262.1.10.7.23":"x509 Certificate List","0.2.262.1.10.7.24":"Time Of Issue","0.2.262.1.10.7.25":"Physical Card Number","0.2.262.1.10.7.26":"File Type","0.2.262.1.10.7.27":"Ctl File Is Archive","0.2.262.1.10.7.28":"Email Address","0.2.262.1.10.7.29":"Certificate Template List","0.2.262.1.10.7.30":"Directory Name","0.2.262.1.10.7.31":"Directory Type Name","0.2.262.1.10.7.32":"Directory Group Name","0.2.262.1.10.7.33":"Directory User Name","0.2.262.1.10.7.34":"Revocation Flag","0.2.262.1.10.7.35":"Symmetric Key Entry Name","0.2.262.1.10.7.36":"Gl Number","0.2.262.1.10.7.37":"Go Number","0.2.262.1.10.7.38":"G Key Data","0.2.262.1.10.7.39":"Z Key Data","0.2.262.1.10.7.40":"Kt Key Data","0.2.262.1.10.7.41":"Kt Key Number","0.2.262.1.10.7.51":"Time Of Revocation Gen","0.2.262.1.10.7.52":"Liability Text","0.2.262.1.10.8":"Attribute Group","0.2.262.1.10.9":"Action","0.2.262.1.10.10":"Notification","0.2.262.1.10.11":"Snmp-mibs","0.2.262.1.10.11.1":"Security Application","0.2.262.1.10.12":"Cert And Crl Extension Definitions","0.2.262.1.10.12.0":"Liability Limitation Flag","0.2.262.1.10.12.1":"Telesec Cert Id Ext","0.2.262.1.10.12.2":"Telesec policy Identifier","0.2.262.1.10.12.3":"Telesec Policy Qualifier I D","0.2.262.1.10.12.4":"Telesec CRL Filtered Ext","0.2.262.1.10.12.5":"Telesec CRL Filter Ext","0.2.262.1.10.12.6":"Telesec Naming Authority Ext","0.4.0.127.0.7":"Bsi","0.4.0.127.0.7.1":"Bsi Ecc","0.4.0.127.0.7.1.1":"Bsifield Type","0.4.0.127.0.7.1.1.1":"Bsi Prime Field","0.4.0.127.0.7.1.1.2":"Bsi Characteristic Two Field","0.4.0.127.0.7.1.1.2.2":"Bsi ECTLV Key Format","0.4.0.127.0.7.1.1.2.2.1":"Bsi ECTLV Public Key","0.4.0.127.0.7.1.1.2.3":"Bsi Characteristic Two Basis","0.4.0.127.0.7.1.1.2.3.1":"Bsi Gn Basis","0.4.0.127.0.7.1.1.2.3.2":"Bsi Tp Basis","0.4.0.127.0.7.1.1.2.3.3":"Bsi Pp Basis","0.4.0.127.0.7.1.1.4.1":"Bsi Ecdsa Signatures","0.4.0.127.0.7.1.1.4.1.1":"Bsi Ecdsa With SHA1","0.4.0.127.0.7.1.1.4.1.2":"Bsi Ecdsa With SHA224","0.4.0.127.0.7.1.1.4.1.3":"Bsi Ecdsa With SHA256","0.4.0.127.0.7.1.1.4.1.4":"Bsi Ecdsa With SHA384","0.4.0.127.0.7.1.1.4.1.5":"Bsi Ecdsa With SHA512","0.4.0.127.0.7.1.1.4.1.6":"Bsi Ecdsa With RIPEMD160","0.4.0.127.0.7.1.1.5.1.1":"Bsi Ecka Eg x963KDF","0.4.0.127.0.7.1.1.5.1.1.1":"Bsi Ecka Eg x963KDF With SHA1","0.4.0.127.0.7.1.1.5.1.1.2":"Bsi Ecka Eg x963KDF With SHA224","0.4.0.127.0.7.1.1.5.1.1.3":"Bsi Ecka Eg x963KDF With SHA256","0.4.0.127.0.7.1.1.5.1.1.4":"Bsi Ecka Eg x963KDF With SHA384","0.4.0.127.0.7.1.1.5.1.1.5":"Bsi Ecka Eg x963KDF With SHA512","0.4.0.127.0.7.1.1.5.1.1.6":"Bsi Ecka Eg x963KDF With RIPEMD160","0.4.0.127.0.7.1.1.5.1.2":"Bsi Ecka Eg Session KDF","0.4.0.127.0.7.1.1.5.1.2.1":"Bsi Ecka Eg Session KDF With3DES","0.4.0.127.0.7.1.1.5.1.2.2":"Bsi Ecka Eg Session KDF With AES128","0.4.0.127.0.7.1.1.5.1.2.3":"Bsi Ecka Eg Session KDF With AES192","0.4.0.127.0.7.1.1.5.1.2.4":"Bsi Ecka Eg Session KDF With AES256","0.4.0.127.0.7.1.1.5.2":"Bsi Ecka DH","0.4.0.127.0.7.1.1.5.2.1":"Bsi Ecka DH x963KDF","0.4.0.127.0.7.1.1.5.2.1.1":"Bsi Ecka DHx963KDF With SHA1","0.4.0.127.0.7.1.1.5.2.1.2":"Bsi Ecka DHx963KDF With SHA224","0.4.0.127.0.7.1.1.5.2.1.3":"Bsi Ecka DHx963KDF With SHA256","0.4.0.127.0.7.1.1.5.2.1.4":"Bsi Ecka DHx963KDF With SHA384","0.4.0.127.0.7.1.1.5.2.1.5":"Bsi Ecka DHx963KDF With SHA512","0.4.0.127.0.7.1.1.5.2.1.6":"Bsi Ecka DHx963KDF With RIPEMD160","0.4.0.127.0.7.1.1.5.2.2":"Bsi Ecka DHSessionKDF","0.4.0.127.0.7.1.1.5.2.2.1":"Bsi Ecka DH Session KDF With3 DES","0.4.0.127.0.7.1.1.5.2.2.2":"Bsi Ecka DH Session KDF With AES128","0.4.0.127.0.7.1.1.5.2.2.3":"Bsi Ecka DH Session KDF With AES192","0.4.0.127.0.7.1.1.5.2.2.4":"Bsi Ecka DH Session KDF With AES256","0.4.0.127.0.7.1.2":"Bsi Ec Key Type","0.4.0.127.0.7.1.2.1":"Bsi Ec Public Key","0.4.0.127.0.7.1.5.1":"Bsi Kaeg","0.4.0.127.0.7.1.5.1.1":"Bsi Kaeg With x963KDF","0.4.0.127.0.7.1.5.1.2":"Bsi Kaeg With 3DESKDF","0.4.0.127.0.7.2.2.1":"Bsi PK","0.4.0.127.0.7.2.2.1.1":"Bsi PK_DH","0.4.0.127.0.7.2.2.1.2":"Bsi PK_ECDH","0.4.0.127.0.7.2.2.2":"Bsi TA","0.4.0.127.0.7.2.2.2.1":"Bsi TA_RSA","0.4.0.127.0.7.2.2.2.1.1":"Bsi TA_RSAv1_5_SHA1","0.4.0.127.0.7.2.2.2.1.2":"Bsi TA_RSAv1_5_SHA256","0.4.0.127.0.7.2.2.2.1.3":"Bsi TA_RSAPSS_SHA1","0.4.0.127.0.7.2.2.2.1.4":"Bsi TA_RSAPSS_SHA256","0.4.0.127.0.7.2.2.2.1.5":"Bsi TA_RSAv1_5_SHA512","0.4.0.127.0.7.2.2.2.1.6":"Bsi TA_RSAPSS_SHA512","0.4.0.127.0.7.2.2.2.2":"Bsi TA_ECDSA","0.4.0.127.0.7.2.2.2.2.1":"Bsi TA_ECDSA_SHA1","0.4.0.127.0.7.2.2.2.2.2":"Bsi TA_ECDSA_SHA224","0.4.0.127.0.7.2.2.2.2.3":"Bsi TA_ECDSA_SHA256","0.4.0.127.0.7.2.2.2.2.4":"Bsi TA_ECDSA_SHA384","0.4.0.127.0.7.2.2.2.2.5":"Bsi TA_ECDSA_SHA512","0.4.0.127.0.7.2.2.3":"Bsi CA","0.4.0.127.0.7.2.2.3.1":"Bsi CA_DH","0.4.0.127.0.7.2.2.3.1.1":"Bsi CA_DH_3DES_CBC_CBC","0.4.0.127.0.7.2.2.3.1.2":"Bsi CA_DH_AES_CBC_CMAC_128","0.4.0.127.0.7.2.2.3.1.3":"Bsi CA_DH_AES_CBC_CMAC_192","0.4.0.127.0.7.2.2.3.1.4":"Bsi CA_DH_AES_CBC_CMAC_256","0.4.0.127.0.7.2.2.3.2":"Bsi CA_ECDH","0.4.0.127.0.7.2.2.3.2.1":"Bsi CA_ECDH_3DES_CBC_CBC","0.4.0.127.0.7.2.2.3.2.2":"Bsi CA_ECDH_AES_CBC_CMAC_128","0.4.0.127.0.7.2.2.3.2.3":"Bsi CA_ECDH_AES_CBC_CMAC_192","0.4.0.127.0.7.2.2.3.2.4":"Bsi CA_ECDH_AES_CBC_CMAC_256","0.4.0.127.0.7.2.2.4":"Bsi PACE","0.4.0.127.0.7.2.2.4.1":"Bsi PACE_DH_GM","0.4.0.127.0.7.2.2.4.1.1":"Bsi PACE_DH_GM_3DES_CBC_CBC","0.4.0.127.0.7.2.2.4.1.2":"Bsi PACE_DH_GM_AES_CBC_CMAC_128","0.4.0.127.0.7.2.2.4.1.3":"Bsi PACE_DH_GM_AES_CBC_CMAC_192","0.4.0.127.0.7.2.2.4.1.4":"Bsi PACE_DH_GM_AES_CBC_CMAC_256","0.4.0.127.0.7.2.2.4.2":"Bsi PACE_ECDH_GM","0.4.0.127.0.7.2.2.4.2.1":"Bsi PACE_ECDH_GM_3DES_CBC_CBC","0.4.0.127.0.7.2.2.4.2.2":"Bsi PACE_ECDH_GM_AES_CBC_CMAC_128","0.4.0.127.0.7.2.2.4.2.3":"Bsi PACE_ECDH_GM_AES_CBC_CMAC_192","0.4.0.127.0.7.2.2.4.2.4":"Bsi PACE_ECDH_GM_AES_CBC_CMAC_256","0.4.0.127.0.7.2.2.4.3":"Bsi PACE_DH_IM","0.4.0.127.0.7.2.2.4.3.1":"Bsi PACE_DH_IM_3DES_CBC_CBC","0.4.0.127.0.7.2.2.4.3.2":"Bsi PACE_DH_IM_AES_CBC_CMAC_128","0.4.0.127.0.7.2.2.4.3.3":"Bsi PACE_DH_IM_AES_CBC_CMAC_192","0.4.0.127.0.7.2.2.4.3.4":"Bsi PACE_DH_IM_AES_CBC_CMAC_256","0.4.0.127.0.7.2.2.4.4":"Bsi PACE_ECDH_IM","0.4.0.127.0.7.2.2.4.4.1":"Bsi PACE_ECDH_IM_3DES_CBC_CBC","0.4.0.127.0.7.2.2.4.4.2":"Bsi PACE_ECDH_IM_AES_CBC_CMAC_128","0.4.0.127.0.7.2.2.4.4.3":"Bsi PACE_ECDH_IM_AES_CBC_CMAC_192","0.4.0.127.0.7.2.2.4.4.4":"Bsi PACE_ECDH_IM_AES_CBC_CMAC_256","0.4.0.127.0.7.2.2.5":"Bsi RI","0.4.0.127.0.7.2.2.5.1":"Bsi RI_DH","0.4.0.127.0.7.2.2.5.1.1":"Bsi RI_DH_SHA1","0.4.0.127.0.7.2.2.5.1.2":"Bsi RI_DH_SHA224","0.4.0.127.0.7.2.2.5.1.3":"Bsi RI_DH_SHA256","0.4.0.127.0.7.2.2.5.1.4":"Bsi RI_DH_SHA384","0.4.0.127.0.7.2.2.5.1.5":"Bsi RI_DH_SHA512","0.4.0.127.0.7.2.2.5.2":"Bsi RI_ECDH","0.4.0.127.0.7.2.2.5.2.1":"Bsi RI_ECDH_SHA1","0.4.0.127.0.7.2.2.5.2.2":"Bsi RI_ECDH_SHA224","0.4.0.127.0.7.2.2.5.2.3":"Bsi RI_ECDH_SHA256","0.4.0.127.0.7.2.2.5.2.4":"Bsi RI_ECDH_SHA384","0.4.0.127.0.7.2.2.5.2.5":"Bsi RI_ECDH_SHA512","0.4.0.127.0.7.2.2.6":"Bsi Card Info","0.4.0.127.0.7.2.2.7":"Bsi Eid Security","0.4.0.127.0.7.2.2.8":"Bsi PT","0.4.0.127.0.7.3.1.2":"Bsi EAC Roles","0.4.0.127.0.7.3.1.2.1":"Bsi EAC Roles IS","0.4.0.127.0.7.3.1.2.2":"Bsi EAC Roles AT","0.4.0.127.0.7.3.1.2.3":"Bsi EAC Roles ST","0.4.0.127.0.7.3.1.3":"Bsi TAv2ce","0.4.0.127.0.7.3.1.3.1":"Bsi TAv2ce Description","0.4.0.127.0.7.3.1.3.1.1":"Bsi TAv2ce Description Plain Text","0.4.0.127.0.7.3.1.3.1.2":"Bsi TAv2ce Description IA5 String","0.4.0.127.0.7.3.1.3.1.3":"Bsi TAv2ce Description Octet String","0.4.0.127.0.7.3.1.3.2":"Bsi TAv2ce Terminal Sector","0.4.0.127.0.7.3.1.4":"Bsi Aux Data","0.4.0.127.0.7.3.1.4.1":"Bsi Aux Data Birthday","0.4.0.127.0.7.3.1.4.2":"Bsi Aux Data Expire Date","0.4.0.127.0.7.3.1.4.3":"Bsi Aux Data Community ID","0.4.0.127.0.7.3.1.5":"Bsi Defect List","0.4.0.127.0.7.3.1.5.1":"Bsi Defect Auth Defect","0.4.0.127.0.7.3.1.5.1.1":"Bsi Defect Cert Revoked","0.4.0.127.0.7.3.1.5.1.2":"Bsi Defect Cert Replaced","0.4.0.127.0.7.3.1.5.1.3":"Bsi Defect Chip Auth Key Revoked","0.4.0.127.0.7.3.1.5.1.4":"Bsi Defect Active Auth Key Revoked","0.4.0.127.0.7.3.1.5.2":"Bsi Defect EPassport Defect","0.4.0.127.0.7.3.1.5.2.1":"Bsi Defect EPassport DG Malformed","0.4.0.127.0.7.3.1.5.2.2":"Bsi Defect SOD Invalid","0.4.0.127.0.7.3.1.5.3":"Bsi Defect EID Defect","0.4.0.127.0.7.3.1.5.3.1":"Bsi Defect EIDDG Malformed","0.4.0.127.0.7.3.1.5.3.2":"Bsi Defect EID Integrity","0.4.0.127.0.7.3.1.5.4":"Bsi Defect Document Defect","0.4.0.127.0.7.3.1.5.4.1":"Bsi Defect Card Security Malformed","0.4.0.127.0.7.3.1.5.4.2":"Bsi Defect Chip Security Malformed","0.4.0.127.0.7.3.1.5.4.3":"Bsi Defect Power Down Req","0.4.0.127.0.7.3.1.6":"Bsi List Content Description","0.4.0.127.0.7.3.2.1":"Bsi Security Object","0.4.0.127.0.7.3.2.2":"Bsi Black List","0.4.0.1862":"Etsi Qcs Profile","0.4.0.1862.1":"Etsi Qcs","0.4.0.1862.1.1":"Etsi Qcs Compliance","0.4.0.1862.1.2":"Etsi Qcs Limit Value","0.4.0.1862.1.3":"Etsi Qcs Retention Period","0.4.0.1862.1.4":"Etsi Qcs QcSSCD","0.9.2342.19200300.100.1.1":"User ID","0.9.2342.19200300.100.1.3":"Rfc822 Mailbox","0.9.2342.19200300.100.1.25":"Domain Component","1.0.10118.3.0.49":"Ripemd160","1.0.10118.3.0.50":"Ripemd128","1.0.10118.3.0.55":"Whirlpool","1.2.36.1.3.1.1.1":"Qgpki","1.2.36.1.3.1.1.1.1":"Qgpki Policies","1.2.36.1.3.1.1.1.1.1":"Qgpki Med Intermed CA","1.2.36.1.3.1.1.1.1.1.1":"Qgpki Med Intermed Individual","1.2.36.1.3.1.1.1.1.1.2":"Qgpki Med Intermed Device Control","1.2.36.1.3.1.1.1.1.1.3":"Qgpki Med Intermed Device","1.2.36.1.3.1.1.1.1.1.4":"Qgpki Med Intermed Authorised Party","1.2.36.1.3.1.1.1.1.1.5":"Qgpki Med Intermed Device System","1.2.36.1.3.1.1.1.1.2":"Qgpki Med Issuing CA","1.2.36.1.3.1.1.1.1.2.1":"Qgpki Med Issuing Individual","1.2.36.1.3.1.1.1.1.2.2":"Qgpki Med Issuing Device Control","1.2.36.1.3.1.1.1.1.2.3":"Qgpki Med Issuing Device","1.2.36.1.3.1.1.1.1.2.4":"Qgpki Med Issuing Authorised Party","1.2.36.1.3.1.1.1.1.2.5":"Qgpki Med Issuing Client Auth","1.2.36.1.3.1.1.1.1.2.6":"Qgpki Med Issuing Server Auth","1.2.36.1.3.1.1.1.1.2.7":"Qgpki Med Issuing Data Prot","1.2.36.1.3.1.1.1.1.2.8":"Qgpki Med Issuing Token Auth","1.2.36.1.3.1.1.1.1.3":"Qgpki Basic Intermed CA","1.2.36.1.3.1.1.1.1.3.1":"Qgpki Basic Intermed Device System","1.2.36.1.3.1.1.1.1.4":"Qgpki Basic Issuing CA","1.2.36.1.3.1.1.1.1.4.1":"Qgpki Basic Issuing Client Auth","1.2.36.1.3.1.1.1.1.4.2":"Qgpki Basic Issuing Server Auth","1.2.36.1.3.1.1.1.1.4.3":"Qgpki Basic Issuing Data Signing","1.2.36.1.3.1.1.1.2":"Qgpki Assurance Level","1.2.36.1.3.1.1.1.2.1":"Qgpki Assurance Rudimentary","1.2.36.1.3.1.1.1.2.2":"Qgpki Assurance Basic","1.2.36.1.3.1.1.1.2.3":"Qgpki Assurance Medium","1.2.36.1.3.1.1.1.2.4":"Qgpki Assurance High","1.2.36.1.3.1.1.1.3":"Qgpki Cert Function","1.2.36.1.3.1.1.1.3.1":"Qgpki Function Individual","1.2.36.1.3.1.1.1.3.2":"Qgpki Function Device","1.2.36.1.3.1.1.1.3.3":"Qgpki Function Authorised Party","1.2.36.1.3.1.1.1.3.4":"Qgpki Function Device Control","1.2.36.1.3.1.2":"Qpspki","1.2.36.1.3.1.2.1":"Qpspki Policies","1.2.36.1.3.1.2.1.2":"Qpspki Policy Basic","1.2.36.1.3.1.2.1.3":"Qpspki Policy Medium","1.2.36.1.3.1.2.1.4":"Qpspki Policy High","1.2.36.1.3.1.3.2":"Qtmrpki","1.2.36.1.3.1.3.2.1":"Qtmrpki Policies","1.2.36.1.3.1.3.2.2":"Qtmrpki Purpose","1.2.36.1.3.1.3.2.2.1":"Qtmrpki Individual","1.2.36.1.3.1.3.2.2.2":"Qtmrpki Device Control","1.2.36.1.3.1.3.2.2.3":"Qtmrpki Device","1.2.36.1.3.1.3.2.2.4":"Qtmrpki Authorised Party","1.2.36.1.3.1.3.2.2.5":"Qtmrpki Device System","1.2.36.1.3.1.3.2.3":"Qtmrpki Device","1.2.36.1.3.1.3.2.3.1":"Qtmrpki Driver License","1.2.36.1.3.1.3.2.3.2":"Qtmrpki Industry Authority","1.2.36.1.3.1.3.2.3.3":"Qtmrpki Marine License","1.2.36.1.3.1.3.2.3.4":"Qtmrpki Adult Proof Of Age","1.2.36.1.3.1.3.2.3.5":"Qtmrpki Sam","1.2.36.1.3.1.3.2.4":"Qtmrpki Authorised Party","1.2.36.1.3.1.3.2.4.1":"Qtmrpki Transport Inspector","1.2.36.1.3.1.3.2.4.2":"Qtmrpki Police Officer","1.2.36.1.3.1.3.2.4.3":"Qtmrpki System","1.2.36.1.3.1.3.2.4.4":"Qtmrpki Liquor Licensing Inspector","1.2.36.1.3.1.3.2.4.5":"Qtmrpki Marine Enforcement Officer","1.2.36.1.333.1":"Australian Business Number","1.2.36.68980861.1.1.2":"Signet Personal","1.2.36.68980861.1.1.3":"Signet Business","1.2.36.68980861.1.1.4":"Signet Legal","1.2.36.68980861.1.1.10":"Signet Pilot","1.2.36.68980861.1.1.11":"Signet Intra Net","1.2.36.68980861.1.1.20":"Signet Policy","1.2.36.75878867.1.100.1.1":"Certificates Australia Policy","1.2.40.0.17.1.22":"A-Trust  EV policy","1.2.392.200011.61.1.1.1":"Mitsubishi Security Algorithm","1.2.392.200011.61.1.1.1.1":"Misty1-cbc","1.2.392.200091.100.721.1":"Security Communication (SECOM) EV policy","1.2.410.200004.1":"Kisa Algorithm","1.2.410.200004.1.1":"Kcdsa","1.2.410.200004.1.2":"Has160","1.2.410.200004.1.3":"Seed ECB","1.2.410.200004.1.4":"Seed CBC","1.2.410.200004.1.5":"Seed OFB","1.2.410.200004.1.6":"Seed CFB","1.2.410.200004.1.7":"Seed MAC","1.2.410.200004.1.8":"Kcdsa With HAS160","1.2.410.200004.1.9":"Kcdsa With SHA1","1.2.410.200004.1.10":"PBE With HAS160 And SEED-ECB","1.2.410.200004.1.11":"PBE With HAS160 And SEED-CBC","1.2.410.200004.1.12":"PBE With HAS160 And SEED-CFB","1.2.410.200004.1.13":"PBE With HAS160 And SEED-OFB","1.2.410.200004.1.14":"PBE With SHA1 And SEED-ECB","1.2.410.200004.1.15":"PBE With SHA1 And SEED-CBC","1.2.410.200004.1.16":"PBE With SHA1 And SEED-CFB","1.2.410.200004.1.17":"PBE With SHA1 And SEED-OFB","1.2.410.200004.1.20":"RSA With HAS160","1.2.410.200004.1.21":"Kcdsa1","1.2.410.200004.2":"Npki CP","1.2.410.200004.2.1":"Npki Signature Policy","1.2.410.200004.3":"Npki KP","1.2.410.200004.4":"Npki AT","1.2.410.200004.5":"Npki LCA","1.2.410.200004.5.1":"Npki Sign Korea","1.2.410.200004.5.2":"Npki Sign Gate","1.2.410.200004.5.3":"Npki Nca Sign","1.2.410.200004.6":"Npki ON","1.2.410.200004.7":"Npki APP","1.2.410.200004.7.1":"Npki SMIME","1.2.410.200004.7.1.1":"Npki SMIME Algo","1.2.410.200004.7.1.1.1":"Npki Cms SEED Wrap","1.2.410.200004.10":"Npki","1.2.410.200004.10.1":"Npki Attribute","1.2.410.200004.10.1.1":"Npki Identify Data","1.2.410.200004.10.1.1.1":"Npki VID","1.2.410.200004.10.1.1.2":"Npki Encrypted VID","1.2.410.200004.10.1.1.3":"Npki Random Num","1.2.410.200004.10.1.1.4":"Npki VID","1.2.410.200046.1.1":"Aria1 Algorithm Modes","1.2.410.200046.1.1.1":"Aria128-ecb","1.2.410.200046.1.1.2":"Aria128-cbc","1.2.410.200046.1.1.3":"Aria128-cfb","1.2.410.200046.1.1.4":"Aria128-ofb","1.2.410.200046.1.1.5":"Aria128-ctr","1.2.410.200046.1.1.6":"Aria192-ecb","1.2.410.200046.1.1.7":"Aria192-cbc","1.2.410.200046.1.1.8":"Aria192-cfb","1.2.410.200046.1.1.9":"Aria192-ofb","1.2.410.200046.1.1.10":"Aria192-ctr","1.2.410.200046.1.1.11":"Aria256-ecb","1.2.410.200046.1.1.12":"Aria256-cbc","1.2.410.200046.1.1.13":"Aria256-cfb","1.2.410.200046.1.1.14":"Aria256-ofb","1.2.410.200046.1.1.15":"Aria256-ctr","1.2.410.200046.1.1.21":"Aria128-cmac","1.2.410.200046.1.1.22":"Aria192-cmac","1.2.410.200046.1.1.23":"Aria256-cmac","1.2.410.200046.1.1.31":"Aria128-ocb2","1.2.410.200046.1.1.32":"Aria192-ocb2","1.2.410.200046.1.1.33":"Aria256-ocb2","1.2.410.200046.1.1.34":"Aria128-gcm","1.2.410.200046.1.1.35":"Aria192-gcm","1.2.410.200046.1.1.36":"Aria256-gcm","1.2.410.200046.1.1.37":"Aria128-ccm","1.2.410.200046.1.1.38":"Aria192-ccm","1.2.410.200046.1.1.39":"Aria256-ccm","1.2.410.200046.1.1.40":"Aria128-keywrap","1.2.410.200046.1.1.41":"Aria192-keywrap","1.2.410.200046.1.1.42":"Aria256-keywrap","1.2.410.200046.1.1.43":"Aria128-keywrap With Pad","1.2.410.200046.1.1.44":"Aria192-keywrap With Pad","1.2.410.200046.1.1.45":"Aria256-keywrap With Pad","1.2.643.2.2.3":"Gost Signature","1.2.643.2.2.4":"Gost94 Signature","1.2.643.2.2.9":"Gost Digest","1.2.643.2.2.10":"Hmac Gost","1.2.643.2.2.13.0":"Gost Wrap","1.2.643.2.2.13.1":"Crypto Pro Wrap","1.2.643.2.2.14.0":"Null Meshing","1.2.643.2.2.14.1":"Crypto Pro Meshing","1.2.643.2.2.19":"Gost Public Key","1.2.643.2.2.20":"Gost94 Public Key","1.2.643.2.2.21":"Gost Cipher","1.2.643.2.2.30.0":"Test Digest Params","1.2.643.2.2.30.1":"Crypto Pro Digest A","1.2.643.2.2.31.0":"Test Cipher Params","1.2.643.2.2.31.1":"Crypto Pro Cipher A","1.2.643.2.2.31.2":"Crypto Pro Cipher B","1.2.643.2.2.31.3":"Crypto Pro Cipher C","1.2.643.2.2.31.4":"Crypto Pro Cipher D","1.2.643.2.2.31.5":"Oscar11 Cipher","1.2.643.2.2.31.6":"Oscar10 Cipher","1.2.643.2.2.31.7":"Ric1 Cipher","1.2.643.2.2.35.0":"Test Sign Params","1.2.643.2.2.35.1":"Crypto Pro Sign A","1.2.643.2.2.35.2":"Crypto Pro Sign B","1.2.643.2.2.35.3":"Crypto Pro Sign C","1.2.643.2.2.36.0":"Crypto Pro Sign XA","1.2.643.2.2.36.1":"Crypto Pro Sign XB","1.2.643.2.2.96":"Crypto Pro ECDH Wrap","1.2.752.34.1":"Seis-cp","1.2.752.34.1.1":"SEIS high-assurance policy Identifier","1.2.752.34.1.2":"SEIS GAK policy Identifier","1.2.752.34.2":"SEI Spe","1.2.752.34.3":"SEI Sat","1.2.752.34.3.1":"SEI Sat-personal Identifier","1.2.840.10040.1":"Module","1.2.840.10040.1.1":"x9f1-cert-mgmt","1.2.840.10040.2":"Holdinstruction","1.2.840.10040.2.1":"Holdinstruction-none","1.2.840.10040.2.2":"Callissuer","1.2.840.10040.2.3":"Reject","1.2.840.10040.2.4":"Pickup Token","1.2.840.10040.3":"Attribute","1.2.840.10040.3.1":"Countersignature","1.2.840.10040.3.2":"Attribute-cert","1.2.840.10040.4":"Algorithm","1.2.840.10040.4.1":"DSA","1.2.840.10040.4.2":"DSA-match","1.2.840.10040.4.3":"DSA With SHA1","1.2.840.10045.1":"Field Type","1.2.840.10045.1.1":"Prime-field","1.2.840.10045.1.2":"Characteristic-two-field","1.2.840.10045.1.2.3":"Characteristic-two-basis","1.2.840.10045.1.2.3.1":"ON Basis","1.2.840.10045.1.2.3.2":"TP Basis","1.2.840.10045.1.2.3.3":"PP Basis","1.2.840.10045.2":"Public Key Type","1.2.840.10045.2.1":"EC Public Key","1.2.840.10045.3.0.1":"C2pnb163v1","1.2.840.10045.3.0.2":"C2pnb163v2","1.2.840.10045.3.0.3":"C2pnb163v3","1.2.840.10045.3.0.5":"C2tnb191v1","1.2.840.10045.3.0.6":"C2tnb191v2","1.2.840.10045.3.0.7":"C2tnb191v3","1.2.840.10045.3.0.10":"C2pnb208w1","1.2.840.10045.3.0.11":"C2tnb239v1","1.2.840.10045.3.0.12":"C2tnb239v2","1.2.840.10045.3.0.13":"C2tnb239v3","1.2.840.10045.3.0.16":"C2pnb272w1","1.2.840.10045.3.0.18":"C2tnb359v1","1.2.840.10045.3.0.19":"C2pnb368w1","1.2.840.10045.3.0.20":"C2tnb431r1","1.2.840.10045.3.1.1":"Prime192v1","1.2.840.10045.3.1.2":"Prime192v2","1.2.840.10045.3.1.3":"Prime192v3","1.2.840.10045.3.1.4":"Prime239v1","1.2.840.10045.3.1.5":"Prime239v2","1.2.840.10045.3.1.6":"Prime239v3","1.2.840.10045.3.1.7":"Prime256v1","1.2.840.10045.4.1":"ECDSA With SHA1","1.2.840.10045.4.2":"ECDSA With Recommended","1.2.840.10045.4.3":"ECDSA With Specified","1.2.840.10045.4.3.1":"ECDSA With SHA224","1.2.840.10045.4.3.2":"ECDSA With SHA256","1.2.840.10045.4.3.3":"ECDSA With SHA384","1.2.840.10045.4.3.4":"ECDSA With SHA512","1.2.840.10046.1":"Field Type","1.2.840.10046.1.1":"Gf-prime","1.2.840.10046.2":"Number Type","1.2.840.10046.2.1":"DH Public Key","1.2.840.10046.3":"Scheme","1.2.840.10046.3.1":"DH Static","1.2.840.10046.3.2":"DH Ephem","1.2.840.10046.3.3":"DH Hybrid1","1.2.840.10046.3.4":"DH Hybrid2","1.2.840.10046.3.5":"Mqv2","1.2.840.10046.3.6":"Mqv1","1.2.840.10065.2.2":"?","1.2.840.10065.2.3":"Healthcare License","1.2.840.10065.2.3.1.1":"License?","1.2.840.10070.":"Iec62351","1.2.840.10070.8":"Iec62351_8","1.2.840.10070.8.1":"Iec User Roles","1.2.840.113533.7":"NSN","1.2.840.113533.7.65":"NSN-ce","1.2.840.113533.7.65.0":"Entrust Vers Info","1.2.840.113533.7.66":"NSN-alg","1.2.840.113533.7.66.3":"Cast3 CBC","1.2.840.113533.7.66.10":"Cast5 CBC","1.2.840.113533.7.66.11":"Cast5 MAC","1.2.840.113533.7.66.12":"PBE With MD5 And CAST5-CBC","1.2.840.113533.7.66.13":"Password Based Mac","1.2.840.113533.7.67":"NSN-oc","1.2.840.113533.7.67.0":"Entrust User","1.2.840.113533.7.68":"NSN-at","1.2.840.113533.7.68.0":"Entrust CA Info","1.2.840.113533.7.68.10":"Attribute Certificate","1.2.840.113549.1.1":"PKCS-1","1.2.840.113549.1.1.1":"RSA Encryption","1.2.840.113549.1.1.2":"MD2 With RSA Encryption","1.2.840.113549.1.1.3":"MD4 With RSA Encryption","1.2.840.113549.1.1.4":"MD5 With RSA Encryption","1.2.840.113549.1.1.5":"SHA1 With RSA Encryption","1.2.840.113549.1.1.6":"RSA OAEP Encryption SET","1.2.840.113549.1.1.7":"RSA OAEP","1.2.840.113549.1.1.8":"PKCS1-MGF","1.2.840.113549.1.1.9":"RSA OAEP-p Specified","1.2.840.113549.1.1.10":"RSA PSS","1.2.840.113549.1.1.11":"SHA256 With RSA Encryption","1.2.840.113549.1.1.12":"SHA384 With RSA Encryption","1.2.840.113549.1.1.13":"SHA512 With RSA Encryption","1.2.840.113549.1.1.14":"SHA224 With RSA Encryption","1.2.840.113549.1.2":"Bsafe Rsa Encr","1.2.840.113549.1.3":"PKCS-3","1.2.840.113549.1.3.1":"Dh Key Agreement","1.2.840.113549.1.5":"PKCS-5","1.2.840.113549.1.5.1":"PBE With MD2 And DES-CBC","1.2.840.113549.1.5.3":"PBE With MD5 And DES-CBC","1.2.840.113549.1.5.4":"PBE With MD2 And RC2-CBC","1.2.840.113549.1.5.6":"PBE With MD5 And RC2-CBC","1.2.840.113549.1.5.9":"PBE With MD5 And XOR","1.2.840.113549.1.5.10":"PBE With SHA And DES-CBC","1.2.840.113549.1.5.12":"PKCS5 PBKDF2","1.2.840.113549.1.5.13":"PKCS5 PBES2","1.2.840.113549.1.5.14":"PKCS5 PBMAC1","1.2.840.113549.1.7":"PKCS-7","1.2.840.113549.1.7.1":"Data","1.2.840.113549.1.7.2":"Signed Data","1.2.840.113549.1.7.3":"Enveloped Data","1.2.840.113549.1.7.4":"Signed And Enveloped Data","1.2.840.113549.1.7.5":"Digested Data","1.2.840.113549.1.7.6":"Encrypted Data","1.2.840.113549.1.7.7":"Data With Attributes","1.2.840.113549.1.7.8":"Encrypted Private Key Info","1.2.840.113549.1.9":"PKCS-9","1.2.840.113549.1.9.1":"Email","1.2.840.113549.1.9.2":"Unstructured Name","1.2.840.113549.1.9.3":"Content Type","1.2.840.113549.1.9.4":"Message Digest","1.2.840.113549.1.9.5":"Signing Time","1.2.840.113549.1.9.6":"Countersignature","1.2.840.113549.1.9.7":"Challenge Password","1.2.840.113549.1.9.8":"Unstructured Address","1.2.840.113549.1.9.9":"Extended Certificate Attributes","1.2.840.113549.1.9.10":"Issuer And Serial Number","1.2.840.113549.1.9.11":"Password Check","1.2.840.113549.1.9.12":"Public Key","1.2.840.113549.1.9.13":"Signing Description","1.2.840.113549.1.9.14":"Extension Request","1.2.840.113549.1.9.15":"S/MIME Capabilities","1.2.840.113549.1.9.15.1":"Prefer Signed Data","1.2.840.113549.1.9.15.2":"Can Not Decrypt Any","1.2.840.113549.1.9.15.3":"Receipt Request","1.2.840.113549.1.9.15.4":"Receipt","1.2.840.113549.1.9.15.5":"Content Hints","1.2.840.113549.1.9.15.6":"Ml Expansion History","1.2.840.113549.1.9.16":"Id-sMIME","1.2.840.113549.1.9.16.0":"Id-mod","1.2.840.113549.1.9.16.0.1":"Id-mod-cms","1.2.840.113549.1.9.16.0.2":"Id-mod-ess","1.2.840.113549.1.9.16.0.3":"Id-mod-oid","1.2.840.113549.1.9.16.0.4":"Id-mod-msg-v3","1.2.840.113549.1.9.16.0.5":"Id-mod-ets-e Signature-88","1.2.840.113549.1.9.16.0.6":"Id-mod-ets-e Signature-97","1.2.840.113549.1.9.16.0.7":"Id-mod-ets-e Sig Policy-88","1.2.840.113549.1.9.16.0.8":"Id-mod-ets-e Sig Policy-88","1.2.840.113549.1.9.16.1":"Content Type","1.2.840.113549.1.9.16.1.1":"Receipt","1.2.840.113549.1.9.16.1.2":"Auth Data","1.2.840.113549.1.9.16.1.3":"Publish Cert","1.2.840.113549.1.9.16.1.4":"TST Info","1.2.840.113549.1.9.16.1.5":"TDT Info","1.2.840.113549.1.9.16.1.6":"Content Info","1.2.840.113549.1.9.16.1.7":"DVCS Request Data","1.2.840.113549.1.9.16.1.8":"DVCS Response Data","1.2.840.113549.1.9.16.1.9":"Compressed Data","1.2.840.113549.1.9.16.1.10":"SCVP Cert Val Request","1.2.840.113549.1.9.16.1.11":"SCVP Cert Val Response","1.2.840.113549.1.9.16.1.12":"SCVP Val Pol Request","1.2.840.113549.1.9.16.1.13":"SCVP Val Pol Response","1.2.840.113549.1.9.16.1.14":"Attr Cert Enc Attrs","1.2.840.113549.1.9.16.1.15":"TS Req","1.2.840.113549.1.9.16.1.16":"Firmware Package","1.2.840.113549.1.9.16.1.17":"Firmware Load Receipt","1.2.840.113549.1.9.16.1.18":"Firmware Load Error","1.2.840.113549.1.9.16.1.19":"Content Collection","1.2.840.113549.1.9.16.1.20":"Content With Attrs","1.2.840.113549.1.9.16.1.21":"Enc Key With I D","1.2.840.113549.1.9.16.1.22":"Enc PEPSI","1.2.840.113549.1.9.16.1.23":"Auth Enveloped Data","1.2.840.113549.1.9.16.1.24":"Route Origin Attest","1.2.840.113549.1.9.16.1.25":"Symmetric Key Package","1.2.840.113549.1.9.16.1.26":"Rpki Manifest","1.2.840.113549.1.9.16.1.27":"Ascii Text With CRLF","1.2.840.113549.1.9.16.1.28":"XML","1.2.840.113549.1.9.16.1.29":"PDF","1.2.840.113549.1.9.16.1.30":"Postscript","1.2.840.113549.1.9.16.1.31":"Timestamped Data","1.2.840.113549.1.9.16.1.32":"As Adjacency Attest","1.2.840.113549.1.9.16.1.33":"Rpki Trust Anchor","1.2.840.113549.1.9.16.1.34":"Trust Anchor List","1.2.840.113549.1.9.16.2":"Authenticated Attributes","1.2.840.113549.1.9.16.2.1":"Receipt Request","1.2.840.113549.1.9.16.2.2":"Security Label","1.2.840.113549.1.9.16.2.3":"Ml Expand History","1.2.840.113549.1.9.16.2.4":"Content Hint","1.2.840.113549.1.9.16.2.5":"Msg Sig Digest","1.2.840.113549.1.9.16.2.6":"Encap Content Type","1.2.840.113549.1.9.16.2.7":"Content Identifier","1.2.840.113549.1.9.16.2.8":"Mac Value","1.2.840.113549.1.9.16.2.9":"Equivalent Labels","1.2.840.113549.1.9.16.2.10":"Content Reference","1.2.840.113549.1.9.16.2.11":"Encryp Key Pref","1.2.840.113549.1.9.16.2.12":"Signing Certificate","1.2.840.113549.1.9.16.2.13":"Smime Encrypt Certs","1.2.840.113549.1.9.16.2.14":"Time Stamp Token","1.2.840.113549.1.9.16.2.15":"Sig Policy Id","1.2.840.113549.1.9.16.2.16":"Commitment Type","1.2.840.113549.1.9.16.2.17":"Signer Location","1.2.840.113549.1.9.16.2.18":"Signer Attr","1.2.840.113549.1.9.16.2.19":"Other Sig Cert","1.2.840.113549.1.9.16.2.20":"Content Timestamp","1.2.840.113549.1.9.16.2.21":"Certificate Refs","1.2.840.113549.1.9.16.2.22":"Revocation Refs","1.2.840.113549.1.9.16.2.23":"Cert Values","1.2.840.113549.1.9.16.2.24":"Revocation Values","1.2.840.113549.1.9.16.2.25":"Esc Time Stamp","1.2.840.113549.1.9.16.2.26":"Cert CRL Timestamp","1.2.840.113549.1.9.16.2.27":"Archive Time Stamp","1.2.840.113549.1.9.16.2.28":"Signature Type","1.2.840.113549.1.9.16.2.29":"Dvcs Dvc","1.2.840.113549.1.9.16.2.30":"Cek Reference","1.2.840.113549.1.9.16.2.31":"Max CEK Decrypts","1.2.840.113549.1.9.16.2.32":"Kek Derivation Alg","1.2.840.113549.1.9.16.2.33":"Intended Recipients","1.2.840.113549.1.9.16.2.34":"Cmc Unsigned Data","1.2.840.113549.1.9.16.2.35":"Fw Package ID","1.2.840.113549.1.9.16.2.36":"Fw Target Hardware IDs","1.2.840.113549.1.9.16.2.37":"Fw Decrypt Key ID","1.2.840.113549.1.9.16.2.38":"Fw Impl Crypt Algs","1.2.840.113549.1.9.16.2.39":"Fw Wrapped Firmware Key","1.2.840.113549.1.9.16.2.40":"Fw Community Identifiers","1.2.840.113549.1.9.16.2.41":"Fw Pkg Message Digest","1.2.840.113549.1.9.16.2.42":"Fw Package Info","1.2.840.113549.1.9.16.2.43":"Fw Impl Compress Algs","1.2.840.113549.1.9.16.2.44":"Ets Attr Certificate Refs","1.2.840.113549.1.9.16.2.45":"Ets Attr Revocation Refs","1.2.840.113549.1.9.16.2.46":"Binary Signing Time","1.2.840.113549.1.9.16.2.47":"Signing Certificate V2","1.2.840.113549.1.9.16.2.48":"Ets Archive Time Stamp V2","1.2.840.113549.1.9.16.2.49":"Er Internal","1.2.840.113549.1.9.16.2.50":"Er External","1.2.840.113549.1.9.16.2.51":"Multiple Signatures","1.2.840.113549.1.9.16.3.1":"Es DHwith3 DES","1.2.840.113549.1.9.16.3.2":"Es DHwith RC2","1.2.840.113549.1.9.16.3.3":"3des Wrap","1.2.840.113549.1.9.16.3.4":"Rc2 Wrap","1.2.840.113549.1.9.16.3.5":"Es DH","1.2.840.113549.1.9.16.3.6":"Cms3 DESwrap","1.2.840.113549.1.9.16.3.7":"Cms RC2wrap","1.2.840.113549.1.9.16.3.8":"Zlib","1.2.840.113549.1.9.16.3.9":"Pwri KEK","1.2.840.113549.1.9.16.3.10":"Ss DH","1.2.840.113549.1.9.16.3.11":"Hmac With3 DE Swrap","1.2.840.113549.1.9.16.3.12":"Hmac With AE Swrap","1.2.840.113549.1.9.16.3.13":"MD5 Xor Experiment","1.2.840.113549.1.9.16.3.14":"RSA KEM","1.2.840.113549.1.9.16.3.15":"Auth Enc128","1.2.840.113549.1.9.16.3.16":"Auth Enc256","1.2.840.113549.1.9.16.4.1":"Cert Dist-ldap","1.2.840.113549.1.9.16.5.1":"Sig Policy Qualifier-spuri x","1.2.840.113549.1.9.16.5.2":"Sig Policy Qualifier-sp User Notice","1.2.840.113549.1.9.16.6.1":"Proof Of Origin","1.2.840.113549.1.9.16.6.2":"Proof Of Receipt","1.2.840.113549.1.9.16.6.3":"Proof Of Delivery","1.2.840.113549.1.9.16.6.4":"Proof Of Sender","1.2.840.113549.1.9.16.6.5":"Proof Of Approval","1.2.840.113549.1.9.16.6.6":"Proof Of Creation","1.2.840.113549.1.9.16.8.1":"Gl Use KEK","1.2.840.113549.1.9.16.8.2":"Gl Delete","1.2.840.113549.1.9.16.8.3":"Gl Add Member","1.2.840.113549.1.9.16.8.4":"Gl Delete Member","1.2.840.113549.1.9.16.8.5":"Gl Rekey","1.2.840.113549.1.9.16.8.6":"Gl Add Owner","1.2.840.113549.1.9.16.8.7":"Gl Remove Owner","1.2.840.113549.1.9.16.8.8":"Glk Compromise","1.2.840.113549.1.9.16.8.9":"Glk Refresh","1.2.840.113549.1.9.16.8.10":"Gl Fail Info","1.2.840.113549.1.9.16.8.11":"Gla Query Request","1.2.840.113549.1.9.16.8.12":"Gla Query Response","1.2.840.113549.1.9.16.8.13":"Gl Provide Cert","1.2.840.113549.1.9.16.8.14":"Gl Update Cert","1.2.840.113549.1.9.16.8.15":"Gl Key","1.2.840.113549.1.9.16.9":"Signature Type Identifier","1.2.840.113549.1.9.16.9.1":"Originator Sig","1.2.840.113549.1.9.16.9.2":"Domain Sig","1.2.840.113549.1.9.16.9.3":"Additional Attributes Sig","1.2.840.113549.1.9.16.9.4":"Review Sig","1.2.840.113549.1.9.16.11":"Capabilities","1.2.840.113549.1.9.16.11.1":"Prefer Binary Inside","1.2.840.113549.1.9.20":"Friendly Name (for PKCS #12)","1.2.840.113549.1.9.21":"Local Key I D (for PKCS #12)","1.2.840.113549.1.9.22":"Cert Types (for PKCS #12)","1.2.840.113549.1.9.22.1":"x509 Certificate (for PKCS #12)","1.2.840.113549.1.9.22.2":"SDSI Certificate (for PKCS #12)","1.2.840.113549.1.9.23":"CRL Types (for PKCS #12)","1.2.840.113549.1.9.23.1":"x509 Crl (for PKCS #12)","1.2.840.113549.1.9.24":"PKCS9object Class","1.2.840.113549.1.9.25":"PKCS9attributes","1.2.840.113549.1.9.25.1":"PKCS15 Token","1.2.840.113549.1.9.25.2":"Encrypted Private Key Info","1.2.840.113549.1.9.25.3":"Random Nonce","1.2.840.113549.1.9.25.4":"Sequence Number","1.2.840.113549.1.9.25.5":"PKCS7 PDU","1.2.840.113549.1.9.26":"PKCS9syntax","1.2.840.113549.1.9.27":"PKCS9matching Rules","1.2.840.113549.1.12":"PKCS-12","1.2.840.113549.1.12.1":"PKCS-12- Pbe Ids#12 mode ID","1.2.840.113549.1.12.1.1":"PBE With SHA And128 Bit RC4","1.2.840.113549.1.12.1.2":"PBE With SHA And40 Bit RC4","1.2.840.113549.1.12.1.3":"PBE With SHA And3-Key Triple DES-CBC","1.2.840.113549.1.12.1.4":"PBE With SHA And2-Key Triple DES-CBC","1.2.840.113549.1.12.1.5":"PBE With SHA And128 Bit RC2-CBC","1.2.840.113549.1.12.1.6":"PBE With SHA And40 Bit RC2-CBC","1.2.840.113549.1.12.2":"PKCS-12-ESPVKID","1.2.840.113549.1.12.2.1":"PKCS-12-PKCS8 Key Shrouding(1284011354911235) instead","1.2.840.113549.1.12.3":"PKCS-12-Bag Ids","1.2.840.113549.1.12.3.1":"PKCS-12-key Bag Id","1.2.840.113549.1.12.3.2":"PKCS-12-cert And CRL Bag Id","1.2.840.113549.1.12.3.3":"PKCS-12-secret Bag Id","1.2.840.113549.1.12.3.4":"PKCS-12-safe Contents Id","1.2.840.113549.1.12.3.5":"PKCS-12-pkcs","1.2.840.113549.1.12.4":"PKCS-12-Cert Bag ID","1.2.840.113549.1.12.4.1":"PKCS-12-x509 Cert CRL Bag I Dformerly assigned as pkcs-12-x509 Cert CRL Bag","1.2.840.113549.1.12.4.2":"PKCS-12-SDSI Cert Bag I Dformerly assigned as pkcs-12-SDSI Cert Bag","1.2.840.113549.1.12.5":"PKCS-12-OID","1.2.840.113549.1.12.5.1":"PKCS-12-PBEI Dthe partially compatible (128401135491121) OIDs instead","1.2.840.113549.1.12.5.1.1":"PKCS-12-PBE With SHA1 And128 Bit RC4use (1284011354911211) instead","1.2.840.113549.1.12.5.1.2":"PKCS-12-PBE With SHA1 And40 Bit RC4use (1284011354911212) instead","1.2.840.113549.1.12.5.1.3":"PKCS-12-PBE With SHA1 And Triple DESCB Cuse the incompatible but similar (1284011354911213) or (1284011354911214) instead","1.2.840.113549.1.12.5.1.4":"PKCS-12-PBE With SHA1 And128 Bit RC2CB Cuse (1284011354911215) instead","1.2.840.113549.1.12.5.1.5":"PKCS-12-PBE With SHA1 And40 Bit RC2CB Cuse (1284011354911216) instead","1.2.840.113549.1.12.5.1.6":"PKCS-12-PBE With SHA1 And RC4use the incompatible but similar (1284011354911211) or (1284011354911212) instead","1.2.840.113549.1.12.5.1.7":"PKCS-12-PBE With SHA1 And RC2CB Cuse the incompatible but similar (1284011354911215) or (1284011354911216) instead","1.2.840.113549.1.12.5.2":"PKCS-12-Enveloping I Dthe conventional  PKCS#1OIDs instead","1.2.840.113549.1.12.5.2.1":"PKCS-12-RSA Encryption With128 Bit RC4use the conventional  PKCS#1OIDs instead","1.2.840.113549.1.12.5.2.2":"PKCS-12-RSA Encryption With40 Bit RC4use the conventional  PKCS#1OIDs instead","1.2.840.113549.1.12.5.2.3":"PKCS-12-RSA Encryption With Triple DESuse the conventional  PKCS#1OIDs instead","1.2.840.113549.1.12.5.3":"PKCS-12-Signature IDuse the conventional  PKCS#1OIDs instead","1.2.840.113549.1.12.5.3.1":"PKCS-12-RSA Signature With SHA1 Digestuse the conventional  PKCS#1OIDs instead","1.2.840.113549.1.12.10":"PKCS-12 Version1","1.2.840.113549.1.12.10.1":"PKCS-12 Bad Ids","1.2.840.113549.1.12.10.1.1":"PKCS-12-key Bag","1.2.840.113549.1.12.10.1.2":"PKCS-12-pkcs","1.2.840.113549.1.12.10.1.3":"PKCS-12-cert Bag","1.2.840.113549.1.12.10.1.4":"PKCS-12-crl Bag","1.2.840.113549.1.12.10.1.5":"PKCS-12-secret Bag","1.2.840.113549.1.12.10.1.6":"PKCS-12-safe Contents Bag","1.2.840.113549.1.15.1":"PKCS15modules","1.2.840.113549.1.15.2":"PKCS15attributes","1.2.840.113549.1.15.3":"PKCS15content Type","1.2.840.113549.1.15.3.1":"PKCS15content","1.2.840.113549.2":"Digest Algorithm","1.2.840.113549.2.2":"MD2","1.2.840.113549.2.4":"MD4","1.2.840.113549.2.5":"MD5","1.2.840.113549.2.7":"HMAC With SHA1","1.2.840.113549.2.8":"HMAC With SHA224","1.2.840.113549.2.9":"HMAC With SHA256","1.2.840.113549.2.10":"HMAC With SHA384","1.2.840.113549.2.11":"HMAC With SHA512","1.2.840.113549.3":"Encryption Algorithm","1.2.840.113549.3.2":"Rc2CBC","1.2.840.113549.3.3":"Rc2ECB","1.2.840.113549.3.4":"Rc4","1.2.840.113549.3.5":"Rc4 With MAC","1.2.840.113549.3.6":"Desx-CBC","1.2.840.113549.3.7":"Des-EDE3-CBC","1.2.840.113549.3.8":"Rc5CBC","1.2.840.113549.3.9":"Rc5-CBCPad","1.2.840.113549.3.10":"DesCDMF","1.2.840.113556.1.2.241":"Delivery Mechanism","1.2.840.113556.1.2.281":"Nt Security Descriptor","1.2.840.113556.1.3.0":"Site-Addressing","1.2.840.113556.1.3.13":"Class Schema","1.2.840.113556.1.3.14":"Attribute Schema","1.2.840.113556.1.3.17":"Mailbox- Agent","1.2.840.113556.1.3.22":"Mailbox","1.2.840.113556.1.3.23":"Container","1.2.840.113556.1.3.46":"Mail Recipient","1.2.840.113556.1.4.145":"Revision","1.2.840.113556.1.4.1327":"PKI Default Key Spec","1.2.840.113556.1.4.1328":"PKI Key Usage","1.2.840.113556.1.4.1329":"PKI Max Issuing Depth","1.2.840.113556.1.4.1330":"PKI Critical Extensions","1.2.840.113556.1.4.1331":"PKI Expiration Period","1.2.840.113556.1.4.1332":"PKI Overlap Period","1.2.840.113556.1.4.1333":"PKI Extended Key Usage","1.2.840.113556.1.4.1334":"PKI Default CSPs","1.2.840.113556.1.4.1335":"PKI Enrollment Access","1.2.840.113556.1.4.1429":"MsPKI-RA-Signature","1.2.840.113556.1.4.1430":"MsPKI-Enrollment-Flag","1.2.840.113556.1.4.1431":"MsPKI-Private-Key","1.2.840.113556.1.4.1432":"MsPKI-Certificate-Name","1.2.840.113556.1.4.1433":"MsPKI-Minimal-Key","1.2.840.113556.1.4.1434":"MsPKI-Template-Schema","1.2.840.113556.1.4.1435":"MsPKI-Template-Minor","1.2.840.113556.1.4.1436":"MsPKI-Cert-Template","1.2.840.113556.1.4.1437":"MsPKI-Supersede-Templates","1.2.840.113556.1.4.1438":"MsPKI-RA-Policies","1.2.840.113556.1.4.1439":"MsPKI-Certificate-Policy","1.2.840.113556.1.4.1674":"MsPKI-Certificate-Application","1.2.840.113556.1.4.1675":"MsPKI-R A- Application","1.2.840.113556.4.3":"Microsoft Excel","1.2.840.113556.4.4":"Titled With OID","1.2.840.113556.4.5":"Microsoft Power Point","1.2.840.113583.1":"Adobe Acrobat","1.2.840.113583.1.1":"Acrobat Security","1.2.840.113583.1.1.1":"PDF Password","1.2.840.113583.1.1.2":"PDF Default Signing Credential","1.2.840.113583.1.1.3":"PDF Default Encryption Credential","1.2.840.113583.1.1.4":"PDF Password Timeout","1.2.840.113583.1.1.5":"PDF Authentic Documents Trust","1.2.840.113583.1.1.6":"PDF Dynamic Content Trust","1.2.840.113583.1.1.7":"PDF Ubiquity Trust","1.2.840.113583.1.1.8":"PDF Revocation Info Archival","1.2.840.113583.1.1.9":"PDF x509 Extension","1.2.840.113583.1.1.9.1":"PDF Time Stamp","1.2.840.113583.1.1.9.2":"PDF Archive Rev Info","1.2.840.113583.1.1.10":"PDF PPLK Lite Credential","1.2.840.113583.1.2.":"Acrobat CPS","1.2.840.113583.1.2.1":"PDF Authentic Documents CPS","1.2.840.113583.1.2.2":"PDF Test CPS","1.2.840.113583.1.2.3":"PDF Ubiquity CPS","1.2.840.113583.1.2.4":"PDF Adhoc CPS","1.2.840.113583.1.7":"Acrobat Ubiquity","1.2.840.113583.1.7.1":"PDF Ubiquity Sub Rights","1.2.840.113583.1.9":"Acrobat Extension","1.2.840.113628.114.1.7":"Adobe PKCS7","1.2.840.113635.100":"Apple Data Security","1.2.840.113635.100.1":"Apple Trust Policy","1.2.840.113635.100.1.1":"Apple I Sign TP","1.2.840.113635.100.1.2":"Apple x509 Basic","1.2.840.113635.100.1.3":"Apple SSL Policy","1.2.840.113635.100.1.4":"Apple Local Cert Gen Policy","1.2.840.113635.100.1.5":"Apple CSR Gen Policy","1.2.840.113635.100.1.6":"Apple CRL Policy","1.2.840.113635.100.1.7":"Apple OCSP Policy","1.2.840.113635.100.1.8":"Apple SMIME Policy","1.2.840.113635.100.1.9":"Apple EAP Policy","1.2.840.113635.100.1.10":"Apple SW Update Signing Policy","1.2.840.113635.100.1.11":"Apple IPSec Policy","1.2.840.113635.100.1.12":"Apple IChat Policy","1.2.840.113635.100.1.13":"Apple Resource Sign Policy","1.2.840.113635.100.1.14":"Apple PKINIT Client Policy","1.2.840.113635.100.1.15":"Apple PKINIT Server Policy","1.2.840.113635.100.1.16":"Apple Code Signing Policy","1.2.840.113635.100.1.17":"Apple Package Signing Policy","1.2.840.113635.100.2":"Apple Security Algorithm","1.2.840.113635.100.2.1":"Apple FEE","1.2.840.113635.100.2.2":"Apple ASC","1.2.840.113635.100.2.3":"Apple FEE_MD5","1.2.840.113635.100.2.4":"Apple FEE_SHA1","1.2.840.113635.100.2.5":"Apple FEED","1.2.840.113635.100.2.6":"Apple FEEDEXP","1.2.840.113635.100.2.7":"Apple ECDSA","1.2.840.113635.100.3":"Apple Dot Mac Certificate","1.2.840.113635.100.3.1":"Apple Dot Mac Certificate Request","1.2.840.113635.100.3.2":"Apple Dot Mac Certificate Extension","1.2.840.113635.100.3.3":"Apple Dot Mac Certificate Request Values","1.2.840.113635.100.4":"Apple Extended Key Usage","1.2.840.113635.100.4.1":"Apple Code Signing","1.2.840.113635.100.4.1.1":"Apple Code Signing Development","1.2.840.113635.100.4.1.2":"Apple Software Update Signing","1.2.840.113635.100.4.1.3":"Apple Code Signing Third Party","1.2.840.113635.100.4.1.4":"Apple Resource Signing","1.2.840.113635.100.4.2":"Apple I Chat Signing","1.2.840.113635.100.4.3":"Apple I Chat Encryption","1.2.840.113635.100.4.4":"Apple System Identity","1.2.840.113635.100.4.5":"Apple Crypto Env","1.2.840.113635.100.4.5.1":"Apple Crypto Production Env","1.2.840.113635.100.4.5.2":"Apple Crypto Maintenance Env","1.2.840.113635.100.4.5.3":"Apple Crypto Test Env","1.2.840.113635.100.4.5.4":"Apple Crypto Development Env","1.2.840.113635.100.4.6":"Apple Crypto Qo S","1.2.840.113635.100.4.6.1":"Apple Crypto Tier0 QoS","1.2.840.113635.100.4.6.2":"Apple Crypto Tier1 QoS","1.2.840.113635.100.4.6.3":"Apple Crypto Tier2 QoS","1.2.840.113635.100.4.6.4":"Apple Crypto Tier3 QoS","1.2.840.113635.100.4.7":"Apple ID Sharing Certificate","1.2.840.113635.100.5":"Apple Certificate Policies","1.2.840.113635.100.5.1":"Apple Certificate Policy ID","1.2.840.113635.100.5.2":"Apple Dot Mac Certificate Policy ID","1.2.840.113635.100.5.3":"Apple ADC Certificate Policy ID","1.2.840.113635.100.6":"Apple Certificate Extensions","1.2.840.113635.100.6.1":"Apple Certificate Extension Code Signing","1.2.840.113635.100.6.1.1":"Apple Certificate Extension Apple Signing","1.2.840.113635.100.6.1.2":"Apple Certificate Extension ADC Developer Signing","1.2.840.113635.100.6.1.3":"Apple Certificate Extension ADC Apple Signing","1.2.840.114021.1.6.1":"Identrus unknown policy Identifier","1.2.840.114021.4.1":"Identrus OCSP","1.3.6.1.4.1.188.7.1.1":"Ascom","1.3.6.1.4.1.188.7.1.1.1":"Idea ECB","1.3.6.1.4.1.188.7.1.1.2":"Idea CBC","1.3.6.1.4.1.188.7.1.1.3":"Idea CFB","1.3.6.1.4.1.188.7.1.1.4":"Idea OFB","1.3.6.1.4.1.311.2.1.4":"Spc Indirect Data Context","1.3.6.1.4.1.311.2.1.10":"Spc Agency Info","1.3.6.1.4.1.311.2.1.11":"Spc Statement Type","1.3.6.1.4.1.311.2.1.12":"Spc Sp Opus Info","1.3.6.1.4.1.311.2.1.14":"Cert Req Extensions","1.3.6.1.4.1.311.2.1.15":"Spc P E Image Data","1.3.6.1.4.1.311.2.1.18":"Spc Raw File Data","1.3.6.1.4.1.311.2.1.19":"Spc Structured Storage Data","1.3.6.1.4.1.311.2.1.20":"Spc Java ClassData (type 1extension',aka 'Glue extension)","1.3.6.1.4.1.311.2.1.21":"Individual Code Signing","1.3.6.1.4.1.311.2.1.22":"Commercial Code Signing","1.3.6.1.4.1.311.2.1.25":"Spc Link (type 2as 'Glue extension)","1.3.6.1.4.1.311.2.1.26":"Spc Minimal Criteria Info","1.3.6.1.4.1.311.2.1.27":"Spc Financial Criteria Info","1.3.6.1.4.1.311.2.1.28":"SpcLink (type 3as 'Glue extension)","1.3.6.1.4.1.311.2.1.29":"Spc Hash Info Obj ID","1.3.6.1.4.1.311.2.1.30":"Spc Sip Info Obj ID","1.3.6.1.4.1.311.2.2":"Ctl","1.3.6.1.4.1.311.2.2.1":"Ctl Trusted Codesigning CAList","1.3.6.1.4.1.311.2.2.2":"Ctl Trusted Client Auth CAList","1.3.6.1.4.1.311.2.2.3":"Ctl Trusted Server Auth CAList","1.3.6.1.4.1.311.3.2.1":"Timestamp Request","1.3.6.1.4.1.311.10.1":"Cert Trust List","1.3.6.1.4.1.311.10.1.1":"Sorted Ctl","1.3.6.1.4.1.311.10.2":"Next Update Location","1.3.6.1.4.1.311.10.3.1":"Cert Trust List Signing","1.3.6.1.4.1.311.10.3.2":"Time Stamp Signing","1.3.6.1.4.1.311.10.3.3":"Server Gated Crypto","1.3.6.1.4.1.311.10.3.3.1":"Serialized","1.3.6.1.4.1.311.10.3.4":"Encrypted File System","1.3.6.1.4.1.311.10.3.4.1":"Efs Recovery","1.3.6.1.4.1.311.10.3.5":"Whql Crypto","1.3.6.1.4.1.311.10.3.6":"Nt5 Crypto","1.3.6.1.4.1.311.10.3.7":"Oem WHQL Crypto","1.3.6.1.4.1.311.10.3.8":"Embedded NT Crypto","1.3.6.1.4.1.311.10.3.9":"Root List Signer","1.3.6.1.4.1.311.10.3.10":"Qualified Subordination","1.3.6.1.4.1.311.10.3.11":"Key Recovery","1.3.6.1.4.1.311.10.3.12":"Document Signing","1.3.6.1.4.1.311.10.3.13":"Lifetime Signing","1.3.6.1.4.1.311.10.3.14":"Mobile Device Software","1.3.6.1.4.1.311.10.3.15":"Smart Display","1.3.6.1.4.1.311.10.3.16":"Csp Signature","1.3.6.1.4.1.311.10.4.1":"yesno Trust Attr","1.3.6.1.4.1.311.10.5.1":"Drm","1.3.6.1.4.1.311.10.5.2":"Drm Individualization","1.3.6.1.4.1.311.10.6.1":"Licenses","1.3.6.1.4.1.311.10.6.2":"License Server","1.3.6.1.4.1.311.10.7.1":"Keyid Rdn","1.3.6.1.4.1.311.10.8.1":"Remove Certificate","1.3.6.1.4.1.311.10.9.1":"Cross Cert Dist Points","1.3.6.1.4.1.311.10.10.1":"Cmc Add Attributes","1.3.6.1.4.1.311.10.11":"Cert Prop Id Prefix","1.3.6.1.4.1.311.10.11.4":"Cert Md5 Hash Prop Id","1.3.6.1.4.1.311.10.11.20":"Cert Key Identifier Prop Id","1.3.6.1.4.1.311.10.11.28":"Cert Issuer Serial Number Md5 Hash Prop Id","1.3.6.1.4.1.311.10.11.29":"Cert Subject Name MD5 Hash Prop Id","1.3.6.1.4.1.311.10.12.1":"Any Application Policy","1.3.6.1.4.1.311.12":"Catalog","1.3.6.1.4.1.311.12.1.1":"Catalog List","1.3.6.1.4.1.311.12.1.2":"Catalog List Member","1.3.6.1.4.1.311.12.2.1":"Catalog Name Value Obj ID","1.3.6.1.4.1.311.12.2.2":"Catalog Member Info Obj ID","1.3.6.1.4.1.311.13.1":"Renewal Certificate","1.3.6.1.4.1.311.13.2.1":"Enrolment Name Value Pair","1.3.6.1.4.1.311.13.2.2":"Enrolment CSP","1.3.6.1.4.1.311.13.2.3":"Os Version","1.3.6.1.4.1.311.16.4":"Microsoft Recipient Info","1.3.6.1.4.1.311.17.1":"PKCS12 Key Provider Name Attr","1.3.6.1.4.1.311.17.2":"Local Machine Keyset","1.3.6.1.4.1.311.17.3":"PKCS12 Extended Attributes","1.3.6.1.4.1.311.20.1":"Auto Enroll Ctl Usage","1.3.6.1.4.1.311.20.2":"Enroll Certtype Extension","1.3.6.1.4.1.311.20.2.1":"Enrollment Agent","1.3.6.1.4.1.311.20.2.2":"Smartcard Logon","1.3.6.1.4.1.311.20.2.3":"Universal Principal Name","1.3.6.1.4.1.311.20.3":"Cert Manifold","1.3.6.1.4.1.311.21.1":"CA Key Cert Index Pair","1.3.6.1.4.1.311.21.2":"Cert Srv Previous Cert Hash","1.3.6.1.4.1.311.21.3":"CRL Virtual Base","1.3.6.1.4.1.311.21.4":"CRL Next Publish","1.3.6.1.4.1.311.21.5":"Ca Exchange","1.3.6.1.4.1.311.21.6":"Key Recovery","1.3.6.1.4.1.311.21.7":"Certificate Template","1.3.6.1.4.1.311.21.8":"Enterprize OID Root","1.3.6.1.4.1.311.21.9":"Rdn Dummy Signer","1.3.6.1.4.1.311.21.10":"Application Cert Policies","1.3.6.1.4.1.311.21.11":"Application Policy Mappings","1.3.6.1.4.1.311.21.12":"Application Policy Constraints","1.3.6.1.4.1.311.21.13":"Archived Key","1.3.6.1.4.1.311.21.14":"CRL Self CDP","1.3.6.1.4.1.311.21.15":"Require Cert Chain Policy","1.3.6.1.4.1.311.21.16":"Archived Key Cert Hash","1.3.6.1.4.1.311.21.17":"Issued Cert Hash","1.3.6.1.4.1.311.21.19":"DS Email Replication","1.3.6.1.4.1.311.21.20":"Request Client Info","1.3.6.1.4.1.311.21.21":"Encrypted Key Hash","1.3.6.1.4.1.311.21.22":"Certsrv Cross CA Version","1.3.6.1.4.1.311.25.1":"Ntds Replication","1.3.6.1.4.1.311.31.1":"Product Update","1.3.6.1.4.1.311.47.1.1":"System Health","1.3.6.1.4.1.311.47.1.3":"System Health Loophole","1.3.6.1.4.1.311.60.1.1":"Root Program Flags","1.3.6.1.4.1.311.60.2.1.1":"Jurisdiction Of Incorporation L","1.3.6.1.4.1.311.60.2.1.2":"Jurisdiction Of Incorporation SP","1.3.6.1.4.1.311.60.2.1.3":"Jurisdiction Of Incorporation C","1.3.6.1.4.1.311.61.1.1":"Kernel Mode Code Signing","1.3.6.1.4.1.311.88":"Capi Com","1.3.6.1.4.1.311.88.1":"Capi Com Version","1.3.6.1.4.1.311.88.2":"Capi Com Attribute","1.3.6.1.4.1.311.88.2.1":"Capi Com Document Name","1.3.6.1.4.1.311.88.2.2":"Capi Com Document Description","1.3.6.1.4.1.311.88.3":"Capi Com Encrypted Data","1.3.6.1.4.1.311.88.3.1":"Capi Com Encrypted Content","1.3.6.1.4.1.782.1.2.1.8.1":"Network  Solutions  EV policy","1.3.6.1.4.1.2428.10.1.1":"UNINETT policy Identifier","1.3.6.1.4.1.2712.10":"ICE-TEL policy Identifier","1.3.6.1.4.1.2786.1.1.1":"ICE-TEL  Italian","1.3.6.1.4.1.3029.1.1.1":"Blowfish ECB","1.3.6.1.4.1.3029.1.1.2":"Blowfish CBC","1.3.6.1.4.1.3029.1.1.3":"Blowfish CFB","1.3.6.1.4.1.3029.1.1.4":"Blowfish OFB","1.3.6.1.4.1.3029.1.2.1":"Elgamal","1.3.6.1.4.1.3029.1.2.1.1":"Elgamal With SHA-1","1.3.6.1.4.1.3029.1.2.1.2":"Elgamal With RIPEMD-160","1.3.6.1.4.1.3029.3.1.1":"Cryptlib Presence Check","1.3.6.1.4.1.3029.3.1.2":"Pki Boot","1.3.6.1.4.1.3029.3.1.4":"CRL Ext Reason","1.3.6.1.4.1.3029.3.1.5":"Key Features","1.3.6.1.4.1.3029.4.1":"Cryptlib Content","1.3.6.1.4.1.3029.4.1.1":"Cryptlib Config Data","1.3.6.1.4.1.3029.4.1.2":"Cryptlib User Index","1.3.6.1.4.1.3029.4.1.3":"Cryptlib User Info","1.3.6.1.4.1.3029.4.1.4":"Rtcs Request","1.3.6.1.4.1.3029.4.1.5":"Rtcs Response","1.3.6.1.4.1.3029.4.1.6":"Rtcs Response Ext","1.3.6.1.4.1.3029.42.11172.1":"Mpeg-1","1.3.6.1.4.1.3029.54.11940.54":"TSA policy 'Anythingpolicy","1.3.6.1.4.1.3029.88.89.90.90.89":"XYZZY policy Identifier","1.3.6.1.4.1.3401.8.1.1":"Pgp Extension","1.3.6.1.4.1.3576.7":"Ecia Asc X12 Edi","1.3.6.1.4.1.3576.7.1":"Plain ED Imessage","1.3.6.1.4.1.3576.7.2":"Signed ED Imessage","1.3.6.1.4.1.3576.7.5":"Integrity ED Imessage","1.3.6.1.4.1.3576.7.65":"Ia Receipt Message","1.3.6.1.4.1.3576.7.97":"Ia Status Message","1.3.6.1.4.1.3576.8":"Ecia Edifact","1.3.6.1.4.1.3576.9":"Ecia Non Edi","1.3.6.1.4.1.4146":"Globalsign","1.3.6.1.4.1.4146.1":"Globalsign Policy","1.3.6.1.4.1.4146.1.1":"Global Sign  EV policy","1.3.6.1.4.1.4146.1.10":"Globalsign DV Policy","1.3.6.1.4.1.4146.1.20":"Globalsign OV Policy","1.3.6.1.4.1.4146.1.30":"Globalsign TSA Policy","1.3.6.1.4.1.4146.1.40":"Globalsign Client Cert Policy","1.3.6.1.4.1.4146.1.50":"Globalsign Code Sign Policy","1.3.6.1.4.1.4146.1.60":"Globalsign Root Sign Policy","1.3.6.1.4.1.4146.1.70":"Globalsign Trusted Root Policy","1.3.6.1.4.1.4146.1.80":"Globalsign EDI Client Policy","1.3.6.1.4.1.4146.1.81":"Globalsign EDI Server Policy","1.3.6.1.4.1.4146.1.90":"Globalsign TPM Root Policy","1.3.6.1.4.1.4146.1.95":"Globalsign OCSP Policy","1.3.6.1.4.1.4788.2.202.1":"D-TRUSTEV policy","1.3.6.1.4.1.5309.1":"Edel Web Policy","1.3.6.1.4.1.5309.1.2":"Edel Web Customer Policy","1.3.6.1.4.1.5309.1.2.1":"Edel Web Clepsydre Policy","1.3.6.1.4.1.5309.1.2.2":"Edel Web Experimental TSA Policy","1.3.6.1.4.1.5309.1.2.3":"Edel Web Open Evidence TSA Policy","1.3.6.1.4.1.5472":"Timeproof","1.3.6.1.4.1.5472.1":"TSS","1.3.6.1.4.1.5472.1.1":"TSS80","1.3.6.1.4.1.5472.1.2":"TSS380","1.3.6.1.4.1.5472.1.3":"TSS400","1.3.6.1.4.1.5770.0.3":"Secondary Practices","1.3.6.1.4.1.5770.0.4":"Physician Identifiers","1.3.6.1.4.1.6334.1.100.1":"Cybertrust  EV policy","1.3.6.1.4.1.6449.1.2.1.3.1":"Comodo Policy","1.3.6.1.4.1.6449.1.2.1.5.1":"Comodo  EV policy","1.3.6.1.4.1.6449.1.2.2.15":"Wotrust Policy","1.3.6.1.4.1.6449.1.3.5.2":"Comodo Certified Delivery Service","1.3.6.1.4.1.6449.2.1.1":"Comodo Timestamping Policy","1.3.6.1.4.1.7879.13.24.1":"T-Tele Sec  EV policy","1.3.6.1.4.1.8024.0.2.100.1.2":"Quo Vadis  EV policy","1.3.6.1.4.1.8231.1":"Rol Unico Nacional","1.3.6.1.4.1.8301.3.5.1":"alidity Model Chain","1.3.6.1.4.1.8301.3.5.2":"alidity Model Shell","1.3.6.1.4.1.11129.2.4.2":"Certificate Transparency","1.3.6.1.4.1.11591":"Gnu","1.3.6.1.4.1.11591.1":"Gnu Radius","1.3.6.1.4.1.11591.3":"Gnu Radar","1.3.6.1.4.1.11591.12":"Gnu Digest Algorithm","1.3.6.1.4.1.11591.12.2":"Tiger","1.3.6.1.4.1.11591.13":"Gnu Encryption Algorithm","1.3.6.1.4.1.11591.13.2":"Serpent","1.3.6.1.4.1.11591.13.2.1":"Serpent128_ECB","1.3.6.1.4.1.11591.13.2.2":"Serpent128_CBC","1.3.6.1.4.1.11591.13.2.3":"Serpent128_OFB","1.3.6.1.4.1.11591.13.2.4":"Serpent128_CFB","1.3.6.1.4.1.11591.13.2.21":"Serpent192_ECB","1.3.6.1.4.1.11591.13.2.22":"Serpent192_CBC","1.3.6.1.4.1.11591.13.2.23":"Serpent192_OFB","1.3.6.1.4.1.11591.13.2.24":"Serpent192_CFB","1.3.6.1.4.1.11591.13.2.41":"Serpent256_ECB","1.3.6.1.4.1.11591.13.2.42":"Serpent256_CBC","1.3.6.1.4.1.11591.13.2.43":"Serpent256_OFB","1.3.6.1.4.1.11591.13.2.44":"Serpent256_CFB","1.3.6.1.4.1.14370.1.6":"Geo Trust EV policy","1.3.6.1.4.1.14777.6.1.1":"Izenpe EV policy","1.3.6.1.4.1.14777.6.1.2":"Izenpe EV policy","1.3.6.1.4.1.16334.509.1.1":"Northrop Grumman ext Key Usage?","1.3.6.1.4.1.16334.509.2.1":"Ngc Class1","1.3.6.1.4.1.16334.509.2.2":"Ngc Class2","1.3.6.1.4.1.16334.509.2.3":"Ngc Class3","1.3.6.1.4.1.17326.10.8.12.1.2":"Camerfirma EV policy","1.3.6.1.4.1.17326.10.14.2.1.2":"Camerfirma EV policy","1.3.6.1.4.1.22234.2.5.2.3.1":"Cert Plus EV policy","1.3.6.1.4.1.23223.1.1.1":"Start Com EV policy","1.3.6.1.4.1.23629.1.4.2.1.1":"Safenet Usage Limit","1.3.6.1.4.1.23629.1.4.2.1.2":"Safenet End Date","1.3.6.1.4.1.23629.1.4.2.1.3":"Safenet Start Date","1.3.6.1.4.1.23629.1.4.2.1.4":"Safenet Admin Cert","1.3.6.1.4.1.23629.1.4.2.2.1":"Safenet Key Digest","1.3.6.1.4.1.34697.2.1":"Affirm Trust EV policy","1.3.6.1.4.1.34697.2.2":"Affirm Trust EV policy","1.3.6.1.4.1.34697.2.3":"Affirm Trust EV policy","1.3.6.1.4.1.34697.2.4":"Affirm Trust EV policy","1.3.6.1.4.1.40869.1.1.22.3":"TWCAEV policy","1.3.6.1.5.5.7":"PKIX","1.3.6.1.5.5.7.0.12":"Attribute Cert","1.3.6.1.5.5.7.1":"Private Extension","1.3.6.1.5.5.7.1.1":"Certificate Authority Information Access","1.3.6.1.5.5.7.1.2":"Biometric Info","1.3.6.1.5.5.7.1.3":"Qualified Certificate Statements","1.3.6.1.5.5.7.1.4":"Ac Audit Identity","1.3.6.1.5.5.7.1.5":"Ac Targeting","1.3.6.1.5.5.7.1.6":"Ac Aa Controls","1.3.6.1.5.5.7.1.7":"Ip Addr Blocks","1.3.6.1.5.5.7.1.8":"Autonomous Sys Ids","1.3.6.1.5.5.7.1.9":"Router Identifier","1.3.6.1.5.5.7.1.10":"Ac Proxying","1.3.6.1.5.5.7.1.11":"Subject Info Access","1.3.6.1.5.5.7.1.12":"Logo Type","1.3.6.1.5.5.7.1.13":"Wlan SSID","1.3.6.1.5.5.7.2":"Policy Qualifier Ids","1.3.6.1.5.5.7.2.1":"CPS","1.3.6.1.5.5.7.2.2":"Unotice","1.3.6.1.5.5.7.2.3":"Text Notice","1.3.6.1.5.5.7.3":"Key Purpose","1.3.6.1.5.5.7.3.1":"Server Authentication","1.3.6.1.5.5.7.3.2":"Client Authentication","1.3.6.1.5.5.7.3.3":"Code Signing","1.3.6.1.5.5.7.3.4":"Email Protection","1.3.6.1.5.5.7.3.5":"Ipsec End System","1.3.6.1.5.5.7.3.6":"Ipsec Tunnel","1.3.6.1.5.5.7.3.7":"Ipsec User","1.3.6.1.5.5.7.3.8":"Time Stamping","1.3.6.1.5.5.7.3.9":"OCSP Signing","1.3.6.1.5.5.7.3.10":"DVCS","1.3.6.1.5.5.7.3.11":"Sbgp Cert AA Server Auth","1.3.6.1.5.5.7.3.13":"Eap Over PPP","1.3.6.1.5.5.7.3.14":"Eap Over LAN","1.3.6.1.5.5.7.4":"Cmp Information Types","1.3.6.1.5.5.7.4.1":"Ca Prot Enc Cert","1.3.6.1.5.5.7.4.2":"Sign Key Pair Types","1.3.6.1.5.5.7.4.3":"Enc Key Pair Types","1.3.6.1.5.5.7.4.4":"Preferred Symm Alg","1.3.6.1.5.5.7.4.5":"CA Key Update Info","1.3.6.1.5.5.7.4.6":"Current CRL","1.3.6.1.5.5.7.4.7":"Unsupported OIDs","1.3.6.1.5.5.7.4.10":"Key Pair Param Req","1.3.6.1.5.5.7.4.11":"Key Pair Param Rep","1.3.6.1.5.5.7.4.12":"Rev Passphrase","1.3.6.1.5.5.7.4.13":"Implicit Confirm","1.3.6.1.5.5.7.4.14":"Confirm Wait Time","1.3.6.1.5.5.7.4.15":"Orig PKI Message","1.3.6.1.5.5.7.4.16":"Supp Lang Tags","1.3.6.1.5.5.7.5":"Crmf Registration","1.3.6.1.5.5.7.5.1":"Reg Ctrl","1.3.6.1.5.5.7.5.1.1":"Reg Token","1.3.6.1.5.5.7.5.1.2":"Authenticator","1.3.6.1.5.5.7.5.1.3":"Pki Publication Info","1.3.6.1.5.5.7.5.1.4":"Pki Archive Options","1.3.6.1.5.5.7.5.1.5":"Old Cert ID","1.3.6.1.5.5.7.5.1.6":"Protocol Encr Key","1.3.6.1.5.5.7.5.1.7":"Alt Cert Template","1.3.6.1.5.5.7.5.1.8":"Wtls Template","1.3.6.1.5.5.7.5.2":"Utf8 Pairs","1.3.6.1.5.5.7.5.2.1":"Utf8 Pairs","1.3.6.1.5.5.7.5.2.2":"Cert Req","1.3.6.1.5.5.7.6":"Algorithms","1.3.6.1.5.5.7.6.1":"Des40","1.3.6.1.5.5.7.6.2":"No Signature","1.3.6.1.5.5.7.6.3":"Dh-sig-hmac","1.3.6.1.5.5.7.6.4":"Dh-pop","1.3.6.1.5.5.7.7":"CMC Controls","1.3.6.1.5.5.7.8":"Other Names","1.3.6.1.5.5.7.8.1":"Personal Data","1.3.6.1.5.5.7.8.2":"User Group","1.3.6.1.5.5.7.8.5":"Xmpp Addr","1.3.6.1.5.5.7.9":"Personal Data","1.3.6.1.5.5.7.9.1":"Date Of Birth","1.3.6.1.5.5.7.9.2":"Place Of Birth","1.3.6.1.5.5.7.9.3":"Gender","1.3.6.1.5.5.7.9.4":"Country Of Citizenship","1.3.6.1.5.5.7.9.5":"Country Of Residence","1.3.6.1.5.5.7.10":"Attribute Certificate","1.3.6.1.5.5.7.10.1":"Authentication Info","1.3.6.1.5.5.7.10.2":"Access Identity","1.3.6.1.5.5.7.10.3":"Charging Identity","1.3.6.1.5.5.7.10.4":"Group","1.3.6.1.5.5.7.10.5":"Role","1.3.6.1.5.5.7.10.6":"Wlan SSID","1.3.6.1.5.5.7.11":"Personal Data","1.3.6.1.5.5.7.11.1":"Pkix Q C Syntax-v1","1.3.6.1.5.5.7.14.2":"Resource Certificate Policy","1.3.6.1.5.5.7.20":"Logo","1.3.6.1.5.5.7.20.1":"Logo Loyalty","1.3.6.1.5.5.7.20.2":"Logo Background","1.3.6.1.5.5.7.48.1":"OCSP","1.3.6.1.5.5.7.48.1.1":"OCSP Basic","1.3.6.1.5.5.7.48.1.2":"OCSP Nonce","1.3.6.1.5.5.7.48.1.3":"OCSP CRL","1.3.6.1.5.5.7.48.1.4":"OCSP Response","1.3.6.1.5.5.7.48.1.5":"OCSP No Check","1.3.6.1.5.5.7.48.1.6":"OCSP Archive Cutoff","1.3.6.1.5.5.7.48.1.7":"OCSP Service Locator","1.3.6.1.5.5.7.48.2":"CA Issuers","1.3.6.1.5.5.7.48.3":"Time Stamping","1.3.6.1.5.5.7.48.4":"DVCS","1.3.6.1.5.5.7.48.5":"CA Repository","1.3.6.1.5.5.7.48.7":"Signed Object Repository","1.3.6.1.5.5.7.48.10":"Rpki Manifest","1.3.6.1.5.5.7.48.11":"Signed Object","1.3.6.1.5.5.8.1.1":"HMAC MD5","1.3.6.1.5.5.8.1.2":"HMAC SHA","1.3.6.1.5.5.8.1.3":"HMAC Tiger","1.3.6.1.5.5.8.2.2":"IKE Intermediate","1.3.12.2.1011.7.1":"DEC Encryption Algorithm","1.3.12.2.1011.7.1.2":"DEC DEA","1.3.12.2.1011.7.2":"DEC Hash Algorithm","1.3.12.2.1011.7.2.1":"DECMD2","1.3.12.2.1011.7.2.2":"DECMD4","1.3.12.2.1011.7.3":"DEC Signature Algorithm","1.3.12.2.1011.7.3.1":"DEC MD2 With RSA","1.3.12.2.1011.7.3.2":"DEC MD4 With RSA","1.3.12.2.1011.7.3.3":"DEC DEAMAC","1.3.14.2.26.5":"SHA","1.3.14.3.2.1.1":"RSA","1.3.14.3.2.2":"MD4 With RSA","1.3.14.3.2.2.1":"Sqmod-N","1.3.14.3.2.3":"MD5 With RSA","1.3.14.3.2.3.1":"Sqmod-Nwith RSA","1.3.14.3.2.4":"MD4 With RSA Encryption","1.3.14.3.2.6":"DES ECB","1.3.14.3.2.7":"DES CBC","1.3.14.3.2.8":"DES OFB","1.3.14.3.2.9":"DES CFB","1.3.14.3.2.10":"DES MAC","1.3.14.3.2.11":"RSA Signature","1.3.14.3.2.12":"DSA","1.3.14.3.2.13":"DSA With SHA","1.3.14.3.2.14":"MDC2 With RSA Signature","1.3.14.3.2.15":"SHA With RSA Signature","1.3.14.3.2.16":"DH With Common Modulus","1.3.14.3.2.17":"Des EDE","1.3.14.3.2.18":"SHA","1.3.14.3.2.19":"MDC-2","1.3.14.3.2.20":"DSA Common","1.3.14.3.2.21":"DSA Common With SHA","1.3.14.3.2.22":"RSA Key Transport","1.3.14.3.2.23":"Keyed-hash-seal","1.3.14.3.2.24":"MD2 With RSA Signature","1.3.14.3.2.25":"MD5 With RSA Signature","1.3.14.3.2.26":"SHA1","1.3.14.3.2.27":"DSA With SHA1","1.3.14.3.2.28":"DSA With Common SHA1","1.3.14.3.2.29":"SHA-1 With RSA Encryption","1.3.14.3.3.1":"Simple-strong-auth","1.3.14.7.2.1.1":"El Gamal","1.3.14.7.2.3.1":"MD2 With RSA","1.3.14.7.2.3.2":"MD2 With El Gamal","1.3.36.1":"Document","1.3.36.1.1":"Final Version","1.3.36.1.2":"Draft","1.3.36.2":"Sio","1.3.36.2.1":"Sedu","1.3.36.3":"Algorithm","1.3.36.3.1":"Encryption Algorithm","1.3.36.3.1.1":"DES","1.3.36.3.1.1.1":"DES ECB_pad","1.3.36.3.1.1.1.1":"DES ECB_ISOpad","1.3.36.3.1.1.2.1":"DES CBC_pad","1.3.36.3.1.1.2.1.1":"DES CBC_ISOpad","1.3.36.3.1.2":"IDEA","1.3.36.3.1.2.1":"IDEA ECB","1.3.36.3.1.2.1.1":"IDEA ECB_pad","1.3.36.3.1.2.1.1.1":"IDEA ECB_ISOpad","1.3.36.3.1.2.2":"IDEA CBC","1.3.36.3.1.2.2.1":"IDEA CBC_pad","1.3.36.3.1.2.2.1.1":"IDEA CBC_ISOpad","1.3.36.3.1.2.3":"IDEA OFB","1.3.36.3.1.2.4":"IDEA CFB","1.3.36.3.1.3":"DES_3","1.3.36.3.1.3.1.1":"DES_3 ECB_pad","1.3.36.3.1.3.1.1.1":"DES_3 ECB_ISOpad","1.3.36.3.1.3.2.1":"DES_3 CBC_pad","1.3.36.3.1.3.2.1.1":"DES_3 CBC_ISOpad","1.3.36.3.1.4":"RSA Encryption","1.3.36.3.1.4.512.17":"RSA Encryption Withlmod512expe17","1.3.36.3.1.5":"BSI-1","1.3.36.3.1.5.1":"BSI_1 ECB_pad","1.3.36.3.1.5.2":"BSI_1 CBC_pad","1.3.36.3.1.5.2.1":"BSI_1 CBC_PEMpad","1.3.36.3.2":"Hash Algorithm","1.3.36.3.2.1":"Ripemd160","1.3.36.3.2.2":"Ripemd128","1.3.36.3.2.3":"Ripemd256","1.3.36.3.2.4":"Mdc2single Length","1.3.36.3.2.5":"Mdc2double Length","1.3.36.3.3":"Signature Algorithm","1.3.36.3.3.1":"RSA Signature","1.3.36.3.3.1.1":"RSA Signature WithSHA1","1.3.36.3.3.1.1.1024.11":"RSA Signature WithSHA1_l1024_l11","1.3.36.3.3.1.2":"RSA Signature Withripemd160","1.3.36.3.3.1.2.1024.11":"RSA Signature Withripemd160_l1024_l11","1.3.36.3.3.1.3":"RSA Signature Withrimpemd128","1.3.36.3.3.1.4":"RSA Signature Withrimpemd256","1.3.36.3.3.2":"Ecsie Sign","1.3.36.3.3.2.1":"Ecsie Sign WithSHA1","1.3.36.3.3.2.2":"Ecsie Sign Withripemd160","1.3.36.3.3.2.3":"Ecsie Sign Withmd2","1.3.36.3.3.2.4":"Ecsie Sign Withmd5","1.3.36.3.3.2.8.1.1.1":"Brainpool P160r1","1.3.36.3.3.2.8.1.1.2":"Brainpool P160t1","1.3.36.3.3.2.8.1.1.3":"Brainpool P192r1","1.3.36.3.3.2.8.1.1.4":"Brainpool P192t1","1.3.36.3.3.2.8.1.1.5":"Brainpool P224r1","1.3.36.3.3.2.8.1.1.6":"Brainpool P224t1","1.3.36.3.3.2.8.1.1.7":"Brainpool P256r1","1.3.36.3.3.2.8.1.1.8":"Brainpool P256t1","1.3.36.3.3.2.8.1.1.9":"Brainpool P320r1","1.3.36.3.3.2.8.1.1.10":"Brainpool P320t1","1.3.36.3.3.2.8.1.1.11":"Brainpool P384r1","1.3.36.3.3.2.8.1.1.12":"Brainpool P384t1","1.3.36.3.3.2.8.1.1.13":"Brainpool P512r1","1.3.36.3.3.2.8.1.1.14":"Brainpool P512t1","1.3.36.3.4":"Signature Scheme","1.3.36.3.4.1":"Sig S_ISO9796-1","1.3.36.3.4.2":"Sig S_ISO9796-2","1.3.36.3.4.2.1":"Sig S_ISO9796-2 With RED","1.3.36.3.4.2.2":"Sig S_ISO9796-2 With RSA","1.3.36.3.4.2.3":"Sig S_ISO9796-2 With RDN","1.3.36.4":"Attribute","1.3.36.5":"Policy","1.3.36.6":"Api","1.3.36.6.1":"Manufacturer-specific_api","1.3.36.6.1.1":"Utimaco-api","1.3.36.6.2":"Functionality-specific_api","1.3.36.7":"Keymgmnt","1.3.36.7.1":"Keyagree","1.3.36.7.1.1":"Bsi PKE","1.3.36.7.2":"Keytrans","1.3.36.7.2.1":"Enc ISO9796-2 Withrsa","1.3.36.8.1.1":"Teletrust  Sig G Conform policy Identifier","1.3.36.8.2.1":"Directory Service","1.3.36.8.3.1":"Date Of Cert Gen","1.3.36.8.3.2":"Procuration","1.3.36.8.3.3":"Admission","1.3.36.8.3.4":"Monetary Limit","1.3.36.8.3.5":"Declaration Of Majority","1.3.36.8.3.6":"Integrated Circuit Card Serial Number","1.3.36.8.3.7":"PK Reference","1.3.36.8.3.8":"Restriction","1.3.36.8.3.9":"Retrieve If Allowed","1.3.36.8.3.10":"Requested Certificate","1.3.36.8.3.11":"Naming Authorities","1.3.36.8.3.11.1":"Recht Wirtschaft Steuern","1.3.36.8.3.11.1.1":"Rechtsanwaeltin","1.3.36.8.3.11.1.2":"Rechtsanwalt","1.3.36.8.3.11.1.3":"Rechts Beistand","1.3.36.8.3.11.1.4":"Steuer Beraterin","1.3.36.8.3.11.1.5":"Steuer Berater","1.3.36.8.3.11.1.6":"Steuer Bevollmaechtigte","1.3.36.8.3.11.1.7":"Steuer Bevollmaechtigter","1.3.36.8.3.11.1.8":"Notarin","1.3.36.8.3.11.1.9":"Notar","1.3.36.8.3.11.1.10":"Notar Vertreterin","1.3.36.8.3.11.1.11":"Notar Vertreter","1.3.36.8.3.11.1.12":"Notariats Verwalterin","1.3.36.8.3.11.1.13":"Notariats Verwalter","1.3.36.8.3.11.1.14":"Wirtschafts Prueferin","1.3.36.8.3.11.1.15":"Wirtschafts Pruefer","1.3.36.8.3.11.1.16":"ereidigte Buchprueferin","1.3.36.8.3.11.1.17":"ereidigter Buchpruefer","1.3.36.8.3.11.1.18":"Patent Anwaeltin","1.3.36.8.3.11.1.19":"Patent Anwalt","1.3.36.8.3.12":"Cert In Dir Since","1.3.36.8.3.13":"Cert Hash","1.3.36.8.3.14":"Name At Birth","1.3.36.8.3.15":"Additional Information","1.3.36.8.4.1":"Personal Data","1.3.36.8.4.8":"Restriction","1.3.36.8.5.1.1.1":"RSA Indicate SHA1","1.3.36.8.5.1.1.2":"RSA Indicate RIPEMD160","1.3.36.8.5.1.1.3":"RSA With SHA1","1.3.36.8.5.1.1.4":"RSA With RIPEMD160","1.3.36.8.5.1.2.1":"Dsa Extended","1.3.36.8.5.1.2.2":"Dsa With RIPEMD160","1.3.36.8.6.1":"Cert","1.3.36.8.6.2":"Cert Ref","1.3.36.8.6.3":"Attr Cert","1.3.36.8.6.4":"Attr Ref","1.3.36.8.6.5":"File Name","1.3.36.8.6.6":"Storage Time","1.3.36.8.6.7":"File Size","1.3.36.8.6.8":"Location","1.3.36.8.6.9":"Sig Number","1.3.36.8.6.10":"Auto Gen","1.3.36.8.7.1.1":"Pt Adobe ILL","1.3.36.8.7.1.2":"Pt Ami Pro","1.3.36.8.7.1.3":"Pt Auto CAD","1.3.36.8.7.1.4":"Pt Binary","1.3.36.8.7.1.5":"Pt BMP","1.3.36.8.7.1.6":"Pt CGM","1.3.36.8.7.1.7":"Pt Corel CRT","1.3.36.8.7.1.8":"Pt Corel DRW","1.3.36.8.7.1.9":"Pt Corel EXC","1.3.36.8.7.1.10":"Pt Corel PHT","1.3.36.8.7.1.11":"Pt Draw","1.3.36.8.7.1.12":"Pt DVI","1.3.36.8.7.1.13":"Pt EPS","1.3.36.8.7.1.14":"Pt Excel","1.3.36.8.7.1.15":"Pt GEM","1.3.36.8.7.1.16":"Pt GIF","1.3.36.8.7.1.17":"Pt HPGL","1.3.36.8.7.1.18":"Pt JPEG","1.3.36.8.7.1.19":"Pt Kodak","1.3.36.8.7.1.20":"Pt LaTeX","1.3.36.8.7.1.21":"Pt Lotus","1.3.36.8.7.1.22":"Pt Lotus PIC","1.3.36.8.7.1.23":"Pt Mac PICT","1.3.36.8.7.1.24":"Pt Mac Word","1.3.36.8.7.1.25":"Pt MSWfD","1.3.36.8.7.1.26":"Pt MSWord","1.3.36.8.7.1.27":"Pt MSWord2","1.3.36.8.7.1.28":"Pt MSWord6","1.3.36.8.7.1.29":"Pt MSWord8","1.3.36.8.7.1.30":"Pt PDF","1.3.36.8.7.1.31":"Pt PIF","1.3.36.8.7.1.32":"Pt Postscript","1.3.36.8.7.1.33":"Pt RTF","1.3.36.8.7.1.34":"Pt SCITEX","1.3.36.8.7.1.35":"Pt TAR","1.3.36.8.7.1.36":"Pt Targa","1.3.36.8.7.1.37":"Pt TeX","1.3.36.8.7.1.38":"Pt Text","1.3.36.8.7.1.39":"Pt TIFF","1.3.36.8.7.1.40":"Pt TIFF-FC","1.3.36.8.7.1.41":"Pt UID","1.3.36.8.7.1.42":"Pt UU Encode","1.3.36.8.7.1.43":"Pt WMF","1.3.36.8.7.1.44":"Pt Word Perfect","1.3.36.8.7.1.45":"Pt WP Grph","1.3.101.1.4":"Thawte-ce","1.3.101.1.4.1":"Strong Extranet","1.3.132.0.1":"Sect163k1","1.3.132.0.2":"Sect163r1","1.3.132.0.3":"Sect239k1","1.3.132.0.4":"Sect113r1","1.3.132.0.5":"Sect113r2","1.3.132.0.6":"Secp112r1","1.3.132.0.7":"Secp112r2","1.3.132.0.8":"Secp160r1","1.3.132.0.9":"Secp160k1","1.3.132.0.10":"Secp256k1","1.3.132.0.15":"Sect163r2","1.3.132.0.16":"Sect283k1","1.3.132.0.17":"Sect283r1","1.3.132.0.22":"Sect131r1","1.3.132.0.23":"Sect131r2","1.3.132.0.24":"Sect193r1","1.3.132.0.25":"Sect193r2","1.3.132.0.26":"Sect233k1","1.3.132.0.27":"Sect233r1","1.3.132.0.28":"Secp128r1","1.3.132.0.29":"Secp128r2","1.3.132.0.30":"Secp160r2","1.3.132.0.31":"Secp192k1","1.3.132.0.32":"Secp224k1","1.3.132.0.33":"Secp224r1","1.3.132.0.34":"Secp384r1","1.3.132.0.35":"Secp521r1","1.3.132.0.36":"Sect409k1","1.3.132.0.37":"Sect409r1","1.3.132.0.38":"Sect571k1","1.3.132.0.39":"Sect571r1","1.3.133.16.840.9.84":"x984","1.3.133.16.840.9.84.0":"x984 Module","1.3.133.16.840.9.84.0.1":"x984 Biometrics","1.3.133.16.840.9.84.0.2":"x984 CMS","1.3.133.16.840.9.84.0.3":"x984 Identifiers","1.3.133.16.840.9.84.1":"x984 Biometric","1.3.133.16.840.9.84.1.0":"Biometric Unknown Type","1.3.133.16.840.9.84.1.1":"Biometric Body Odor","1.3.133.16.840.9.84.1.2":"Biometric DNA","1.3.133.16.840.9.84.1.3":"Biometric Ear Shape","1.3.133.16.840.9.84.1.4":"Biometric Facial Features","1.3.133.16.840.9.84.1.5":"Biometric Finger Image","1.3.133.16.840.9.84.1.6":"Biometric Finger Geometry","1.3.133.16.840.9.84.1.7":"Biometric Hand Geometry","1.3.133.16.840.9.84.1.8":"Biometric Iris Features","1.3.133.16.840.9.84.1.9":"Biometric Keystroke Dynamics","1.3.133.16.840.9.84.1.10":"Biometric Palm","1.3.133.16.840.9.84.1.11":"Biometric Retina","1.3.133.16.840.9.84.1.12":"Biometric Signature","1.3.133.16.840.9.84.1.13":"Biometric Speech Pattern","1.3.133.16.840.9.84.1.14":"Biometric Thermal Image","1.3.133.16.840.9.84.1.15":"Biometric Vein Pattern","1.3.133.16.840.9.84.1.16":"Biometric Thermal Face Image","1.3.133.16.840.9.84.1.17":"Biometric Thermal Hand Image","1.3.133.16.840.9.84.1.18":"Biometric Lip Movement","1.3.133.16.840.9.84.1.19":"Biometric Gait","1.3.133.16.840.9.84.3":"x984 Matching Method","1.3.133.16.840.9.84.4":"x984 Format Owner","1.3.133.16.840.9.84.4.0":"x984 Cbeff Owner","1.3.133.16.840.9.84.4.1":"x984 Ibia Owner","1.3.133.16.840.9.84.4.1.1":"Ibia Owner SAFLINK","1.3.133.16.840.9.84.4.1.2":"Ibia Owner Bioscrypt","1.3.133.16.840.9.84.4.1.3":"Ibia Owner Visionics","1.3.133.16.840.9.84.4.1.4":"Ibia Owner Infineon Technologies AG","1.3.133.16.840.9.84.4.1.5":"Ibia Owner Iridian Technologies","1.3.133.16.840.9.84.4.1.6":"Ibia Owner Veridicom","1.3.133.16.840.9.84.4.1.7":"Ibia Owner Cyber SIGN","1.3.133.16.840.9.84.4.1.8":"Ibia Ownere Cryp","1.3.133.16.840.9.84.4.1.9":"Ibia Owner Fingerprint Cards AB","1.3.133.16.840.9.84.4.1.10":"Ibia Owner Secu Gen","1.3.133.16.840.9.84.4.1.11":"Ibia Owner Precise Biometric","1.3.133.16.840.9.84.4.1.12":"Ibia Owner Identix","1.3.133.16.840.9.84.4.1.13":"Ibia Owner DERMALOG","1.3.133.16.840.9.84.4.1.14":"Ibia Owner LOGICO","1.3.133.16.840.9.84.4.1.15":"Ibia Owner NIST","1.3.133.16.840.9.84.4.1.16":"Ibia Owner A3 Vision","1.3.133.16.840.9.84.4.1.17":"Ibia Owner NEC","1.3.133.16.840.9.84.4.1.18":"Ibia Owner ST Microelectronics","2.5.4.0":"Object Class","2.5.4.1":"Aliased Entry Name","2.5.4.2":"Knowledge Information","2.5.4.3":"Common Name","2.5.4.4":"Surname","2.5.4.5":"Serial Number","2.5.4.6":"Country Name","2.5.4.7":"Locality","2.5.4.7.1":"Collective Locality Name","2.5.4.8":"State","2.5.4.8.1":"Collective State Or Province Name","2.5.4.9":"Street Address","2.5.4.9.1":"Collective Street Address","2.5.4.10":"Organization","2.5.4.10.1":"Collective Organization Name","2.5.4.11":"Organization Unit","2.5.4.11.1":"Collective Organization Unit Name","2.5.4.12":"Title","2.5.4.13":"Description","2.5.4.14":"Search Guide","2.5.4.15":"Business Category","2.5.4.16":"Postal Address","2.5.4.16.1":"Collective Postal Address","2.5.4.17":"Postal Code","2.5.4.17.1":"Collective Postal Code","2.5.4.18":"Post Office Box","2.5.4.18.1":"Collective Post Office Box","2.5.4.19":"Physical Delivery Office Name","2.5.4.19.1":"Collective Physical Delivery Office Name","2.5.4.20":"Telephone Number","2.5.4.20.1":"Collective Telephone Number","2.5.4.21":"Telex Number","2.5.4.21.1":"Collective Telex Number","2.5.4.22":"Teletex Terminal Identifier","2.5.4.22.1":"Collective Teletex Terminal Identifier","2.5.4.23":"Facsimile Telephone Number","2.5.4.23.1":"Collective Facsimile Telephone Number","2.5.4.24":"x121 Address","2.5.4.25":"International ISDN Number","2.5.4.25.1":"Collective International ISDN Number","2.5.4.26":"Registered Address","2.5.4.27":"Destination Indicator","2.5.4.28":"Preferred Delivery Mehtod","2.5.4.29":"Presentation Address","2.5.4.30":"Supported Application Context","2.5.4.31":"Member","2.5.4.32":"Owner","2.5.4.33":"Role Occupant","2.5.4.34":"See Also","2.5.4.35":"User Password","2.5.4.36":"User Certificate","2.5.4.37":"Ca Certificate","2.5.4.38":"Authority Revocation List","2.5.4.39":"Certificate Revocation List","2.5.4.40":"Cross Certificate Pair","2.5.4.41":"Name","2.5.4.42":"Given Name","2.5.4.43":"Initials","2.5.4.44":"Generation Qualifier","2.5.4.45":"Unique Identifier","2.5.4.46":"Dn Qualifier","2.5.4.47":"Enhanced Search Guide","2.5.4.48":"Protocol Information","2.5.4.49":"Distinguished Name","2.5.4.50":"Unique Member","2.5.4.51":"House Identifier","2.5.4.52":"Supported Algorithms","2.5.4.53":"Delta Revocation List","2.5.4.54":"DMD Name","2.5.4.55":"Clearance","2.5.4.56":"Default Dir Qop","2.5.4.57":"Attribute Integrity Info","2.5.4.58":"Attribute Certificate","2.5.4.59":"Attribute Certificate Revocation List","2.5.4.60":"Conf Key Info","2.5.4.61":"AA Certificate","2.5.4.62":"Attribute Descriptor Certificate","2.5.4.63":"Attribute Authority Revocation List","2.5.4.64":"Family Information","2.5.4.65":"Pseudonym","2.5.4.66":"Communications Service","2.5.4.67":"Communications Network","2.5.4.68":"Certification Practice Stmt","2.5.4.69":"Certificate Policy","2.5.4.70":"Pki Path","2.5.4.71":"Priv Policy","2.5.4.72":"Role","2.5.4.73":"Delegation Path","2.5.4.74":"Prot Priv Policy","2.5.4.75":"XML Privilege Info","2.5.4.76":"XML Priv Policy","2.5.4.82":"Permission","2.5.6.0":"Top","2.5.6.1":"Alias","2.5.6.2":"Country","2.5.6.3":"Locality","2.5.6.4":"Organization","2.5.6.5":"Organization Unit","2.5.6.6":"Person","2.5.6.7":"Organization Person","2.5.6.8":"Organization Role","2.5.6.9":"Group Of Names","2.5.6.10":"Residential Person","2.5.6.11":"Application Process","2.5.6.12":"Application Entity","2.5.6.13":"DSA","2.5.6.14":"Device","2.5.6.15":"Strong Authentication User","2.5.6.16":"Certificate Authority","2.5.6.17":"Group Of Unique Names","2.5.6.21":"Pki User","2.5.6.22":"Pki CA","2.5.8.1.1":"RSA","2.5.29.1":"Authority Key Identifier","2.5.29.2":"Key Attributes","2.5.29.3":"Certificate Policies","2.5.29.4":"Key Usage Restriction","2.5.29.5":"Policy Mapping","2.5.29.6":"Subtrees Constraint","2.5.29.7":"Subject Alt Name","2.5.29.8":"Issuer Alt Name","2.5.29.9":"Subject Directory Attributes","2.5.29.10":"Basic Constraints","2.5.29.11":"Name Constraints","2.5.29.12":"Policy Constraints","2.5.29.13":"Basic Constraints","2.5.29.14":"Subject Key Identifier","2.5.29.15":"Key Usage","2.5.29.16":"Private Key Usage Period","2.5.29.17":"Subject Alternative Name","2.5.29.18":"Issuer Alternative Name","2.5.29.19":"Basic Constraints","2.5.29.20":"CRL Number","2.5.29.21":"CRL Reason","2.5.29.22":"Expiration Date","2.5.29.23":"Instruction Code","2.5.29.24":"Invalidity Date","2.5.29.25":"CRL Distribution Points","2.5.29.26":"Issuing Distribution Point","2.5.29.27":"Delta CRL Indicator","2.5.29.28":"Issuing Distribution Point","2.5.29.29":"Certificate Issuer","2.5.29.30":"Name Constraints","2.5.29.31":"CRL Distribution Points","2.5.29.32":"Certificate Policies","2.5.29.32.0":"Any Policy","2.5.29.33":"Policy Mappings","2.5.29.34":"Policy Constraints","2.5.29.35":"Authority Key Identifier","2.5.29.36":"Policy Constraints","2.5.29.37":"Extended Key Usage","2.5.29.37.0":"Any Extended Key Usage","2.5.29.38":"Authority Attribute Identifier","2.5.29.39":"Role Spec Cert Identifier","2.5.29.40":"CRL Stream Identifier","2.5.29.41":"Basic Att Constraints","2.5.29.42":"Delegated Name Constraints","2.5.29.43":"Time Specification","2.5.29.44":"CRL Scope","2.5.29.45":"Status Referrals","2.5.29.46":"Freshest CRL","2.5.29.47":"Ordered List","2.5.29.48":"Attribute Descriptor","2.5.29.49":"User Notice","2.5.29.50":"SOA Identifier","2.5.29.51":"Base Update Time","2.5.29.52":"Acceptable Cert Policies","2.5.29.53":"Delta Info","2.5.29.54":"Inhibit Any Policy","2.5.29.55":"Target Information","2.5.29.56":"No Rev Avail","2.5.29.57":"Acceptable Privilege Policies","2.5.29.58":"To Be Revoked","2.5.29.59":"Revoked Groups","2.5.29.60":"Expired Certs On CRL","2.5.29.61":"Indirect Issuer","2.5.29.62":"No Assertion","2.5.29.63":"A Aissuing Distribution Point","2.5.29.64":"Issued On Behalf Of","2.5.29.65":"Single Use","2.5.29.66":"Group AC","2.5.29.67":"Allowed Att Ass","2.5.29.68":"Attribute Mappings","2.5.29.69":"Holder Name Constraints","2.16.528.1.1001.1.1.1.12.6.1.1.1":"Digi Notar EV policy","2.16.578.1.26.1.3.3":"Buy Pass EV policy","2.16.724.1.2.2.4.1":"Personal Data Info","2.16.756.1.89.1.2.1.1":"Swiss Sign EV policy","2.16.840.1.101.2.1.1.1":"Sdns Signature Algorithm","2.16.840.1.101.2.1.1.2":"Fortezza Signature Algorithm","2.16.840.1.101.2.1.1.3":"Sdns Confidentiality Algorithm","2.16.840.1.101.2.1.1.4":"Fortezza Confidentiality Algorithm","2.16.840.1.101.2.1.1.5":"Sdns Integrity Algorithm","2.16.840.1.101.2.1.1.6":"Fortezza Integrity Algorithm","2.16.840.1.101.2.1.1.7":"Sdns Token Protection Algorithm","2.16.840.1.101.2.1.1.8":"Fortezza Token Protection Algorithm","2.16.840.1.101.2.1.1.9":"Sdns Key Management Algorithm","2.16.840.1.101.2.1.1.10":"Fortezza Key Management Algorithm","2.16.840.1.101.2.1.1.11":"Sdns K Mand Sig Algorithm","2.16.840.1.101.2.1.1.12":"Fortezza K Mand Sig Algorithm","2.16.840.1.101.2.1.1.13":"Suite A Signature Algorithm","2.16.840.1.101.2.1.1.14":"Suite A Confidentiality Algorithm","2.16.840.1.101.2.1.1.15":"Suite A Integrity Algorithm","2.16.840.1.101.2.1.1.16":"Suite A Token Protection Algorithm","2.16.840.1.101.2.1.1.17":"Suite A Key Management Algorithm","2.16.840.1.101.2.1.1.18":"Suite AK Mand Sig Algorithm","2.16.840.1.101.2.1.1.19":"Fortezza Updated Sig Algorithm","2.16.840.1.101.2.1.1.20":"Fortezza K Mand Upd Sig Algorithms","2.16.840.1.101.2.1.1.21":"Fortezza Updated Integ Algorithm","2.16.840.1.101.2.1.1.22":"Key Exchange Algorithm","2.16.840.1.101.2.1.1.23":"Fortezza Wrap80 Algorithm","2.16.840.1.101.2.1.1.24":"KEA Key Encryption Algorithm","2.16.840.1.101.2.1.2.1":"Rfc822 Message Format","2.16.840.1.101.2.1.2.2":"Empty Content","2.16.840.1.101.2.1.2.3":"Csp Content Type","2.16.840.1.101.2.1.2.42":"MSP Rev3 Content Type","2.16.840.1.101.2.1.2.48":"MSP Content Type","2.16.840.1.101.2.1.2.49":"MSP Rekey Agent Protocol","2.16.840.1.101.2.1.2.50":"MSP MMP","2.16.840.1.101.2.1.2.66":"MSP Rev3-1 Content Type","2.16.840.1.101.2.1.2.72":"Forwarded MSP Message Body Part","2.16.840.1.101.2.1.2.73":"MSP Forwarded Message Parameters","2.16.840.1.101.2.1.2.74":"Forwarded CSP Msg Body Part","2.16.840.1.101.2.1.2.75":"CSP Forwarded Message Parameters","2.16.840.1.101.2.1.2.76":"MSP MMP2","2.16.840.1.101.2.1.3.1":"SDNS Security Policy","2.16.840.1.101.2.1.3.2":"SDNS PRBAC","2.16.840.1.101.2.1.3.3":"Mosaic PRBAC","2.16.840.1.101.2.1.3.10":"SI Security Policy","2.16.840.1.101.2.1.3.10.0":"SI NASP","2.16.840.1.101.2.1.3.10.1":"SI ELCO","2.16.840.1.101.2.1.3.10.2":"SI TK","2.16.840.1.101.2.1.3.10.3":"SI DSAP","2.16.840.1.101.2.1.3.10.4":"SI SSSS","2.16.840.1.101.2.1.3.10.5":"SI DNASP","2.16.840.1.101.2.1.3.10.6":"SI BYEMAN","2.16.840.1.101.2.1.3.10.7":"SI REL-US","2.16.840.1.101.2.1.3.10.8":"SI REL-AUS","2.16.840.1.101.2.1.3.10.9":"SI REL-CAN","2.16.840.1.101.2.1.3.10.10":"SI REL_UK","2.16.840.1.101.2.1.3.10.11":"SI REL-NZ","2.16.840.1.101.2.1.3.10.12":"SI Generic","2.16.840.1.101.2.1.3.11":"Genser","2.16.840.1.101.2.1.3.11.0":"Genser Nations","2.16.840.1.101.2.1.3.11.1":"Genser Comsec","2.16.840.1.101.2.1.3.11.2":"Genser Acquisition","2.16.840.1.101.2.1.3.11.3":"Genser Security Categories","2.16.840.1.101.2.1.3.11.3.0":"Genser Tag Set Name","2.16.840.1.101.2.1.3.12":"Default Security Policy","2.16.840.1.101.2.1.3.13":"Capco Markings","2.16.840.1.101.2.1.3.13.0":"Capco Security Categories","2.16.840.1.101.2.1.3.13.0.1":"Capco Tag Set Name1","2.16.840.1.101.2.1.3.13.0.2":"Capco Tag Set Name2","2.16.840.1.101.2.1.3.13.0.3":"Capco Tag Set Name3","2.16.840.1.101.2.1.3.13.0.4":"Capco Tag Set Name4","2.16.840.1.101.2.1.5.1":"SDNS Key Management Certificate","2.16.840.1.101.2.1.5.2":"SDNS User Signature Certificate","2.16.840.1.101.2.1.5.3":"SDNS K Mand Sig Certificate","2.16.840.1.101.2.1.5.4":"Fortezza Key Management Certificate","2.16.840.1.101.2.1.5.5":"Fortezza K Mand Sig Certificate","2.16.840.1.101.2.1.5.6":"Fortezza User Signature Certificate","2.16.840.1.101.2.1.5.7":"Fortezza CA Signature Certificate","2.16.840.1.101.2.1.5.8":"SDNS CA Signature Certificate","2.16.840.1.101.2.1.5.10":"Auxiliary Vector","2.16.840.1.101.2.1.5.11":"Ml Receipt Policy","2.16.840.1.101.2.1.5.12":"Ml Membership","2.16.840.1.101.2.1.5.13":"Ml Administrators","2.16.840.1.101.2.1.5.14":"Alid","2.16.840.1.101.2.1.5.20":"Jan UKMs","2.16.840.1.101.2.1.5.21":"Feb UKMs","2.16.840.1.101.2.1.5.22":"Mar UKMs","2.16.840.1.101.2.1.5.23":"Apr UKMs","2.16.840.1.101.2.1.5.24":"May UKMs","2.16.840.1.101.2.1.5.25":"Jun UKMs","2.16.840.1.101.2.1.5.26":"Jul UKMs","2.16.840.1.101.2.1.5.27":"Aug UKMs","2.16.840.1.101.2.1.5.28":"Sep UKMs","2.16.840.1.101.2.1.5.29":"Oct UKMs","2.16.840.1.101.2.1.5.30":"Nov UKMs","2.16.840.1.101.2.1.5.31":"Dec UKMs","2.16.840.1.101.2.1.5.40":"Meta SDN Sckl","2.16.840.1.101.2.1.5.41":"Sdns CKL","2.16.840.1.101.2.1.5.42":"Meta SDN Ssignature CKL","2.16.840.1.101.2.1.5.43":"Sdns Signature CKL","2.16.840.1.101.2.1.5.44":"Sdns Certificate Revocation List","2.16.840.1.101.2.1.5.45":"Fortezza Certificate Revocation List","2.16.840.1.101.2.1.5.46":"Fortezza CKL","2.16.840.1.101.2.1.5.47":"Al Exempted Address Processor","2.16.840.1.101.2.1.5.48":"Guard","2.16.840.1.101.2.1.5.49":"Algorithms Supported","2.16.840.1.101.2.1.5.50":"Suite A Key Management Certificate","2.16.840.1.101.2.1.5.51":"Suite AK Mand Sig Certificate","2.16.840.1.101.2.1.5.52":"Suite A User Signature Certificate","2.16.840.1.101.2.1.5.53":"Prbac Info","2.16.840.1.101.2.1.5.54":"Prbac CA Constraints","2.16.840.1.101.2.1.5.55":"Sig Or KM Privileges","2.16.840.1.101.2.1.5.56":"Comm Privileges","2.16.840.1.101.2.1.5.57":"Labeled Attribute","2.16.840.1.101.2.1.5.58":"Policy Information File","2.16.840.1.101.2.1.5.59":"Sec Policy Information File","2.16.840.1.101.2.1.5.60":"CA Clearance Constraint","2.16.840.1.101.2.1.7.1":"CSP Extns","2.16.840.1.101.2.1.7.1.0":"CSP Cs Extn","2.16.840.1.101.2.1.8.1":"MISSI Security Categories","2.16.840.1.101.2.1.8.2":"Standard Security Label Privileges","2.16.840.1.101.2.1.10.1":"SIG Privileges","2.16.840.1.101.2.1.10.2":"KM Privileges","2.16.840.1.101.2.1.10.3":"Named Tag Set Privilege","2.16.840.1.101.2.1.11.1":"UK Demo","2.16.840.1.101.2.1.11.2":"US DOD Class2","2.16.840.1.101.2.1.11.3":"US Medium Pilot","2.16.840.1.101.2.1.11.4":"US DOD Class4","2.16.840.1.101.2.1.11.5":"US DOD Class3","2.16.840.1.101.2.1.11.6":"US DOD Class5","2.16.840.1.101.2.1.12.0":"Test Security Policy","2.16.840.1.101.2.1.12.0.1":"TSP1","2.16.840.1.101.2.1.12.0.1.0":"TSP1 Security Categories","2.16.840.1.101.2.1.12.0.1.0.0":"TSP1 Tag Set Zero","2.16.840.1.101.2.1.12.0.1.0.1":"TSP1 Tag Set One","2.16.840.1.101.2.1.12.0.1.0.2":"TSP1 Tag Set Two","2.16.840.1.101.2.1.12.0.2":"TSP2","2.16.840.1.101.2.1.12.0.2.0":"TSP2 Security Categories","2.16.840.1.101.2.1.12.0.2.0.0":"TSP2 Tag Set Zero","2.16.840.1.101.2.1.12.0.2.0.1":"TSP2 Tag Set One","2.16.840.1.101.2.1.12.0.2.0.2":"TSP2 Tag Set Two","2.16.840.1.101.2.1.12.0.3":"Kafka","2.16.840.1.101.2.1.12.0.3.0":"Kafka Security Categories","2.16.840.1.101.2.1.12.0.3.0.1":"Kafka Tag Set Name1","2.16.840.1.101.2.1.12.0.3.0.2":"Kafka Tag Set Name2","2.16.840.1.101.2.1.12.0.3.0.3":"Kafka Tag Set Name3","2.16.840.1.101.2.1.12.1.1":"TCp1","2.16.840.1.101.3.1":"Slabel","2.16.840.1.101.3.2":"PKI","2.16.840.1.101.3.2.1":"NIST policy Identifier","2.16.840.1.101.3.2.1.3.1":"Fbca Rudimentary Policy","2.16.840.1.101.3.2.1.3.2":"Fbca Basic Policy","2.16.840.1.101.3.2.1.3.3":"Fbca Medium Policy","2.16.840.1.101.3.2.1.3.4":"Fbca High Policy","2.16.840.1.101.3.2.1.48.1":"Nist Test Policy1","2.16.840.1.101.3.2.1.48.2":"Nist Test Policy2","2.16.840.1.101.3.2.1.48.3":"Nist Test Policy3","2.16.840.1.101.3.2.1.48.4":"Nist Test Policy4","2.16.840.1.101.3.2.1.48.5":"Nist Test Policy5","2.16.840.1.101.3.2.1.48.6":"Nist Test Policy6","2.16.840.1.101.3.2.2":"GAK","2.16.840.1.101.3.2.2.1":"KRA Key","2.16.840.1.101.3.2.3":"Extensions","2.16.840.1.101.3.2.3.1":"KR Technique","2.16.840.1.101.3.2.3.2":"K Recovery Capable","2.16.840.1.101.3.2.3.3":"KR","2.16.840.1.101.3.2.4":"Key Recovery Schemes","2.16.840.1.101.3.2.5":"Krapola","2.16.840.1.101.3.3":"ARPA","2.16.840.1.101.3.4":"Nist Algorithm","2.16.840.1.101.3.4.1":"AES","2.16.840.1.101.3.4.1.1":"AES128-ECB","2.16.840.1.101.3.4.1.2":"AES128-CBC","2.16.840.1.101.3.4.1.3":"AES128-OFB","2.16.840.1.101.3.4.1.4":"AES128-CFB","2.16.840.1.101.3.4.1.5":"AES128-wrap","2.16.840.1.101.3.4.1.6":"AES128-GCM","2.16.840.1.101.3.4.1.7":"AES128-CCM","2.16.840.1.101.3.4.1.8":"AES128-wrap-pad","2.16.840.1.101.3.4.1.21":"AES192-ECB","2.16.840.1.101.3.4.1.22":"AES192-CBC","2.16.840.1.101.3.4.1.23":"AES192-OFB","2.16.840.1.101.3.4.1.24":"AES192-CFB","2.16.840.1.101.3.4.1.25":"AES192-wrap","2.16.840.1.101.3.4.1.26":"AES192-GCM","2.16.840.1.101.3.4.1.27":"AES192-CCM","2.16.840.1.101.3.4.1.28":"AES192-wrap-pad","2.16.840.1.101.3.4.1.41":"AES256-ECB","2.16.840.1.101.3.4.1.42":"AES256-CBC","2.16.840.1.101.3.4.1.43":"AES256-OFB","2.16.840.1.101.3.4.1.44":"AES256-CFB","2.16.840.1.101.3.4.1.45":"AES256-wrap","2.16.840.1.101.3.4.1.46":"AES256-GCM","2.16.840.1.101.3.4.1.47":"AES256-CCM","2.16.840.1.101.3.4.1.48":"AES256-wrap-pad","2.16.840.1.101.3.4.2":"Hash Algos","2.16.840.1.101.3.4.2.1":"SHA-256","2.16.840.1.101.3.4.2.2":"SHA-384","2.16.840.1.101.3.4.2.3":"SHA-512","2.16.840.1.101.3.4.2.4":"SHA-224","2.16.840.1.101.3.4.3.1":"DSA With Sha224","2.16.840.1.101.3.4.3.2":"DSA With Sha256","2.16.840.1.113719.1.2.8":"Novell Algorithm","2.16.840.1.113719.1.2.8.22":"DES Cbc IV8","2.16.840.1.113719.1.2.8.23":"DES Cbc Pad IV8","2.16.840.1.113719.1.2.8.24":"DES EDE2 Cbc IV8","2.16.840.1.113719.1.2.8.25":"DES EDE2 Cbc Pad IV8","2.16.840.1.113719.1.2.8.26":"DES EDE3 Cbc IV8","2.16.840.1.113719.1.2.8.27":"DES EDE3 Cbc Pad IV8","2.16.840.1.113719.1.2.8.28":"Rc5 Cbc Pad","2.16.840.1.113719.1.2.8.29":"MD2 With RSA Encryption B Safe1","2.16.840.1.113719.1.2.8.30":"MD5 With RSA Encryption B Safe1","2.16.840.1.113719.1.2.8.31":"SHA1 With RSA Encryption B Safe1","2.16.840.1.113719.1.2.8.32":"Lm Digest","2.16.840.1.113719.1.2.8.40":"MD2","2.16.840.1.113719.1.2.8.50":"MD5","2.16.840.1.113719.1.2.8.51":"Ike Hmac With SHA1-RSA","2.16.840.1.113719.1.2.8.52":"Ike Hmac With MD5-RSA","2.16.840.1.113719.1.2.8.69":"RC2 Cbc Pad","2.16.840.1.113719.1.2.8.82":"SHA-1","2.16.840.1.113719.1.2.8.92":"RC2 B Safe1 Cbc","2.16.840.1.113719.1.2.8.95":"MD4","2.16.840.1.113719.1.2.8.130":"MD4 Packet","2.16.840.1.113719.1.2.8.131":"RSA Encryption Bsafe1","2.16.840.1.113719.1.2.8.132":"Nw Password","2.16.840.1.113719.1.2.8.133":"Novell Obfuscate-1","2.16.840.1.113719.1.9":"PKI","2.16.840.1.113719.1.9.4":"PKI Attribute Type","2.16.840.1.113719.1.9.4.1":"Security Attributes","2.16.840.1.113719.1.9.4.2":"Reliance Limit","2.16.840.1.113730.1":"Certificate Extension","2.16.840.1.113730.1.1":"Netscape Certificate Type","2.16.840.1.113730.1.2":"Netscape Base Url","2.16.840.1.113730.1.3":"Netscape Revocation Url","2.16.840.1.113730.1.4":"Netscape CA Revocation","2.16.840.1.113730.1.7":"Netscape Certificate Renewal","2.16.840.1.113730.1.8":"Netscape CA Policy","2.16.840.1.113730.1.9":"Home Page Url","2.16.840.1.113730.1.10":"Entity Logo","2.16.840.1.113730.1.11":"User Picture","2.16.840.1.113730.1.12":"Netscape Ssl Server","2.16.840.1.113730.1.13":"Netscape Comment","2.16.840.1.113730.2":"Data-type","2.16.840.1.113730.2.1":"Data GIF","2.16.840.1.113730.2.2":"Data JPEG","2.16.840.1.113730.2.3":"Data URL","2.16.840.1.113730.2.4":"Data HTML","2.16.840.1.113730.2.5":"Cert Sequence","2.16.840.1.113730.2.6":"Cert URL","2.16.840.1.113730.3":"Directory","2.16.840.1.113730.3.1":"Ldap Definitions","2.16.840.1.113730.3.1.1":"Car License","2.16.840.1.113730.3.1.2":"Department Number","2.16.840.1.113730.3.1.3":"Employee Number","2.16.840.1.113730.3.1.4":"Employee Type","2.16.840.1.113730.3.2.2":"Inet Org Person","2.16.840.1.113730.4.1":"Server Gated Crypto","2.16.840.1.113733.1":"PKI","2.16.840.1.113733.1.6.3":"Verisign CZAG","2.16.840.1.113733.1.6.6":"Verisign In Box","2.16.840.1.113733.1.6.11":"Verisign Onsite Jurisdiction Hash","2.16.840.1.113733.1.6.13":"Unknown  Verisign  VPN extension","2.16.840.1.113733.1.6.15":"Verisign Server ID","2.16.840.1.113733.1.7.1.1":"Verisign Cert Policies95 Qualifier1","2.16.840.1.113733.1.7.1.1.1":"Verisign CP Sv1notice","2.16.840.1.113733.1.7.1.1.2":"Verisign CP Sv1nsi","2.16.840.1.113733.1.7.23.6":"Veri Sign EV policy","2.16.840.1.113733.1.7.48.1":"Thawte EV policy","2.16.840.1.113733.1.8.1":"erisign ISS Strong Crypto","2.16.840.1.113733.1.9":"PKCS7 Attribute","2.16.840.1.113733.1.9.2":"Message Type","2.16.840.1.113733.1.9.3":"PKI Status","2.16.840.1.113733.1.9.4":"Fail Info","2.16.840.1.113733.1.9.5":"Sender Nonce","2.16.840.1.113733.1.9.6":"Recipient Nonce","2.16.840.1.113733.1.9.7":"Trans ID","2.16.840.1.113733.1.9.8":"Extension Req","2.16.840.1.113741.2":"Intel CDSA","2.16.840.1.114028.10.1.2":"Entrust EV policy","2.16.840.1.114171.500.9":"Wells Fargo EV policy","2.16.840.1.114404.1.1.2.4.1":"Trust Wave EV policy","2.16.840.1.114412.1":"Digi Cert Non EV Certs","2.16.840.1.114412.1.1":"Digi Cert OV Cert","2.16.840.1.114412.1.2":"Digi Cert DV Cert","2.16.840.1.114412.1.3.0.1":"Digi Cert Global CA Policy","2.16.840.1.114412.1.3.0.2":"Digi Cert High Assurance EVCA Policy","2.16.840.1.114412.1.3.0.3":"Digi Cert Global Root CA Policy","2.16.840.1.114412.1.3.0.4":"Digi Cert Assured ID Root CA Policy","2.16.840.1.114412.1.11":"Digi Cert Federated Device Cert","2.16.840.1.114412.2.1":"Digi Cert  EV policy","2.16.840.1.114412.2.2":"Digi Cert EV Cert","2.16.840.1.114412.2.3":"Digi Cert Object Signing Cert","2.16.840.1.114412.2.3.1":"Digi Cert Code Signing Cert","2.16.840.1.114412.2.3.2":"Digi Cert EV Code Signing Cert","2.16.840.1.114412.2.3.11":"Digi Cert Kernel Code Signing Cert","2.16.840.1.114412.2.3.21":"Digi Cert Document Signing Cert","2.16.840.1.114412.2.4":"Digi Cert Client Cert","2.16.840.1.114412.2.4.1.1":"Digi Cert Level1 Personal Client Cert","2.16.840.1.114412.2.4.1.2":"Digi Cert Level1 Enterprise Client Cert","2.16.840.1.114412.2.4.2":"Digi Cert Level2 Client Cert","2.16.840.1.114412.2.4.3.1":"Digi Cert Level3 US Client Cert","2.16.840.1.114412.2.4.3.2":"Digi Cert Level3 CBP Client Cert","2.16.840.1.114412.2.4.4.1":"Digi Cert Level4 US Client Cert","2.16.840.1.114412.2.4.4.2":"Digi Cert Level4 CBP Client Cert","2.16.840.1.114412.2.4.5.1":"Digi Cert PIV Hardware Cert","2.16.840.1.114412.2.4.5.2":"Digi Cert PIV Card Auth Cert","2.16.840.1.114412.2.4.5.3":"Digi Cert PIV Content Signing Cert","2.16.840.1.114412.4.31":"Digi Cert Grid Classic Cert","2.16.840.1.114412.4.31.5":"Digi Cert Grid Integrated Cert","2.16.840.1.114412.31.4.31.1":"Digi Cert Grid Host Cert","2.16.840.1.114413.1.7.23.3":"Go Daddy EV policy","2.16.840.1.114414.1.7.23.3":"Starfield EV policy","2.23.42.0":"Content Type","2.23.42.0.0":"Pan Data","2.23.42.0.1":"Pan Token","2.23.42.0.2":"Pan Only","2.23.42.1":"Msg Ext","2.23.42.2":"Field","2.23.42.2.0":"Full Name","2.23.42.2.1":"Given Name","2.23.42.2.2":"Family Name","2.23.42.2.3":"Birth Family Name","2.23.42.2.4":"Place Name","2.23.42.2.5":"Identification Number","2.23.42.2.6":"Month","2.23.42.2.7":"Date","2.23.42.2.8":"Address","2.23.42.2.9":"Telephone","2.23.42.2.10":"Amount","2.23.42.2.11":"Account Number","2.23.42.2.12":"Pass Phrase","2.23.42.3":"Attribute","2.23.42.3.0":"Cert","2.23.42.3.0.0":"Root Key Thumb","2.23.42.3.0.1":"Additional Policy","2.23.42.4":"Algorithm","2.23.42.5":"Policy","2.23.42.5.0":"Root","2.23.42.6":"Module","2.23.42.7":"Cert Ext","2.23.42.7.0":"Hashed Root Key","2.23.42.7.1":"Certificate Type","2.23.42.7.2":"Merchant Data","2.23.42.7.3":"Card Cert Required","2.23.42.7.4":"Tunneling","2.23.42.7.5":"Set Extensions","2.23.42.7.6":"Set Qualifier","2.23.42.8":"Brand","2.23.42.8.1":"IATA-ATA","2.23.42.8.4":" ISA","2.23.42.8.5":"Master Card","2.23.42.8.30":"Diners","2.23.42.8.34":"American Express","2.23.42.8.6011":"Novus","2.23.42.9":"Vendor","2.23.42.9.0":"Globe Set","2.23.42.9.1":"IBM","2.23.42.9.2":"Cyber Cash","2.23.42.9.3":"Terisa","2.23.42.9.4":"RSADSI","2.23.42.9.5":"Veri Fone","2.23.42.9.6":"Trin Tech","2.23.42.9.7":"Bank Gate","2.23.42.9.8":"GTE","2.23.42.9.9":"Compu Source","2.23.42.9.10":"Griffin","2.23.42.9.11":"Certicom","2.23.42.9.12":"OSS","2.23.42.9.13":"Tenth Mountain","2.23.42.9.14":"Antares","2.23.42.9.15":"ECC","2.23.42.9.16":"Maithean","2.23.42.9.17":"Netscape","2.23.42.9.18":"erisign","2.23.42.9.19":"Blue Money","2.23.42.9.20":"Lacerte","2.23.42.9.21":"Fujitsu","2.23.42.9.22":"E Lab","2.23.42.9.23":"Entrust","2.23.42.9.24":"VI Anet","2.23.42.9.25":"III","2.23.42.9.26":"Open Market","2.23.42.9.27":"Lexem","2.23.42.9.28":"Intertrader","2.23.42.9.29":"Persimmon","2.23.42.9.30":"NABLE","2.23.42.9.31":"Espace-net","2.23.42.9.32":"Hitachi","2.23.42.9.33":"Microsoft","2.23.42.9.34":"NEC","2.23.42.9.35":"Mitsubishi","2.23.42.9.36":"NCR","2.23.42.9.37":"E-COMM","2.23.42.9.38":"Gemplus","2.23.42.10":"National","2.23.42.10.392":"Japan","2.23.43.1.4":"WTLS-ECC","2.23.43.1.4.1":"WTLS-ECC-curve1","2.23.43.1.4.6":"WTLS-ECC-curve6","2.23.43.1.4.8":"WTLS-ECC-curve8","2.23.43.1.4.9":"WTLS-ECC-curve9","2.23.133":"TCPA","2.23.133.1":"TCPA Spec Version","2.23.133.2":"TCPA Attribute","2.23.133.2.1":"TCPA Tpm Manufacturer","2.23.133.2.2":"TCPA Tpm Model","2.23.133.2.3":"TCPA Tpm Version","2.23.133.2.4":"TCPA Platform Manufacturer","2.23.133.2.5":"TCPA Platform Model","2.23.133.2.6":"TCPA Platform Version","2.23.133.2.7":"TCPA Component Manufacturer","2.23.133.2.8":"TCPA Component Model","2.23.133.2.9":"TCPA Component Version","2.23.133.2.10":"TCPA Security Qualities","2.23.133.2.11":"TCPA Tpm Protection Profile","2.23.133.2.12":"TCPA Tpm Security Target","2.23.133.2.13":"TCPA Foundation Protection Profile","2.23.133.2.14":"TCPA Foundation Security Target","2.23.133.2.15":"TCPA Tpm Id Label","2.23.133.3":"TCPA Protocol","2.23.133.3.1":"TCPA Prtt Tpm Id Protocol","2.23.134.1.2.1.8.210":"Post Signum Commercial Server Policy","2.23.134.1.2.2.3":"Post Signum Public CA","2.23.134.1.4.2.1":"Post Signum Root QCA","2.23.136.1.1.1":"MRTD Signature Data","2.54.1775.2":"Hashed Root Key","2.54.1775.3":"Certificate Type","2.54.1775.4":"Merchant Data","2.54.1775.5":"Card Cert Required","2.54.1775.6":"Tunneling","2.54.1775.7":"Set Qualifier","2.54.1775.99":"Set Data","1.3.6.1.4.1.11129.2.4.3":"CT Pre-Certificate Poison","2.23.140.1.2.2":"CA/B Forum Organization Validated","2.23.140.1.2.1":"CA/B Forum Domain Validated","1.3.6.1.4.1.44947.1.1.1":"Let's Encrypt","1.3.6.1.4.1.4329.7.2.4":"SslTlsCerts","1.3.6.1.4.1.4329.7":"Siemens Public Key Infrastructure"},Ot={0:"Other Name",1:"Email Address",2:"DNS Name",3:"X400 Address",4:"Directory Name",5:"Edi Party Name",6:"Uniform Resource Identifier",7:"IP Address",8:"Registered ID"};var Ft;!function(e){e.BasicConstraints="2.5.29.19",e.KeyUsage="2.5.29.15",e.ExtendedKeyUsage="2.5.29.37",e.CertificatePolicies="2.5.29.32",e.AuthorityKeyIdentifier="2.5.29.35",e.CertificateAuthorityInformationAccess="1.3.6.1.5.5.7.1.1",e.CRLDistributionPoints="2.5.29.31",e.SubjectAlternativeName="2.5.29.17",e.NetscapeCertificateType="2.16.840.1.113730.1.1",e.NameConstraints="2.5.29.30",e.CertificateTransparency="1.3.6.1.4.1.11129.2.4.2",e.CertificateTemplate="1.3.6.1.4.1.311.21.7",e.ANY=""}(Ft||(Ft={}));class _t extends Re{constructor(e,t,i=!1){super(e,t),this.validity="",this.extensions=[],this.version=0,this.isRoot=!1,this.downloadAsPEM=()=>{xt(this.pem,"text/plain",this.commonName,"crt")},this.downloadAsDER=()=>{xt(this.hex,"application/octet-stream",this.commonName,"crt")},this.decode(i)}static base64ToPem(e){return e=e.replace(/(.{64})/g,"$1\n"),_t.pemTagCertificate(e)}static getExtensionNetscapeCertType(e){const t=[],i=Be(e.extnValue.valueBlock.valueHex).result,r=i.valueBlock.unusedBits;let s=new Uint8Array(i.valueBlock.valueHex)[0];return s>>=r,128&(s<<=r)&&t.push("SSL client"),64&s&&t.push("SSL server"),32&s&&t.push("S/MIME"),16&s&&t.push("Object Signing"),8&s&&t.push("Reserved"),4&s&&t.push("SSL CA"),2&s&&t.push("S/MIME CA"),1&s&&t.push("Object Signing CA"),t}static getExtensionKeyUsage(e){const t=[],i=new Uint8Array(e.parsedValue.valueBlock.valueHex),r=e.parsedValue.valueBlock.unusedBits;let s=i[0],n=i.byteLength>1?i[1]:0;return 1===i.byteLength&&(s>>=r,s<<=r),2===i.byteLength&&(n>>=r,n<<=r),128&s&&t.push("Digital Signature"),64&s&&t.push("Non Repudiation"),32&s&&t.push("Key Encipherment"),16&s&&t.push("Data Encipherment"),8&s&&t.push("Key Agreement"),4&s&&t.push("Key Cert Sign"),2&s&&t.push("cRL Sign"),1&s&&t.push("Encipher Only"),128&n&&t.push("Decipher Only"),t}static decodeIP(e){if(64===e.length&&0===parseInt(e,16))return"::/0";if(16!==e.length)return e;const t=parseInt(e.slice(8),16).toString(2).split("").reduce((e,t)=>e+ +t,0);let i=e.slice(0,8).replace(/(.{2})/g,e=>`${parseInt(e,16)}.`);return`${i=i.slice(0,-1)}/${t}`}static decodeSANs(e){return e.map(e=>{const t="base"in e?e.base:e,i={value:void 0,name:Ot[t.type]||`need handler for this type - ${t.type}`,type:t.type};switch(i.type){case 4:i.value=t.value.typesAndValues.map(e=>({name:Mt[e.type],oid:e.type,value:e.value.valueBlock.value}));break;case 7:i.value=_t.decodeIP(Ne.ToHex(t.value.valueBlock.valueHex));break;default:i.value="string"==typeof t.value?t.value:i.type}return i})}decode(t=!1){this.pem=_t.base64ToPem(this.base64);const i=new Ut({schema:this.schema});i.subject&&(Array.isArray(i.subject)&&(this.subject=_t.prepareSubject(i.subject)),Array.isArray(i.subject.typesAndValues)&&(this.subject=_t.prepareSubject(i.subject.typesAndValues))),i.issuer&&(Array.isArray(i.issuer)&&(this.issuer=_t.prepareSubject(i.issuer)),Array.isArray(i.issuer.typesAndValues)&&(this.issuer=_t.prepareSubject(i.issuer.typesAndValues))),this.isRoot=JSON.stringify(this.issuer)===JSON.stringify(this.subject),i.notBefore&&i.notBefore.value&&(this.notBefore=i.notBefore.value),i.notAfter&&i.notAfter.value&&(this.notAfter=i.notAfter.value),this.notAfter&&(this.validity=e(this.notAfter)),this.publicKey={algorithm:{name:""},value:Ne.ToHex(i.subjectPublicKeyInfo.subjectPublicKey.valueBeforeDecode).toLowerCase(),oid:i.subjectPublicKeyInfo.algorithm.algorithmId},i.subjectPublicKeyInfo.parsedKey&&("1.2.840.10045.2.1"===i.subjectPublicKeyInfo.algorithm.algorithmId?(this.publicKey.algorithm.name="EC",this.publicKey.algorithm.namedCurve=i.subjectPublicKeyInfo.toJSON().crv):(this.publicKey.algorithm.name="RSA","modulus"in i.subjectPublicKeyInfo.parsedKey&&(this.publicKey.algorithm.modulusBits=i.subjectPublicKeyInfo.parsedKey.modulus.valueBlock.valueHex.byteLength<<3),"publicExponent"in i.subjectPublicKeyInfo.parsedKey&&(this.publicKey.algorithm.publicExponent=3===i.subjectPublicKeyInfo.parsedKey.publicExponent.valueBlock.valueHex.byteLength?65537:3))),this.signature={algorithm:_t.prepareAlgorithm(i.signatureAlgorithm),value:Ne.ToHex(i.signatureValue.valueBlock.valueHex),oid:i.signatureAlgorithm.algorithmId},this.serialNumber=i.serialNumber?Ne.ToHex(i.serialNumber.valueBlock.valueHex):void 0,this.version=i.version,t&&i.extensions&&i.extensions.forEach(e=>{if(e.parsedValue instanceof ot)return this.extensions.push({name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.BasicConstraints,value:{cA:!1,pathLenConstraint:"number"==typeof e.parsedValue.pathLenConstraint?e.parsedValue.pathLenConstraint:void 0}});if(e.parsedValue instanceof gt){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.ExtendedKeyUsage,value:e.parsedValue.keyPurposes.map(e=>({oid:e,name:Mt[e]}))};return this.extensions.push(t)}if(e.parsedValue instanceof At){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.CertificatePolicies,value:e.parsedValue.certificatePolicies.map(e=>({oid:e.policyIdentifier,name:Mt[e.policyIdentifier]}))};return this.extensions.push(t)}if(e.parsedValue instanceof wt){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.AuthorityKeyIdentifier,value:{keyIdentifier:Ne.ToHex(e.parsedValue.keyIdentifier.valueBlock.valueHex),authorityCertSerialNumber:e.parsedValue.authorityCertSerialNumber?Ne.ToHex(e.parsedValue.authorityCertSerialNumber.valueBlock.valueHex):void 0}};return this.extensions.push(t)}if(e.parsedValue instanceof ft)return this.extensions.push({name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.CRLDistributionPoints,value:e.parsedValue.distributionPoints});if(e.parsedValue instanceof Pt)return this.extensions.push({name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.CertificateAuthorityInformationAccess,value:e.parsedValue.accessDescriptions});if(e.parsedValue instanceof at){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.SubjectAlternativeName,value:_t.decodeSANs(e.parsedValue.altNames)};return this.extensions.push(t)}if(e.parsedValue instanceof ut){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.NameConstraints,value:{permitted:_t.decodeSANs(e.parsedValue.permittedSubtrees||[]),excluded:_t.decodeSANs(e.parsedValue.excludedSubtrees||[])}};return this.extensions.push(t)}if(e.parsedValue instanceof _){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:e.extnID,value:Ne.ToHex(e.extnValue.valueBlock.valueHex)};return this.extensions.push(t)}if(e.extnID===Ft.KeyUsage){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.KeyUsage,value:_t.getExtensionKeyUsage(e)};return this.extensions.push(t)}if(e.extnID===Ft.NetscapeCertificateType){const t={name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.NetscapeCertificateType,value:_t.getExtensionNetscapeCertType(e)};return this.extensions.push(t)}if(e.extnID===Ft.CertificateTemplate)return this.extensions.push({name:Mt[e.extnID]||"",critical:e.critical,oid:Ft.CertificateTemplate,value:e.parsedValue});const t={name:Mt[e.extnID]||"",critical:e.critical,oid:e.extnID,value:Ne.ToHex(e.extnValue.valueBlock.valueHex)};this.extensions.push(t)})}get commonName(){if(this.name)return this.name;if(this.subject){if(this.subject.CN)return this.subject.CN.value;if(this.subject.E)return this.subject.E.value}}}export{_t as C,Ft as E};