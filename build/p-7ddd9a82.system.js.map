{"version":3,"names":["attributesParsers","_a","id_DomainNameBeneficiary","DomainNameBeneficiary","id_DomainNameLegalRepresentative","DomainNameLegalRepresentative","id_DomainNameOwner","DomainNameOwner","id_DomainNameTechnicalOperator","DomainNameTechnicalOperator","id_TypeRelationship","TypeRelationship","id_ActivityDescription","ActivityDescription","id_WebGDPR","WebGDPR","id_InsuranceValue","InsuranceValue","id_ValuationRanking","ValuationRanking","id_pkcs9_at_challengePassword","ChallengePassword","id_pkcs9_at_unstructuredName","UnstructuredName","id_pkcs9_at_extensionRequest","ExtensionRequest","__extends","Attribute","_super","raw","_this","call","this","AsnAttribute","asnExtnValue","getAsnExtnValue","target","asn","type","value","AsnParser","parse","console","warn","concat","Convert","ToHex","error","message","prototype","values","AsnData","Pkcs10CertificateRequest","certificateRawToBuffer","CertificationRequest","thumbprints","tag","certificationRequestInfo","subject","Name","toJSON","version","Object","defineProperty","subjectPKInfo","subjectPublicKey","algorithm","params","id_ecPublicKey","parameters","AsnConvert","ECParameters","id_rsaEncryption","RSAPublicKey","spki","serialize","signature","signatureAlgorithm","i","length","name","shortName","getThumbprint","getCertificateThumbprint","thumbprint","sent","error_1","parseAttributes","attributes","map","e","extensionRequestAttribute","find","attribute","extensions","Extension","toString","format","hexFormat","base64Format","ToBase64","downloadAsPEM","Download","csr","asPEM","commonName","downloadAsDER","asDER"],"sources":["src/crypto/attribute.ts","src/crypto/pkcs10_certificate_request.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) Peculiar Ventures, LLC.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { Convert } from 'pvtsutils';\nimport { AsnParser } from '@peculiar/asn1-schema';\nimport { Attribute as AsnAttribute } from '@peculiar/asn1-x509';\nimport {\n  id_DomainNameBeneficiary,\n  DomainNameBeneficiary,\n\n  id_DomainNameLegalRepresentative,\n  DomainNameLegalRepresentative,\n\n  id_DomainNameOwner,\n  DomainNameOwner,\n\n  id_DomainNameTechnicalOperator,\n  DomainNameTechnicalOperator,\n\n  id_TypeRelationship,\n  TypeRelationship,\n\n  id_ActivityDescription,\n  ActivityDescription,\n\n  id_WebGDPR,\n  WebGDPR,\n\n  id_InsuranceValue,\n  InsuranceValue,\n\n  id_ValuationRanking,\n  ValuationRanking,\n} from '@peculiar/asn1-ntqwac';\nimport {\n  id_pkcs9_at_extensionRequest,\n  ExtensionRequest,\n\n  id_pkcs9_at_challengePassword,\n  ChallengePassword,\n\n  id_pkcs9_at_unstructuredName,\n  UnstructuredName,\n} from '@peculiar/asn1-pkcs9';\n\nimport { AsnData } from './asn_data';\n\nconst attributesParsers = {\n  [id_DomainNameBeneficiary]: DomainNameBeneficiary,\n  [id_DomainNameLegalRepresentative]: DomainNameLegalRepresentative,\n  [id_DomainNameOwner]: DomainNameOwner,\n  [id_DomainNameTechnicalOperator]: DomainNameTechnicalOperator,\n  [id_TypeRelationship]: TypeRelationship,\n  [id_ActivityDescription]: ActivityDescription,\n  [id_WebGDPR]: WebGDPR,\n  [id_InsuranceValue]: InsuranceValue,\n  [id_ValuationRanking]: ValuationRanking,\n  [id_pkcs9_at_challengePassword]: ChallengePassword,\n  [id_pkcs9_at_unstructuredName]: UnstructuredName,\n  [id_pkcs9_at_extensionRequest]: ExtensionRequest,\n};\n\ntype TAttributeKeys = keyof typeof attributesParsers;\nexport type TAttributeValue = InstanceType<typeof attributesParsers[TAttributeKeys]> | string;\n\nexport class Attribute<T extends TAttributeValue> extends AsnData<AsnAttribute> {\n  public readonly value: T;\n\n  private getAsnExtnValue() {\n    return this.asn.values[0];\n  }\n\n  constructor(raw: BufferSource) {\n    super(raw, AsnAttribute);\n\n    const asnExtnValue = this.getAsnExtnValue();\n\n    try {\n      const target = attributesParsers[this.asn.type];\n\n      if (target) {\n        this.value = AsnParser.parse<T>(asnExtnValue, target);\n      } else {\n        console.warn(`Didn't detect parser for \"${this.asn.type}\" attribute.`);\n\n        this.value = Convert.ToHex(asnExtnValue) as T;\n      }\n    } catch (error) {\n      console.error(`Error parse \"${this.asn.type}\" attribute:`, error.message);\n\n      this.value = Convert.ToHex(asnExtnValue) as T;\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) Peculiar Ventures, LLC.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { AsnConvert } from '@peculiar/asn1-schema';\nimport { ECParameters, id_ecPublicKey } from '@peculiar/asn1-ecc';\nimport { id_rsaEncryption, RSAPublicKey } from '@peculiar/asn1-rsa';\nimport { CertificationRequest } from '@peculiar/asn1-csr';\nimport {\n  id_pkcs9_at_extensionRequest,\n  ExtensionRequest,\n} from '@peculiar/asn1-pkcs9';\nimport { Convert } from 'pvtsutils';\n\nimport { Download } from '../utils';\n\nimport { AsnData } from './asn_data';\nimport { Name, INameJSON } from './name';\nimport { Attribute, TAttributeValue } from './attribute';\nimport { Extension, TExtensionValue } from './extension';\nimport {\n  certificateRawToBuffer,\n  hexFormat,\n  base64Format,\n  getCertificateThumbprint,\n} from './utils';\n\ninterface ISignature {\n  algorithm: string;\n  value: BufferSource;\n}\n\ninterface IPublicKey {\n  algorithm: string;\n  value: BufferSource;\n  params?: ECParameters | RSAPublicKey;\n}\n\nexport class Pkcs10CertificateRequest extends AsnData<CertificationRequest> {\n  public readonly subject: INameJSON[];\n\n  public readonly version: number;\n\n  public attributes: Attribute<TAttributeValue>[];\n\n  public extensions: Extension<TExtensionValue>[];\n\n  public thumbprints: Record<string, string> = {};\n\n  public readonly type = 'PKCS#10 Certificate Request';\n\n  public readonly tag = 'CERTIFICATE REQUEST';\n\n  constructor(raw: string) {\n    super(certificateRawToBuffer(raw), CertificationRequest);\n\n    const { certificationRequestInfo } = this.asn;\n\n    this.subject = new Name(certificationRequestInfo.subject).toJSON();\n    this.version = certificationRequestInfo.version;\n  }\n\n  public get publicKey(): IPublicKey {\n    const { subjectPublicKey, algorithm } = this.asn.certificationRequestInfo.subjectPKInfo;\n    let params;\n\n    if (algorithm.algorithm === id_ecPublicKey && algorithm.parameters) {\n      params = AsnConvert.parse(algorithm.parameters, ECParameters);\n    }\n\n    if (algorithm.algorithm === id_rsaEncryption) {\n      params = AsnConvert.parse(subjectPublicKey, RSAPublicKey);\n    }\n\n    const spki = AsnConvert.serialize(this.asn.certificationRequestInfo.subjectPKInfo);\n\n    return {\n      params,\n      value: spki,\n      algorithm: algorithm.algorithm,\n    };\n  }\n\n  public get signature(): ISignature {\n    const { signature, signatureAlgorithm } = this.asn;\n\n    return {\n      value: signature,\n      algorithm: signatureAlgorithm.algorithm,\n    };\n  }\n\n  public get commonName(): string {\n    if (!this.subject) {\n      return '';\n    }\n\n    for (let i = 0; i < this.subject.length; i += 1) {\n      const name = this.subject[i];\n\n      if (name.shortName === 'CN' || name.shortName === 'E' || name.shortName === 'O') {\n        return name.value;\n      }\n    }\n\n    return '';\n  }\n\n  public async getThumbprint(\n    algorithm: string = 'SHA-1',\n  ): Promise<void> {\n    try {\n      const thumbprint = await getCertificateThumbprint(algorithm, this.raw);\n\n      if (thumbprint) {\n        this.thumbprints[algorithm] = Convert.ToHex(thumbprint);\n      }\n    } catch (error) {\n      console.error('Error thumbprint get:', error);\n    }\n  }\n\n  public parseAttributes() {\n    const { certificationRequestInfo } = this.asn;\n\n    if (certificationRequestInfo.attributes) {\n      this.attributes = certificationRequestInfo.attributes\n        .map((e) => new Attribute(AsnConvert.serialize(e)));\n\n      const extensionRequestAttribute = this.attributes.find(\n        (attribute) => attribute.asn.type === id_pkcs9_at_extensionRequest,\n      ) as Attribute<ExtensionRequest>;\n\n      if (extensionRequestAttribute) {\n        this.extensions = extensionRequestAttribute.value\n          .map((e) => new Extension(AsnConvert.serialize(e)));\n      }\n    }\n  }\n\n  public toString(format: 'hex' | 'pem' | 'base64' = 'pem'): string {\n    switch (format) {\n      case 'hex':\n        return hexFormat(Convert.ToHex(this.raw));\n      case 'pem':\n        return `-----BEGIN ${this.tag}-----\\n${base64Format(this.toString('base64'))}\\n-----END ${this.tag}-----`;\n      default:\n        return Convert.ToBase64(this.raw);\n    }\n  }\n\n  public downloadAsPEM(name?: string) {\n    Download.csr.asPEM(\n      this.toString('pem'),\n      name || this.commonName,\n    );\n  }\n\n  public downloadAsDER(name?: string) {\n    Download.csr.asDER(\n      this.raw,\n      name || this.commonName,\n    );\n  }\n}\n"],"mappings":"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"}